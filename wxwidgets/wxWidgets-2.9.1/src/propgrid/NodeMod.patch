Index: advprops.cpp
===================================================================
--- advprops.cpp	(revision 102)
+++ advprops.cpp	(working copy)
@@ -1,2235 +1,2235 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/advprops.cpp
-// Purpose:     wxPropertyGrid Advanced Properties (font, colour, etc.)
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2004-09-25
-// RCS-ID:      $Id: advprops.cpp 59837 2009-03-25 10:27:36Z VZ $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcclient.h"
-    #include "wx/button.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/cursor.h"
-    #include "wx/dialog.h"
-    #include "wx/settings.h"
-    #include "wx/msgdlg.h"
-    #include "wx/choice.h"
-    #include "wx/stattext.h"
-    #include "wx/textctrl.h"
-    #include "wx/scrolwin.h"
-    #include "wx/dirdlg.h"
-    #include "wx/combobox.h"
-    #include "wx/sizer.h"
-    #include "wx/textdlg.h"
-    #include "wx/filedlg.h"
-    #include "wx/intl.h"
-    #include "wx/wxcrtvararg.h"
-#endif
-
-#define __wxPG_SOURCE_FILE__
-
-#include "wx/propgrid/propgrid.h"
-
-#if wxPG_INCLUDE_ADVPROPS
-
-#include "wx/propgrid/advprops.h"
-
-#ifdef __WXMSW__
-    #include "wx/msw/private.h"
-    #include "wx/msw/dc.h"
-#endif
-
-// -----------------------------------------------------------------------
-
-#if defined(__WXMSW__)
-    #define wxPG_CAN_DRAW_CURSOR           1
-#elif defined(__WXGTK__)
-    #define wxPG_CAN_DRAW_CURSOR           0
-#elif defined(__WXMAC__)
-    #define wxPG_CAN_DRAW_CURSOR           0
-#else
-    #define wxPG_CAN_DRAW_CURSOR           0
-#endif
-
-
-// -----------------------------------------------------------------------
-// Value type related
-// -----------------------------------------------------------------------
-
-
-// Implement dynamic class for type value.
-IMPLEMENT_DYNAMIC_CLASS(wxColourPropertyValue, wxObject)
-
-bool operator == (const wxColourPropertyValue& a, const wxColourPropertyValue& b)
-{
-    return ( ( a.m_colour == b.m_colour ) && (a.m_type == b.m_type) );
-}
-
-bool operator == (const wxArrayInt& array1, const wxArrayInt& array2)
-{
-    if ( array1.size() != array2.size() )
-        return false;
-    size_t i;
-    for ( i=0; i<array1.size(); i++ )
-    {
-        if ( array1[i] != array2[i] )
-            return false;
-    }
-    return true;
-}
-
-// -----------------------------------------------------------------------
-// wxSpinCtrl-based property editor
-// -----------------------------------------------------------------------
-
-#if wxUSE_SPINBTN
-
-
-#ifdef __WXMSW__
-  #define IS_MOTION_SPIN_SUPPORTED  1
-#else
-  #define IS_MOTION_SPIN_SUPPORTED  0
-#endif
-
-#if IS_MOTION_SPIN_SUPPORTED
-
-//
-// This class implements ability to rapidly change "spin" value
-// by moving mouse when one of the spin buttons is depressed.
-class wxPGSpinButton : public wxSpinButton
-{
-public:
-    wxPGSpinButton() : wxSpinButton()
-    {
-        m_bLeftDown = false;
-        m_hasCapture = false;
-        m_spins = 1;
-
-        Connect( wxEVT_LEFT_DOWN,
-                 wxMouseEventHandler(wxPGSpinButton::OnMouseEvent) );
-        Connect( wxEVT_LEFT_UP,
-                 wxMouseEventHandler(wxPGSpinButton::OnMouseEvent) );
-        Connect( wxEVT_MOTION,
-                 wxMouseEventHandler(wxPGSpinButton::OnMouseEvent) );
-        Connect( wxEVT_MOUSE_CAPTURE_LOST,
-          wxMouseCaptureLostEventHandler(wxPGSpinButton::OnMouseCaptureLost) );
-    }
-
-    int GetSpins() const
-    {
-        return m_spins;
-    }
-
-private:
-    wxPoint m_ptPosition;
-
-    // Having a separate spins variable allows us to handle validation etc. for
-    // multiple spin events at once (with quick mouse movements there could be
-    // hundreds of 'spins' being done at once). Technically things like this
-    // should be stored in event (wxSpinEvent in this case), but there probably
-    // isn't anything there that can be reliably reused.
-    int     m_spins;
-
-    bool    m_bLeftDown;
-
-    // SpinButton seems to be a special for mouse capture, so we may need track
-    // privately whether mouse is actually captured.
-    bool    m_hasCapture;
-
-    void Capture()
-    {
-        if ( !m_hasCapture )
-        {
-            CaptureMouse();
-            m_hasCapture = true;
-        }
-
-        SetCursor(wxCURSOR_SIZENS);
-    }
-    void Release()
-    {
-        m_bLeftDown = false;
-
-        if ( m_hasCapture )
-        {
-            ReleaseMouse();
-            m_hasCapture = false;
-        }
-
-        wxWindow *parent = GetParent();
-        if ( parent )
-            SetCursor(parent->GetCursor());
-        else
-            SetCursor(wxNullCursor);
-    }
-
-    void OnMouseEvent(wxMouseEvent& event)
-    {
-        if ( event.GetEventType() == wxEVT_LEFT_DOWN )
-        {
-            m_bLeftDown = true;
-            m_ptPosition = event.GetPosition();
-        }
-        else if ( event.GetEventType() == wxEVT_LEFT_UP )
-        {
-            Release();
-            m_bLeftDown = false;
-        }
-        else if ( event.GetEventType() == wxEVT_MOTION )
-        {
-            if ( m_bLeftDown )
-            {
-                int dy = m_ptPosition.y - event.GetPosition().y;
-                if ( dy )
-                {
-                    Capture();
-                    m_ptPosition = event.GetPosition();
-
-                    wxSpinEvent evtscroll( (dy >= 0) ? wxEVT_SCROLL_LINEUP :
-                                                       wxEVT_SCROLL_LINEDOWN,
-                                           GetId() );
-                    evtscroll.SetEventObject(this);
-
-                    wxASSERT( m_spins == 1 );
-
-                    m_spins = abs(dy);
-                    GetEventHandler()->ProcessEvent(evtscroll);
-                    m_spins = 1;
-                }
-            }
-        }
-
-        event.Skip();
-    }
-    void OnMouseCaptureLost(wxMouseCaptureLostEvent& WXUNUSED(event))
-    {
-        Release();
-    }
-};
-
-#endif  // IS_MOTION_SPIN_SUPPORTED
-
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(SpinCtrl,
-                                      wxPGSpinCtrlEditor,
-                                      wxPGEditor)
-
-
-// Trivial destructor.
-wxPGSpinCtrlEditor::~wxPGSpinCtrlEditor()
-{
-}
-
-
-// Create controls and initialize event handling.
-wxPGWindowList wxPGSpinCtrlEditor::CreateControls( wxPropertyGrid* propgrid, wxPGProperty* property,
-                                                   const wxPoint& pos, const wxSize& sz ) const
-{
-    const int margin = 1;
-    wxSize butSz(18, sz.y);
-    wxSize tcSz(sz.x - butSz.x - margin, sz.y);
-    wxPoint butPos(pos.x + tcSz.x + margin, pos.y);
-
-    wxSpinButton* wnd2;
-
-#if IS_MOTION_SPIN_SUPPORTED
-    if ( property->GetAttributeAsLong(wxT("MotionSpin"), 0) )
-    {
-        wnd2 = new wxPGSpinButton();
-    }
-    else
-#endif
-    {
-        wnd2 = new wxSpinButton();
-    }
-
-#ifdef __WXMSW__
-    wnd2->Hide();
-#endif
-    wnd2->Create( propgrid->GetPanel(), wxPG_SUBID2, butPos, butSz, wxSP_VERTICAL );
-
-    wnd2->SetRange( INT_MIN, INT_MAX );
-    wnd2->SetValue( 0 );
-
-    // Let's add validator to make sure only numbers can be entered
-    wxTextValidator validator(wxFILTER_NUMERIC, &m_tempString);
-
-    wxTextCtrl* wnd1 = (wxTextCtrl*) wxPGTextCtrlEditor::CreateControls( propgrid, property, pos, tcSz ).m_primary;
-    wnd1->SetValidator(validator);
-
-    return wxPGWindowList(wnd1, wnd2);
-}
-
-// Control's events are redirected here
-bool wxPGSpinCtrlEditor::OnEvent( wxPropertyGrid* propgrid, wxPGProperty* property,
-                                  wxWindow* wnd, wxEvent& event ) const
-{
-    int evtType = event.GetEventType();
-    int keycode = -1;
-    int spins = 1;
-    bool bigStep = false;
-
-    if ( evtType == wxEVT_KEY_DOWN )
-    {
-        wxKeyEvent& keyEvent = (wxKeyEvent&)event;
-        keycode = keyEvent.GetKeyCode();
-
-        if ( keycode == WXK_UP )
-            evtType = wxEVT_SCROLL_LINEUP;
-        else if ( keycode == WXK_DOWN )
-            evtType = wxEVT_SCROLL_LINEDOWN;
-        else if ( keycode == WXK_PAGEUP )
-        {
-            evtType = wxEVT_SCROLL_LINEUP;
-            bigStep = true;
-        }
-        else if ( keycode == WXK_PAGEDOWN )
-        {
-            evtType = wxEVT_SCROLL_LINEDOWN;
-            bigStep = true;
-        }
-    }
-
-    if ( evtType == wxEVT_SCROLL_LINEUP || evtType == wxEVT_SCROLL_LINEDOWN )
-    {
-    #if IS_MOTION_SPIN_SUPPORTED
-        if ( property->GetAttributeAsLong(wxT("MotionSpin"), 0) )
-        {
-            wxPGSpinButton* spinButton =
-                (wxPGSpinButton*) propgrid->GetEditorControlSecondary();
-
-            if ( spinButton )
-                spins = spinButton->GetSpins();
-        }
-    #endif
-
-        wxString s;
-        // Can't use wnd since it might be clipper window
-        wxTextCtrl* tc = wxDynamicCast(propgrid->GetEditorControl(), wxTextCtrl);
-
-        if ( tc )
-            s = tc->GetValue();
-        else
-            s = property->GetValueAsString(wxPG_FULL_VALUE);
-
-        int mode = wxPG_PROPERTY_VALIDATION_SATURATE;
-
-        if ( property->GetAttributeAsLong(wxT("Wrap"), 0) )
-            mode = wxPG_PROPERTY_VALIDATION_WRAP;
-
-        if ( property->GetValueType() == wxT("double") )
-        {
-            double v_d;
-            double step = property->GetAttributeAsDouble(wxT("Step"), 1.0);
-
-            // Try double
-            if ( s.ToDouble(&v_d) )
-            {
-                if ( bigStep )
-                    step *= 10.0;
-
-                step *= (double) spins;
-
-                if ( evtType == wxEVT_SCROLL_LINEUP ) v_d += step;
-                else v_d -= step;
-
-                // Min/Max check
-                wxFloatProperty::DoValidation(property, v_d, NULL, mode);
-
-                wxPropertyGrid::DoubleToString(s, v_d, 6, true, NULL);
-            }
-            else
-            {
-                return false;
-            }
-        }
-        else
-        {
-            wxLongLong_t v_ll;
-            wxLongLong_t step = property->GetAttributeAsLong(wxT("Step"), 1);
-
-            // Try (long) long
-            if ( s.ToLongLong(&v_ll, 10) )
-            {
-                if ( bigStep )
-                    step *= 10;
-
-                step *= spins;
-
-                if ( evtType == wxEVT_SCROLL_LINEUP ) v_ll += step;
-                else v_ll -= step;
-
-                // Min/Max check
-                wxIntProperty::DoValidation(property, v_ll, NULL, mode);
-
-                s = wxLongLong(v_ll).ToString();
-            }
-            else
-            {
-                return false;
-            }
-        }
-
-        if ( tc )
-        {
-            int ip = tc->GetInsertionPoint();
-            int lp = tc->GetLastPosition();
-            tc->SetValue(s);
-            tc->SetInsertionPoint(ip+(tc->GetLastPosition()-lp));
-        }
-
-        return true;
-    }
-
-    return wxPGTextCtrlEditor::OnEvent(propgrid,property,wnd,event);
-}
-
-#endif // wxUSE_SPINBTN
-
-
-// -----------------------------------------------------------------------
-// wxDatePickerCtrl-based property editor
-// -----------------------------------------------------------------------
-
-#if wxUSE_DATEPICKCTRL
-
-
-#include "wx/datectrl.h"
-#include "wx/dateevt.h"
-
-class wxPGDatePickerCtrlEditor : public wxPGEditor
-{
-    DECLARE_DYNAMIC_CLASS(wxPGDatePickerCtrlEditor)
-public:
-    virtual ~wxPGDatePickerCtrlEditor();
-
-    wxString GetName() const;
-    virtual wxPGWindowList CreateControls(wxPropertyGrid* propgrid,
-                                          wxPGProperty* property,
-                                          const wxPoint& pos,
-                                          const wxSize& size) const;
-    virtual void UpdateControl( wxPGProperty* property, wxWindow* wnd ) const;
-    virtual bool OnEvent( wxPropertyGrid* propgrid, wxPGProperty* property,
-        wxWindow* wnd, wxEvent& event ) const;
-    virtual bool GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* wnd ) const;
-    virtual void SetValueToUnspecified( wxPGProperty* WXUNUSED(property), wxWindow* wnd ) const;
-};
-
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(DatePickerCtrl,
-                                      wxPGDatePickerCtrlEditor,
-                                      wxPGEditor)
-
-
-wxPGDatePickerCtrlEditor::~wxPGDatePickerCtrlEditor()
-{
-}
-
-wxPGWindowList wxPGDatePickerCtrlEditor::CreateControls( wxPropertyGrid* propgrid,
-                                                         wxPGProperty* property,
-                                                         const wxPoint& pos,
-                                                         const wxSize& sz ) const
-{
-    wxCHECK_MSG( property->IsKindOf(CLASSINFO(wxDateProperty)),
-                 NULL,
-                 wxT("DatePickerCtrl editor can only be used with wxDateProperty or derivative.") );
-
-    wxDateProperty* prop = wxDynamicCast(property, wxDateProperty);
-
-    // Use two stage creation to allow cleaner display on wxMSW
-    wxDatePickerCtrl* ctrl = new wxDatePickerCtrl();
-#ifdef __WXMSW__
-    ctrl->Hide();
-    wxSize useSz = wxDefaultSize;
-    useSz.x = sz.x;
-#else
-    wxSize useSz = sz;
-#endif
-
-    wxDateTime dateValue(wxInvalidDateTime);
-
-    wxVariant value = prop->GetValue();
-    if ( value.GetType() == wxT("datetime") )
-        dateValue = value.GetDateTime();
-
-    ctrl->Create(propgrid->GetPanel(),
-                 wxPG_SUBID1,
-                 dateValue,
-                 pos,
-                 useSz,
-                 prop->GetDatePickerStyle() | wxNO_BORDER);
-
-#ifdef __WXMSW__
-    ctrl->Show();
-#endif
-
-    return ctrl;
-}
-
-// Copies value from property to control
-void wxPGDatePickerCtrlEditor::UpdateControl( wxPGProperty* property,
-                                              wxWindow* wnd ) const
-{
-    wxDatePickerCtrl* ctrl = (wxDatePickerCtrl*) wnd;
-    wxASSERT( ctrl && ctrl->IsKindOf(CLASSINFO(wxDatePickerCtrl)) );
-
-    wxDateTime dateValue(wxInvalidDateTime);
-    wxVariant v(property->GetValue());
-    if ( v.GetType() == wxT("datetime") )
-        dateValue = v.GetDateTime();
-
-    ctrl->SetValue( dateValue );
-}
-
-// Control's events are redirected here
-bool wxPGDatePickerCtrlEditor::OnEvent( wxPropertyGrid* WXUNUSED(propgrid),
-                                        wxPGProperty* WXUNUSED(property),
-                                        wxWindow* WXUNUSED(wnd),
-                                        wxEvent& event ) const
-{
-    if ( event.GetEventType() == wxEVT_DATE_CHANGED )
-        return true;
-
-    return false;
-}
-
-bool wxPGDatePickerCtrlEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* WXUNUSED(property), wxWindow* wnd ) const
-{
-    wxDatePickerCtrl* ctrl = (wxDatePickerCtrl*) wnd;
-    wxASSERT( ctrl && ctrl->IsKindOf(CLASSINFO(wxDatePickerCtrl)) );
-
-    variant = ctrl->GetValue();
-
-    return true;
-}
-
-void wxPGDatePickerCtrlEditor::SetValueToUnspecified( wxPGProperty* property,
-                                                      wxWindow* wnd ) const
-{
-    wxDatePickerCtrl* ctrl = (wxDatePickerCtrl*) wnd;
-    wxASSERT( ctrl && ctrl->IsKindOf(CLASSINFO(wxDatePickerCtrl)) );
-
-    wxDateProperty* prop = wxDynamicCast(property, wxDateProperty);
-
-    if ( prop )
-    {
-        int datePickerStyle = prop->GetDatePickerStyle();
-        if ( datePickerStyle & wxDP_ALLOWNONE )
-            ctrl->SetValue(wxInvalidDateTime);
-    }
-}
-
-#endif // wxUSE_DATEPICKCTRL
-
-
-// -----------------------------------------------------------------------
-// wxFontProperty
-// -----------------------------------------------------------------------
-
-#include "wx/fontdlg.h"
-#include "wx/fontenum.h"
-
-static const wxChar* gs_fp_es_family_labels[] = {
-    wxT("Default"), wxT("Decorative"),
-    wxT("Roman"), wxT("Script"),
-    wxT("Swiss"), wxT("Modern"),
-    (const wxChar*) NULL
-};
-
-static long gs_fp_es_family_values[] = {
-    wxDEFAULT, wxDECORATIVE,
-    wxROMAN, wxSCRIPT,
-    wxSWISS, wxMODERN
-};
-
-static const wxChar* gs_fp_es_style_labels[] = {
-    wxT("Normal"),
-    wxT("Slant"),
-    wxT("Italic"),
-    (const wxChar*) NULL
-};
-
-static long gs_fp_es_style_values[] = {
-    wxNORMAL,
-    wxSLANT,
-    wxITALIC
-};
-
-static const wxChar* gs_fp_es_weight_labels[] = {
-    wxT("Normal"),
-    wxT("Light"),
-    wxT("Bold"),
-    (const wxChar*) NULL
-};
-
-static long gs_fp_es_weight_values[] = {
-    wxNORMAL,
-    wxLIGHT,
-    wxBOLD
-};
-
-// Class body is in advprops.h
-
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxFontProperty,wxPGProperty,
-                               wxFont,const wxFont&,TextCtrlAndButton)
-
-
-wxFontProperty::wxFontProperty( const wxString& label, const wxString& name,
-                                const wxFont& value )
-    : wxPGProperty(label,name)
-{
-    SetValue(WXVARIANT(value));
-
-    // Initialize font family choices list
-    if ( !wxPGGlobalVars->m_fontFamilyChoices )
-    {
-        wxArrayString faceNames = wxFontEnumerator::GetFacenames();
-
-        faceNames.Sort();
-
-        wxPGGlobalVars->m_fontFamilyChoices = new wxPGChoices(faceNames);
-    }
-
-    wxString emptyString(wxEmptyString);
-
-    wxFont font;
-    font << m_value;
-
-    AddPrivateChild( new wxIntProperty( _("Point Size"),
-                     wxS("Point Size"),(long)font.GetPointSize() ) );
-
-    AddPrivateChild( new wxEnumProperty(_("Family"), wxS("PointSize"),
-                     gs_fp_es_family_labels,gs_fp_es_family_values,
-                     font.GetFamily()) );
-
-    wxString faceName = font.GetFaceName();
-    // If font was not in there, add it now
-    if ( faceName.length() &&
-         wxPGGlobalVars->m_fontFamilyChoices->Index(faceName) == wxNOT_FOUND )
-        wxPGGlobalVars->m_fontFamilyChoices->AddAsSorted(faceName);
-
-    wxPGProperty* p = new wxEnumProperty(_("Face Name"), wxS("Face Name"),
-                                         *wxPGGlobalVars->m_fontFamilyChoices);
-
-    p->SetValueFromString(faceName, wxPG_FULL_VALUE);
-
-    AddPrivateChild( p );
-
-    AddPrivateChild( new wxEnumProperty(_("Style"), wxS("Style"),
-                     gs_fp_es_style_labels,gs_fp_es_style_values,
-                     font.GetStyle()) );
-
-    AddPrivateChild( new wxEnumProperty(_("Weight"), wxS("Weight"),
-                     gs_fp_es_weight_labels,gs_fp_es_weight_values,
-                     font.GetWeight()) );
-
-    AddPrivateChild( new wxBoolProperty(_("Underlined"), wxS("Underlined"),
-                     font.GetUnderlined()) );
-}
-
-wxFontProperty::~wxFontProperty() { }
-
-void wxFontProperty::OnSetValue()
-{
-    wxFont font;
-    font << m_value;
-
-    if ( !font.Ok() )
-    {
-        font = wxFont(10,wxSWISS,wxNORMAL,wxNORMAL);
-        m_value << font;
-    }
-}
-
-wxString wxFontProperty::ValueToString( wxVariant& value,
-                                        int argFlags ) const
-{
-    return wxPGProperty::ValueToString(value, argFlags);
-}
-
-bool wxFontProperty::OnEvent( wxPropertyGrid* propgrid, wxWindow* WXUNUSED(primary),
-                              wxEvent& event )
-{
-    if ( propgrid->IsMainButtonEvent(event) )
-    {
-        // Update value from last minute changes
-        wxVariant useValue = propgrid->GetUncommittedPropertyValue();
-
-        wxFontData data;
-        wxFont font;
-        font << useValue;
-        data.SetInitialFont( font );
-        data.SetColour(*wxBLACK);
-
-        wxFontDialog dlg(propgrid, data);
-        if ( dlg.ShowModal() == wxID_OK )
-        {
-            propgrid->EditorsValueWasModified();
-
-            wxVariant variant;
-            variant << dlg.GetFontData().GetChosenFont();
-            SetValueInEvent( variant );
-            return true;
-        }
-    }
-    return false;
-}
-
-void wxFontProperty::RefreshChildren()
-{
-    if ( !GetChildCount() ) return;
-    wxFont font;
-    font << m_value;
-    Item(0)->SetValue( (long)font.GetPointSize() );
-    Item(1)->SetValue( (long)font.GetFamily() );
-    Item(2)->SetValueFromString( font.GetFaceName(), wxPG_FULL_VALUE );
-    Item(3)->SetValue( (long)font.GetStyle() );
-    Item(4)->SetValue( (long)font.GetWeight() );
-    Item(5)->SetValue( font.GetUnderlined() );
-}
-
-void wxFontProperty::ChildChanged( wxVariant& thisValue, int ind, wxVariant& childValue ) const
-{
-    wxFont font;
-    font << thisValue;
-
-    if ( ind == 0 )
-    {
-        font.SetPointSize( wxPGVariantToInt(childValue) );
-    }
-    else if ( ind == 1 )
-    {
-        int fam = childValue.GetLong();
-        if ( fam < wxDEFAULT ||
-             fam > wxTELETYPE )
-             fam = wxDEFAULT;
-        font.SetFamily( fam );
-    }
-    else if ( ind == 2 )
-    {
-        wxString faceName;
-        int faceIndex = childValue.GetLong();
-
-        if ( faceIndex >= 0 )
-            faceName = wxPGGlobalVars->m_fontFamilyChoices->GetLabel(faceIndex);
-
-        font.SetFaceName( faceName );
-    }
-    else if ( ind == 3 )
-    {
-        int st = childValue.GetLong();
-        if ( st != wxFONTSTYLE_NORMAL &&
-             st != wxFONTSTYLE_SLANT &&
-             st != wxFONTSTYLE_ITALIC )
-             st = wxFONTWEIGHT_NORMAL;
-        font.SetStyle( st );
-    }
-    else if ( ind == 4 )
-    {
-        int wt = childValue.GetLong();
-        if ( wt != wxFONTWEIGHT_NORMAL &&
-             wt != wxFONTWEIGHT_LIGHT &&
-             wt != wxFONTWEIGHT_BOLD )
-             wt = wxFONTWEIGHT_NORMAL;
-        font.SetWeight( wt );
-    }
-    else if ( ind == 5 )
-    {
-        font.SetUnderlined( childValue.GetBool() );
-    }
-
-    thisValue << font;
-}
-
-/*
-wxSize wxFontProperty::OnMeasureImage() const
-{
-    return wxSize(-1,-1);
-}
-
-void wxFontProperty::OnCustomPaint(wxDC& dc,
-                                        const wxRect& rect,
-                                        wxPGPaintData& paintData)
-{
-    wxString drawFace;
-    if ( paintData.m_choiceItem >= 0 )
-        drawFace = wxPGGlobalVars->m_fontFamilyChoices->GetLabel(paintData.m_choiceItem);
-    else
-        drawFace = m_value_wxFont.GetFaceName();
-
-    if ( drawFace.length() )
-    {
-        // Draw the background
-        dc.SetBrush( wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE)) );
-        //dc.SetBrush( *wxWHITE_BRUSH );
-        //dc.SetPen( *wxMEDIUM_GREY_PEN );
-        dc.DrawRectangle( rect );
-
-        wxFont oldFont = dc.GetFont();
-        wxFont drawFont(oldFont.GetPointSize(),
-                        wxDEFAULT,wxNORMAL,wxBOLD,false,drawFace);
-        dc.SetFont(drawFont);
-
-        dc.SetTextForeground( wxSystemSettings::GetColour(wxSYS_COLOUR_BTNTEXT) );
-        dc.DrawText( wxT("Aa"), rect.x+2, rect.y+1 );
-
-        dc.SetFont(oldFont);
-    }
-    else
-    {
-        // No file - just draw a white box
-        dc.SetBrush ( *wxWHITE_BRUSH );
-        dc.DrawRectangle ( rect );
-    }
-}
-*/
-
-
-// -----------------------------------------------------------------------
-// wxSystemColourProperty
-// -----------------------------------------------------------------------
-
-// wxEnumProperty based classes cannot use wxPG_PROP_CLASS_SPECIFIC_1
-#define wxPG_PROP_HIDE_CUSTOM_COLOUR        wxPG_PROP_CLASS_SPECIFIC_2
-
-#include "wx/colordlg.h"
-
-//#define wx_cp_es_syscolours_len 25
-static const wxChar* gs_cp_es_syscolour_labels[] = {
-    wxT("AppWorkspace"),
-    wxT("ActiveBorder"),
-    wxT("ActiveCaption"),
-    wxT("ButtonFace"),
-    wxT("ButtonHighlight"),
-    wxT("ButtonShadow"),
-    wxT("ButtonText"),
-    wxT("CaptionText"),
-    wxT("ControlDark"),
-    wxT("ControlLight"),
-    wxT("Desktop"),
-    wxT("GrayText"),
-    wxT("Highlight"),
-    wxT("HighlightText"),
-    wxT("InactiveBorder"),
-    wxT("InactiveCaption"),
-    wxT("InactiveCaptionText"),
-    wxT("Menu"),
-    wxT("Scrollbar"),
-    wxT("Tooltip"),
-    wxT("TooltipText"),
-    wxT("Window"),
-    wxT("WindowFrame"),
-    wxT("WindowText"),
-    wxT("Custom"),
-    (const wxChar*) NULL
-};
-
-static long gs_cp_es_syscolour_values[] = {
-    wxSYS_COLOUR_APPWORKSPACE,
-    wxSYS_COLOUR_ACTIVEBORDER,
-    wxSYS_COLOUR_ACTIVECAPTION,
-    wxSYS_COLOUR_BTNFACE,
-    wxSYS_COLOUR_BTNHIGHLIGHT,
-    wxSYS_COLOUR_BTNSHADOW,
-    wxSYS_COLOUR_BTNTEXT ,
-    wxSYS_COLOUR_CAPTIONTEXT,
-    wxSYS_COLOUR_3DDKSHADOW,
-    wxSYS_COLOUR_3DLIGHT,
-    wxSYS_COLOUR_BACKGROUND,
-    wxSYS_COLOUR_GRAYTEXT,
-    wxSYS_COLOUR_HIGHLIGHT,
-    wxSYS_COLOUR_HIGHLIGHTTEXT,
-    wxSYS_COLOUR_INACTIVEBORDER,
-    wxSYS_COLOUR_INACTIVECAPTION,
-    wxSYS_COLOUR_INACTIVECAPTIONTEXT,
-    wxSYS_COLOUR_MENU,
-    wxSYS_COLOUR_SCROLLBAR,
-    wxSYS_COLOUR_INFOBK,
-    wxSYS_COLOUR_INFOTEXT,
-    wxSYS_COLOUR_WINDOW,
-    wxSYS_COLOUR_WINDOWFRAME,
-    wxSYS_COLOUR_WINDOWTEXT,
-    wxPG_COLOUR_CUSTOM
-};
-
-
-IMPLEMENT_VARIANT_OBJECT_EXPORTED_SHALLOWCMP(wxColourPropertyValue, WXDLLIMPEXP_PROPGRID)
-
-
-// Class body is in advprops.h
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxSystemColourProperty,wxEnumProperty,
-                               wxColourPropertyValue,const wxColourPropertyValue&,Choice)
-
-
-void wxSystemColourProperty::Init( int type, const wxColour& colour )
-{
-    wxColourPropertyValue cpv;
-
-    if ( colour.Ok() )
-        cpv.Init( type, colour );
-    else
-        cpv.Init( type, *wxWHITE );
-
-    m_flags |= wxPG_PROP_STATIC_CHOICES; // Colour selection cannot be changed.
-
-    m_value << cpv;
-
-    OnSetValue();
-}
-
-
-static wxPGChoices gs_wxSystemColourProperty_choicesCache;
-
-
-wxSystemColourProperty::wxSystemColourProperty( const wxString& label, const wxString& name,
-    const wxColourPropertyValue& value )
-    : wxEnumProperty( label,
-                      name,
-                      gs_cp_es_syscolour_labels,
-                      gs_cp_es_syscolour_values,
-                      &gs_wxSystemColourProperty_choicesCache )
-{
-    if ( &value )
-        Init( value.m_type, value.m_colour );
-    else
-        Init( wxPG_COLOUR_CUSTOM, *wxWHITE );
-}
-
-
-wxSystemColourProperty::wxSystemColourProperty( const wxString& label, const wxString& name,
-    const wxChar** labels, const long* values, wxPGChoices* choicesCache,
-    const wxColourPropertyValue& value )
-    : wxEnumProperty( label, name, labels, values, choicesCache )
-{
-    if ( &value )
-        Init( value.m_type, value.m_colour );
-    else
-        Init( wxPG_COLOUR_CUSTOM, *wxWHITE );
-}
-
-
-wxSystemColourProperty::wxSystemColourProperty( const wxString& label, const wxString& name,
-    const wxChar** labels, const long* values, wxPGChoices* choicesCache,
-    const wxColour& value )
-    : wxEnumProperty( label, name, labels, values, choicesCache )
-{
-    if ( &value )
-        Init( wxPG_COLOUR_CUSTOM, value );
-    else
-        Init( wxPG_COLOUR_CUSTOM, *wxWHITE );
-}
-
-
-wxSystemColourProperty::~wxSystemColourProperty() { }
-
-
-wxColourPropertyValue wxSystemColourProperty::GetVal( const wxVariant* pVariant ) const
-{
-    if ( !pVariant )
-        pVariant = &m_value;
-
-    if ( pVariant->IsNull() )
-        return wxColourPropertyValue(wxPG_COLOUR_UNSPECIFIED, wxColour());
-
-    if ( pVariant->GetType() == wxS("wxColourPropertyValue") )
-    {
-        wxColourPropertyValue v;
-        v << *pVariant;
-        return v;
-    }
-
-    wxColour col;
-    bool variantProcessed = true;
-
-    if ( pVariant->GetType() == wxS("wxColour*") )
-    {
-        wxColour* pCol = wxStaticCast(pVariant->GetWxObjectPtr(), wxColour);
-        col = *pCol;
-    }
-    else if ( pVariant->GetType() == wxS("wxColour") )
-    {
-        col << *pVariant;
-    }
-    else if ( pVariant->GetType() == wxArrayInt_VariantType )
-    {
-        // This code is mostly needed for wxPython bindings, which
-        // may offer tuple of integers as colour value.
-        wxArrayInt arr;
-        arr << *pVariant;
-
-        if ( arr.size() >= 3 )
-        {
-            int r, g, b;
-            int a = 255;
-
-            r = arr[0];
-            g = arr[1];
-            b = arr[2];
-            if ( arr.size() >= 4 )
-                a = arr[3];
-
-            col = wxColour(r, g, b, a);
-        }
-        else
-        {
-            variantProcessed = false;
-        }
-    }
-    else
-    {
-        variantProcessed = false;
-    }
-
-    if ( !variantProcessed )
-        return wxColourPropertyValue(wxPG_COLOUR_UNSPECIFIED, wxColour());
-
-    wxColourPropertyValue v2( wxPG_COLOUR_CUSTOM, col );
-
-    int colInd = ColToInd(col);
-    if ( colInd != wxNOT_FOUND )
-        v2.m_type = colInd;
-
-    return v2;
-}
-
-wxVariant wxSystemColourProperty::DoTranslateVal( wxColourPropertyValue& v ) const
-{
-    wxVariant variant;
-    variant << v;
-    return variant;
-}
-
-int wxSystemColourProperty::ColToInd( const wxColour& colour ) const
-{
-    size_t i;
-    size_t i_max = m_choices.GetCount() - 1;
-
-    for ( i=0; i<i_max; i++ )
-    {
-        int ind = m_choices[i].GetValue();
-
-        if ( colour == GetColour(ind) )
-        {
-            /*wxLogDebug(wxT("%s(%s): Index %i for ( getcolour(%i,%i,%i), colour(%i,%i,%i))"),
-                GetClassName(),GetLabel().c_str(),
-                (int)i,(int)GetColour(ind).Red(),(int)GetColour(ind).Green(),(int)GetColour(ind).Blue(),
-                (int)colour.Red(),(int)colour.Green(),(int)colour.Blue());*/
-            return ind;
-        }
-    }
-    return wxNOT_FOUND;
-}
-
-void wxSystemColourProperty::OnSetValue()
-{
-    // Convert from generic wxobject ptr to wxPGVariantDataColour
-    if ( m_value.GetType() == wxS("wxColour*") )
-    {
-        wxColour* pCol = wxStaticCast(m_value.GetWxObjectPtr(), wxColour);
-        m_value << *pCol;
-    }
-
-    wxColourPropertyValue val = GetVal(&m_value);
-
-    if ( val.m_type == wxPG_COLOUR_UNSPECIFIED )
-    {
-        m_value.MakeNull();
-        return;
-    }
-    else
-    {
-
-        if ( val.m_type < wxPG_COLOUR_WEB_BASE )
-            val.m_colour = GetColour( val.m_type );
-
-        m_value = TranslateVal(val);
-    }
-
-    int ind = wxNOT_FOUND;
-
-    if ( m_value.GetType() == wxS("wxColourPropertyValue") )
-    {
-        wxColourPropertyValue cpv;
-        cpv << m_value;
-        wxColour col = cpv.m_colour;
-
-        if ( !col.Ok() )
-        {
-            SetValueToUnspecified();
-            SetIndex(wxNOT_FOUND);
-            return;
-        }
-
-        if ( cpv.m_type < wxPG_COLOUR_WEB_BASE )
-        {
-            ind = GetIndexForValue(cpv.m_type);
-        }
-        else
-        {
-            cpv.m_type = wxPG_COLOUR_CUSTOM;
-            ind = GetCustomColourIndex();
-        }
-    }
-    else
-    {
-        wxColour col;
-        col << m_value;
-
-        if ( !col.Ok() )
-        {
-            SetValueToUnspecified();
-            SetIndex(wxNOT_FOUND);
-            return;
-        }
-
-        ind = ColToInd(col);
-
-        if ( ind == wxNOT_FOUND )
-            ind = GetCustomColourIndex();
-    }
-
-    SetIndex(ind);
-}
-
-
-wxColour wxSystemColourProperty::GetColour( int index ) const
-{
-    return wxSystemSettings::GetColour( (wxSystemColour)index );
-}
-
-wxString wxSystemColourProperty::ColourToString( const wxColour& col, int index ) const
-{
-    if ( index == wxNOT_FOUND )
-        return wxString::Format(wxT("(%i,%i,%i)"),
-                                (int)col.Red(),
-                                (int)col.Green(),
-                                (int)col.Blue());
-    else
-        return m_choices.GetLabel(index);
-}
-
-wxString wxSystemColourProperty::ValueToString( wxVariant& value,
-                                                int argFlags ) const
-{
-    wxColourPropertyValue val = GetVal(&value);
-
-    int index;
-
-    if ( argFlags & wxPG_VALUE_IS_CURRENT )
-    {
-        // GetIndex() only works reliably if wxPG_VALUE_IS_CURRENT flag is set,
-        // but we should use it whenever possible.
-        index = GetIndex();
-
-        // If custom colour was selected, use invalid index, so that
-        // ColourToString() will return properly formatted colour text.
-        if ( index == GetCustomColourIndex() )
-            index = wxNOT_FOUND;
-    }
-    else
-    {
-        index = m_choices.Index(val.m_type);
-    }
-
-    return ColourToString(val.m_colour, index);
-}
-
-
-wxSize wxSystemColourProperty::OnMeasureImage( int ) const
-{
-    return wxPG_DEFAULT_IMAGE_SIZE;
-}
-
-
-int wxSystemColourProperty::GetCustomColourIndex() const
-{
-    return m_choices.GetCount() - 1;
-}
-
-
-bool wxSystemColourProperty::QueryColourFromUser( wxVariant& variant ) const
-{
-    wxASSERT( m_value.GetType() != wxPG_VARIANT_TYPE_STRING );
-    bool res = false;
-
-    wxPropertyGrid* propgrid = GetGrid();
-    wxASSERT( propgrid );
-
-    // Must only occur when user triggers event
-    if ( !(propgrid->GetInternalFlags() & wxPG_FL_IN_HANDLECUSTOMEDITOREVENT) )
-        return res;
-
-    wxColourPropertyValue val = GetVal();
-
-    val.m_type = wxPG_COLOUR_CUSTOM;
-
-    wxColourData data;
-    data.SetChooseFull(true);
-    data.SetColour(val.m_colour);
-    int i;
-    for ( i = 0; i < 16; i++)
-    {
-        wxColour colour(i*16, i*16, i*16);
-        data.SetCustomColour(i, colour);
-    }
-
-    wxColourDialog dialog(propgrid, &data);
-    if ( dialog.ShowModal() == wxID_OK )
-    {
-        wxColourData retData = dialog.GetColourData();
-        val.m_colour = retData.GetColour();
-
-        variant = DoTranslateVal(val);
-
-        SetValueInEvent(variant);
-
-        res = true;
-    }
-
-    return res;
-}
-
-
-bool wxSystemColourProperty::IntToValue( wxVariant& variant, int number, int WXUNUSED(argFlags) ) const
-{
-    int index = number;
-    int type = m_choices.GetValue(index);
-
-    if ( type == wxPG_COLOUR_CUSTOM )
-    {
-        QueryColourFromUser(variant);
-    }
-    else
-    {
-        variant = TranslateVal( type, GetColour(type) );
-    }
-
-    return true;
-}
-
-// Need to do some extra event handling.
-bool wxSystemColourProperty::OnEvent( wxPropertyGrid* propgrid, wxWindow* WXUNUSED(primary), wxEvent& event )
-{
-    if ( propgrid->IsMainButtonEvent(event) )
-    {
-        // We need to handle button click in case editor has been
-        // switched to one that has wxButton as well.
-        wxVariant variant;
-        if ( QueryColourFromUser(variant) )
-            return true;
-    }
-    return false;
-}
-
-/*class wxPGColourPropertyRenderer : public wxPGDefaultRenderer
-{
-public:
-    virtual void Render( wxDC& dc, const wxRect& rect,
-                         const wxPropertyGrid* propertyGrid, wxPGProperty* property,
-                         int WXUNUSED(column), int item, int WXUNUSED(flags) ) const
-    {
-        wxASSERT( property->IsKindOf(CLASSINFO(wxSystemColourProperty)) );
-        wxSystemColourProperty* prop = wxStaticCast(property, wxSystemColourProperty);
-
-        dc.SetPen(*wxBLACK_PEN);
-        if ( item >= 0 &&
-             ( item < (int)(GetCustomColourIndex) || (prop->HasFlag(wxPG_PROP_HIDE_CUSTOM_COLOUR)))
-           )
-        {
-            int colInd;
-            const wxArrayInt& values = prop->GetValues();
-            if ( values.GetChildCount() )
-                colInd = values[item];
-            else
-                colInd = item;
-            dc.SetBrush( wxColour( prop->GetColour( colInd ) ) );
-        }
-        else if ( !prop->IsValueUnspecified() )
-            dc.SetBrush( prop->GetVal().m_colour );
-        else
-            dc.SetBrush( *wxWHITE );
-
-        wxRect imageRect = propertyGrid->GetImageRect(property, item);
-        wxLogDebug(wxT("%i, %i"),imageRect.x,imageRect.y);
-        dc.DrawRectangle( rect.x+imageRect.x, rect.y+imageRect.y,
-                          imageRect.width, imageRect.height );
-
-        wxString text;
-        if ( item == -1 )
-            text = property->GetValueAsString();
-        else
-            text = property->GetChoiceString(item);
-        DrawText( dc, rect, imageRect.width, text );
-    }
-protected:
-};
-
-wxPGColourPropertyRenderer g_wxPGColourPropertyRenderer;
-
-wxPGCellRenderer* wxSystemColourProperty::GetCellRenderer( int column ) const
-{
-    if ( column == 1 )
-        return &g_wxPGColourPropertyRenderer;
-    return wxEnumProperty::GetCellRenderer(column);
-}*/
-
-void wxSystemColourProperty::OnCustomPaint( wxDC& dc, const wxRect& rect,
-                                            wxPGPaintData& paintdata )
-{
-    wxColour col;
-
-    if ( paintdata.m_choiceItem >= 0 && paintdata.m_choiceItem < (int)m_choices.GetCount() &&
-         paintdata.m_choiceItem != GetCustomColourIndex() )
-    {
-        int colInd = m_choices[paintdata.m_choiceItem].GetValue();
-        col = GetColour( colInd );
-    }
-    else if ( !IsValueUnspecified() )
-    {
-        col = GetVal().m_colour;
-    }
-
-    if ( col.Ok() )
-    {
-        dc.SetBrush(col);
-        dc.DrawRectangle(rect);
-    }
-}
-
-
-bool wxSystemColourProperty::StringToValue( wxVariant& value, const wxString& text, int argFlags ) const
-{
-    //
-    // Accept colour format "[Name] [(R,G,B)]"
-    // Name takes precedence.
-    //
-    wxString colourName;
-    wxString colourRGB;
-
-    int ppos = text.Find(wxT("("));
-
-    if ( ppos == wxNOT_FOUND )
-    {
-        colourName = text;
-    }
-    else
-    {
-        colourName = text.substr(0, ppos);
-        colourRGB = text.substr(ppos, text.length()-ppos);
-    }
-
-    // Strip spaces from extremities
-    colourName.Trim(true);
-    colourName.Trim(false);
-    colourRGB.Trim(true);
-
-    // Validate colourRGB string - (1,1,1) is shortest allowed
-    if ( colourRGB.length() < 7 )
-        colourRGB.clear();
-
-    if ( colourRGB.length() == 0 && m_choices.GetCount() &&
-         colourName == m_choices.GetLabel(GetCustomColourIndex()) )
-    {
-        if ( !(argFlags & wxPG_EDITABLE_VALUE ))
-        {
-            // This really should not occurr...
-            // wxASSERT(false);
-            ResetNextIndex();
-            return false;
-        }
-
-        QueryColourFromUser(value);
-    }
-    else
-    {
-        wxColourPropertyValue val;
-
-        bool done = false;
-
-        if ( colourName.length() )
-        {
-            // Try predefined colour first
-            bool res = wxEnumProperty::StringToValue(value, colourName, argFlags);
-            if ( res && GetIndex() >= 0 )
-            {
-                val.m_type = GetIndex();
-                if ( val.m_type < m_choices.GetCount() )
-                    val.m_type = m_choices[val.m_type].GetValue();
-
-                // Get proper colour for type.
-                val.m_colour = GetColour(val.m_type);
-
-                done = true;
-            }
-        }
-        if ( colourRGB.length() && !done )
-        {
-            // Then check custom colour.
-            val.m_type = wxPG_COLOUR_CUSTOM;
-
-            int r = -1, g = -1, b = -1;
-            wxSscanf(colourRGB.c_str(),wxT("(%i,%i,%i)"),&r,&g,&b);
-
-            if ( r >= 0 && r <= 255 &&
-                 g >= 0 && g <= 255 &&
-                 b >= 0 && b <= 255 )
-            {
-                val.m_colour.Set(r,g,b);
-
-                done = true;
-            }
-        }
-
-        if ( !done )
-        {
-            ResetNextIndex();
-            return false;
-        }
-
-        value = DoTranslateVal(val);
-    }
-
-    return true;
-}
-
-
-bool wxSystemColourProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    if ( name == wxPG_COLOUR_ALLOW_CUSTOM )
-    {
-        int ival = wxPGVariantToInt(value);
-
-        if ( ival && (m_flags & wxPG_PROP_HIDE_CUSTOM_COLOUR) )
-        {
-            // Show custom choice
-            m_choices.Insert(wxT("Custom"), GetCustomColourIndex(), wxPG_COLOUR_CUSTOM);
-            m_flags &= ~(wxPG_PROP_HIDE_CUSTOM_COLOUR);
-        }
-        else if ( !ival && !(m_flags & wxPG_PROP_HIDE_CUSTOM_COLOUR) )
-        {
-            // Hide custom choice
-            m_choices.RemoveAt(GetCustomColourIndex());
-            m_flags |= wxPG_PROP_HIDE_CUSTOM_COLOUR;
-        }
-        return true;
-    }
-    return false;
-}
-
-
-// -----------------------------------------------------------------------
-// wxColourProperty
-// -----------------------------------------------------------------------
-
-static const wxChar* gs_cp_es_normcolour_labels[] = {
-    wxT("Black"),
-    wxT("Maroon"),
-    wxT("Navy"),
-    wxT("Purple"),
-    wxT("Teal"),
-    wxT("Gray"),
-    wxT("Green"),
-    wxT("Olive"),
-    wxT("Brown"),
-    wxT("Blue"),
-    wxT("Fuchsia"),
-    wxT("Red"),
-    wxT("Orange"),
-    wxT("Silver"),
-    wxT("Lime"),
-    wxT("Aqua"),
-    wxT("Yellow"),
-    wxT("White"),
-    wxT("Custom"),
-    (const wxChar*) NULL
-};
-
-static unsigned long gs_cp_es_normcolour_colours[] = {
-    wxPG_COLOUR(0,0,0),
-    wxPG_COLOUR(128,0,0),
-    wxPG_COLOUR(0,0,128),
-    wxPG_COLOUR(128,0,128),
-    wxPG_COLOUR(0,128,128),
-    wxPG_COLOUR(128,128,128),
-    wxPG_COLOUR(0,128,0),
-    wxPG_COLOUR(128,128,0),
-    wxPG_COLOUR(166,124,81),
-    wxPG_COLOUR(0,0,255),
-    wxPG_COLOUR(255,0,255),
-    wxPG_COLOUR(255,0,0),
-    wxPG_COLOUR(247,148,28),
-    wxPG_COLOUR(192,192,192),
-    wxPG_COLOUR(0,255,0),
-    wxPG_COLOUR(0,255,255),
-    wxPG_COLOUR(255,255,0),
-    wxPG_COLOUR(255,255,255),
-    wxPG_COLOUR(0,0,0)
-};
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxColourProperty, wxSystemColourProperty,
-                               wxColour, const wxColour&, TextCtrlAndButton)
-
-static wxPGChoices gs_wxColourProperty_choicesCache;
-
-wxColourProperty::wxColourProperty( const wxString& label,
-                      const wxString& name,
-                      const wxColour& value )
-    : wxSystemColourProperty(label, name, gs_cp_es_normcolour_labels,
-                             NULL,
-                             &gs_wxColourProperty_choicesCache, value )
-{
-    Init( value );
-
-    m_flags |= wxPG_PROP_TRANSLATE_CUSTOM;
-}
-
-wxColourProperty::~wxColourProperty()
-{
-}
-
-void wxColourProperty::Init( wxColour colour )
-{
-    if ( !colour.Ok() )
-        colour = *wxWHITE;
-    wxVariant variant;
-    variant << colour;
-    m_value = variant;
-    int ind = ColToInd(colour);
-    if ( ind < 0 )
-        ind = m_choices.GetCount() - 1;
-    SetIndex( ind );
-}
-
-wxString wxColourProperty::ValueToString( wxVariant& value,
-                                          int argFlags ) const
-{
-    const wxPGEditor* editor = GetEditorClass();
-    if ( editor != wxPGEditor_Choice &&
-         editor != wxPGEditor_ChoiceAndButton &&
-         editor != wxPGEditor_ComboBox )
-        argFlags |= wxPG_PROPERTY_SPECIFIC;
-
-    return wxSystemColourProperty::ValueToString(value, argFlags);
-}
-
-wxColour wxColourProperty::GetColour( int index ) const
-{
-    return gs_cp_es_normcolour_colours[m_choices.GetValue(index)];
-}
-
-wxVariant wxColourProperty::DoTranslateVal( wxColourPropertyValue& v ) const
-{
-    wxVariant variant;
-    variant << v.m_colour;
-    return variant;
-}
-
-// -----------------------------------------------------------------------
-// wxCursorProperty
-// -----------------------------------------------------------------------
-
-#define wxPG_CURSOR_IMAGE_WIDTH     32
-
-#define NUM_CURSORS 28
-
-//#define wx_cp_es_syscursors_len 28
-static const wxChar* gs_cp_es_syscursors_labels[NUM_CURSORS+1] = {
-    wxT("Default"),
-    wxT("Arrow"),
-    wxT("Right Arrow"),
-    wxT("Blank"),
-    wxT("Bullseye"),
-    wxT("Character"),
-    wxT("Cross"),
-    wxT("Hand"),
-    wxT("I-Beam"),
-    wxT("Left Button"),
-    wxT("Magnifier"),
-    wxT("Middle Button"),
-    wxT("No Entry"),
-    wxT("Paint Brush"),
-    wxT("Pencil"),
-    wxT("Point Left"),
-    wxT("Point Right"),
-    wxT("Question Arrow"),
-    wxT("Right Button"),
-    wxT("Sizing NE-SW"),
-    wxT("Sizing N-S"),
-    wxT("Sizing NW-SE"),
-    wxT("Sizing W-E"),
-    wxT("Sizing"),
-    wxT("Spraycan"),
-    wxT("Wait"),
-    wxT("Watch"),
-    wxT("Wait Arrow"),
-    (const wxChar*) NULL
-};
-
-static long gs_cp_es_syscursors_values[NUM_CURSORS] = {
-    wxCURSOR_NONE,
-    wxCURSOR_ARROW,
-    wxCURSOR_RIGHT_ARROW,
-    wxCURSOR_BLANK,
-    wxCURSOR_BULLSEYE,
-    wxCURSOR_CHAR,
-    wxCURSOR_CROSS,
-    wxCURSOR_HAND,
-    wxCURSOR_IBEAM,
-    wxCURSOR_LEFT_BUTTON,
-    wxCURSOR_MAGNIFIER,
-    wxCURSOR_MIDDLE_BUTTON,
-    wxCURSOR_NO_ENTRY,
-    wxCURSOR_PAINT_BRUSH,
-    wxCURSOR_PENCIL,
-    wxCURSOR_POINT_LEFT,
-    wxCURSOR_POINT_RIGHT,
-    wxCURSOR_QUESTION_ARROW,
-    wxCURSOR_RIGHT_BUTTON,
-    wxCURSOR_SIZENESW,
-    wxCURSOR_SIZENS,
-    wxCURSOR_SIZENWSE,
-    wxCURSOR_SIZEWE,
-    wxCURSOR_SIZING,
-    wxCURSOR_SPRAYCAN,
-    wxCURSOR_WAIT,
-    wxCURSOR_WATCH,
-    wxCURSOR_ARROWWAIT
-};
-
-IMPLEMENT_DYNAMIC_CLASS(wxCursorProperty, wxEnumProperty)
-
-wxCursorProperty::wxCursorProperty( const wxString& label, const wxString& name,
-    int value )
-    : wxEnumProperty( label,
-                      name,
-                      gs_cp_es_syscursors_labels,
-                      gs_cp_es_syscursors_values,
-                      value )
-{
-    m_flags |= wxPG_PROP_STATIC_CHOICES; // Cursor selection cannot be changed.
-}
-
-wxCursorProperty::~wxCursorProperty()
-{
-}
-
-wxSize wxCursorProperty::OnMeasureImage( int item ) const
-{
-#if wxPG_CAN_DRAW_CURSOR
-    if ( item != -1 && item < NUM_CURSORS )
-        return wxSize(wxPG_CURSOR_IMAGE_WIDTH,wxPG_CURSOR_IMAGE_WIDTH);
-#else
-    wxUnusedVar(item);
-#endif
-    return wxSize(0,0);
-}
-
-#if wxPG_CAN_DRAW_CURSOR
-
-void wxCursorProperty::OnCustomPaint( wxDC& dc,
-                                      const wxRect& rect,
-                                      wxPGPaintData& paintdata )
-{
-    // Background brush
-    dc.SetBrush( wxSystemSettings::GetColour( wxSYS_COLOUR_BTNFACE ) );
-
-    if ( paintdata.m_choiceItem >= 0 )
-    {
-        dc.DrawRectangle( rect );
-
-        if ( paintdata.m_choiceItem < NUM_CURSORS )
-        {
-            wxStockCursor cursorIndex =
-                (wxStockCursor) gs_cp_es_syscursors_values[paintdata.m_choiceItem];
-
-            {
-                if ( cursorIndex == wxCURSOR_NONE )
-                    cursorIndex = wxCURSOR_ARROW;
-
-                wxCursor cursor( cursorIndex );
-
-            #ifdef __WXMSW__
-                HDC hDc = (HDC)((const wxMSWDCImpl *)dc.GetImpl())->GetHDC();
-                ::DrawIconEx( hDc,
-                              rect.x,
-                              rect.y,
-                              (HICON)cursor.GetHandle(),
-                              0,
-                              0,
-                              0,
-                              NULL,
-            #if !defined(__WXWINCE__)
-                              DI_COMPAT | DI_DEFAULTSIZE |
-            #endif
-                              DI_NORMAL
-                            );
-            #endif
-            }
-        }
-    }
-}
-
-#else
-void wxCursorProperty::OnCustomPaint( wxDC&, const wxRect&, wxPGPaintData& ) { }
-/*wxPGCellRenderer* wxCursorProperty::GetCellRenderer( int column ) const
-{
-    return wxEnumProperty::GetCellRenderer(column);
-}*/
-#endif
-
-// -----------------------------------------------------------------------
-// wxImageFileProperty
-// -----------------------------------------------------------------------
-
-#if wxUSE_IMAGE
-
-const wxString& wxPGGetDefaultImageWildcard()
-{
-    // Form the wildcard, if not done yet
-    if ( !wxPGGlobalVars->m_pDefaultImageWildcard.length() )
-    {
-
-        wxString str;
-
-        // TODO: This section may require locking (using global).
-
-        wxList& handlers = wxImage::GetHandlers();
-
-        wxList::iterator node;
-
-        // Let's iterate over the image handler list.
-        //for ( wxList::Node *node = handlers.GetFirst(); node; node = node->GetNext() )
-        for ( node = handlers.begin(); node != handlers.end(); ++node )
-        {
-            wxImageHandler *handler = (wxImageHandler*)*node;
-
-            wxString ext_lo = handler->GetExtension();
-            wxString ext_up = ext_lo.Upper();
-
-            str.append( ext_up );
-            str.append( wxT(" files (*.") );
-            str.append( ext_up );
-            str.append( wxT(")|*.") );
-            str.append( ext_lo );
-            str.append( wxT("|") );
-        }
-
-        str.append ( wxT("All files (*.*)|*.*") );
-
-        wxPGGlobalVars->m_pDefaultImageWildcard = str;
-    }
-
-    return wxPGGlobalVars->m_pDefaultImageWildcard;
-}
-
-IMPLEMENT_DYNAMIC_CLASS(wxImageFileProperty, wxFileProperty)
-
-wxImageFileProperty::wxImageFileProperty( const wxString& label, const wxString& name,
-    const wxString& value )
-    : wxFileProperty(label,name,value)
-{
-    SetAttribute( wxPG_FILE_WILDCARD, wxPGGetDefaultImageWildcard() );
-
-    m_pImage = NULL;
-    m_pBitmap = NULL;
-}
-
-wxImageFileProperty::~wxImageFileProperty()
-{
-    if ( m_pBitmap )
-        delete m_pBitmap;
-    if ( m_pImage )
-        delete m_pImage;
-}
-
-void wxImageFileProperty::OnSetValue()
-{
-    wxFileProperty::OnSetValue();
-
-    // Delete old image
-    if ( m_pImage )
-    {
-        delete m_pImage;
-        m_pImage = NULL;
-    }
-    if ( m_pBitmap )
-    {
-        delete m_pBitmap;
-        m_pBitmap = NULL;
-    }
-
-    wxFileName filename = GetFileName();
-
-    // Create the image thumbnail
-    if ( filename.FileExists() )
-    {
-        m_pImage = new wxImage( filename.GetFullPath() );
-    }
-}
-
-wxSize wxImageFileProperty::OnMeasureImage( int ) const
-{
-    return wxPG_DEFAULT_IMAGE_SIZE;
-}
-
-void wxImageFileProperty::OnCustomPaint( wxDC& dc,
-                                         const wxRect& rect,
-                                         wxPGPaintData& )
-{
-    if ( m_pBitmap || (m_pImage && m_pImage->Ok() ) )
-    {
-        // Draw the thumbnail
-
-        // Create the bitmap here because required size is not known in OnSetValue().
-        if ( !m_pBitmap )
-        {
-            m_pImage->Rescale( rect.width, rect.height );
-            m_pBitmap = new wxBitmap( *m_pImage );
-            delete m_pImage;
-            m_pImage = NULL;
-        }
-
-        dc.DrawBitmap( *m_pBitmap, rect.x, rect.y, false );
-    }
-    else
-    {
-        // No file - just draw a white box
-        dc.SetBrush( *wxWHITE_BRUSH );
-        dc.DrawRectangle ( rect );
-    }
-}
-
-#endif // wxUSE_IMAGE
-
-// -----------------------------------------------------------------------
-// wxMultiChoiceProperty
-// -----------------------------------------------------------------------
-
-#if wxUSE_CHOICEDLG
-
-#include "wx/choicdlg.h"
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxMultiChoiceProperty,wxPGProperty,
-                               wxArrayInt,const wxArrayInt&,TextCtrlAndButton)
-
-wxMultiChoiceProperty::wxMultiChoiceProperty( const wxString& label,
-                                              const wxString& name,
-                                              const wxPGChoices& choices,
-                                              const wxArrayString& value)
-                                                : wxPGProperty(label,name)
-{
-    m_choices.Assign(choices);
-    SetValue(value);
-}
-
-wxMultiChoiceProperty::wxMultiChoiceProperty( const wxString& label,
-                                              const wxString& name,
-                                              const wxArrayString& strings,
-                                              const wxArrayString& value)
-                                                : wxPGProperty(label,name)
-{
-    m_choices.Set(strings);
-    SetValue(value);
-}
-
-wxMultiChoiceProperty::wxMultiChoiceProperty( const wxString& label,
-                                              const wxString& name,
-                                              const wxArrayString& value)
-                                                : wxPGProperty(label,name)
-{
-    wxArrayString strings;
-    m_choices.Set(strings);
-    SetValue(value);
-}
-
-wxMultiChoiceProperty::~wxMultiChoiceProperty()
-{
-}
-
-void wxMultiChoiceProperty::OnSetValue()
-{
-    GenerateValueAsString(m_value, &m_display);
-}
-
-wxString wxMultiChoiceProperty::ValueToString( wxVariant& value,
-                                               int argFlags ) const
-{
-    // If possible, use cached string
-    if ( argFlags & wxPG_VALUE_IS_CURRENT )
-        return m_display;
-
-    wxString s;
-    GenerateValueAsString(value, &s);
-    return s;
-}
-
-void wxMultiChoiceProperty::GenerateValueAsString( wxVariant& value,
-                                                   wxString* target ) const
-{
-    wxArrayString strings;
-
-    if ( value.GetType() == wxPG_VARIANT_TYPE_ARRSTRING )
-        strings = value.GetArrayString();
-
-    wxString& tempStr = *target;
-    unsigned int i;
-    unsigned int itemCount = strings.size();
-
-    tempStr.Empty();
-
-    if ( itemCount )
-        tempStr.append( wxT("\"") );
-
-    for ( i = 0; i < itemCount; i++ )
-    {
-        tempStr.append( strings[i] );
-        tempStr.append( wxT("\"") );
-        if ( i < (itemCount-1) )
-            tempStr.append ( wxT(" \"") );
-    }
-}
-
-wxArrayInt wxMultiChoiceProperty::GetValueAsIndices() const
-{
-    wxVariant variant = GetValue();
-    const wxArrayInt& valueArr = wxArrayIntRefFromVariant(variant);
-    unsigned int i;
-
-    // Translate values to string indices.
-    wxArrayInt selections;
-
-    if ( !m_choices.IsOk() || !m_choices.GetCount() || !(&valueArr) )
-    {
-        for ( i=0; i<valueArr.size(); i++ )
-            selections.Add(-1);
-    }
-    else
-    {
-        for ( i=0; i<valueArr.size(); i++ )
-        {
-            int sIndex = m_choices.Index(valueArr[i]);
-            if ( sIndex >= 0 )
-                selections.Add(sIndex);
-        }
-    }
-
-    return selections;
-}
-
-bool wxMultiChoiceProperty::OnEvent( wxPropertyGrid* propgrid,
-                                     wxWindow* WXUNUSED(primary),
-                                     wxEvent& event )
-{
-    if ( propgrid->IsMainButtonEvent(event) )
-    {
-        // Update the value
-        wxVariant useValue = propgrid->GetUncommittedPropertyValue();
-
-        wxArrayString labels = m_choices.GetLabels();
-        unsigned int choiceCount;
-
-        if ( m_choices.IsOk() )
-            choiceCount = m_choices.GetCount();
-        else
-            choiceCount = 0;
-
-        // launch editor dialog
-        wxMultiChoiceDialog dlg( propgrid,
-                                 _("Make a selection:"),
-                                 m_label,
-                                 choiceCount,
-                                 choiceCount?&labels[0]:NULL,
-                                 wxCHOICEDLG_STYLE );
-
-        dlg.Move( propgrid->GetGoodEditorDialogPosition(this,dlg.GetSize()) );
-
-        wxArrayString strings = useValue.GetArrayString();
-        wxArrayString extraStrings;
-
-        dlg.SetSelections(m_choices.GetIndicesForStrings(strings, &extraStrings));
-
-        if ( dlg.ShowModal() == wxID_OK && choiceCount )
-        {
-            int userStringMode = GetAttributeAsLong(wxT("UserStringMode"), 0);
-
-            wxArrayInt arrInt = dlg.GetSelections();
-
-            wxVariant variant;
-
-            // Strings that were not in list of choices
-            wxArrayString value;
-
-            // Translate string indices to strings
-
-            unsigned int n;
-            if ( userStringMode == 1 )
-            {
-                for (n=0;n<extraStrings.size();n++)
-                    value.push_back(extraStrings[n]);
-            }
-
-            unsigned int i;
-            for ( i=0; i<arrInt.size(); i++ )
-                value.Add(m_choices.GetLabel(arrInt.Item(i)));
-
-            if ( userStringMode == 2 )
-            {
-                for (n=0;n<extraStrings.size();n++)
-                    value.push_back(extraStrings[n]);
-            }
-
-            variant = WXVARIANT(value);
-
-            SetValueInEvent(variant);
-
-            return true;
-        }
-    }
-    return false;
-}
-
-bool wxMultiChoiceProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
-{
-    wxArrayString arr;
-
-    int userStringMode = GetAttributeAsLong(wxT("UserStringMode"), 0);
-
-    WX_PG_TOKENIZER2_BEGIN(text,wxT('"'))
-        if ( userStringMode > 0 || (m_choices.IsOk() && m_choices.Index( token ) != wxNOT_FOUND) )
-            arr.Add(token);
-    WX_PG_TOKENIZER2_END()
-
-    wxVariant v( WXVARIANT(arr) );
-    variant = v;
-
-    return true;
-}
-
-#endif // wxUSE_CHOICEDLG
-
-
-// -----------------------------------------------------------------------
-// wxDateProperty
-// -----------------------------------------------------------------------
-
-#if wxUSE_DATETIME
-
-
-#if wxUSE_DATEPICKCTRL
-    #define dtCtrl      DatePickerCtrl
-#else
-    #define dtCtrl      TextCtrl
-#endif
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxDateProperty,
-                               wxPGProperty,
-                               wxDateTime,
-                               const wxDateTime&,
-                               dtCtrl)
-
-
-wxString wxDateProperty::ms_defaultDateFormat;
-
-
-wxDateProperty::wxDateProperty( const wxString& label,
-                                const wxString& name,
-                                const wxDateTime& value )
-    : wxPGProperty(label,name)
-{
-    //wxPGRegisterDefaultValueType(wxDateTime)
-
-#if wxUSE_DATEPICKCTRL
-    wxPGRegisterEditorClass(DatePickerCtrl);
-
-    m_dpStyle = wxDP_DEFAULT | wxDP_SHOWCENTURY;
-#else
-    m_dpStyle = 0;
-#endif
-
-    SetValue( value );
-}
-
-wxDateProperty::~wxDateProperty()
-{
-}
-
-void wxDateProperty::OnSetValue()
-{
-    //
-    // Convert invalid dates to unspecified value
-    if ( m_value.GetType() == wxT("datetime") )
-    {
-        if ( !m_value.GetDateTime().IsValid() )
-            m_value.MakeNull();
-    }
-}
-
-bool wxDateProperty::StringToValue( wxVariant& variant, const wxString& text,
-                                    int WXUNUSED(argFlags) ) const
-{
-    wxDateTime dt;
-
-    // FIXME: do we really want to return true from here if only part of the
-    //        string was parsed?
-    const char* c = dt.ParseFormat(text);
-
-    if ( c )
-    {
-        variant = dt;
-        return true;
-    }
-
-    return false;
-}
-
-wxString wxDateProperty::ValueToString( wxVariant& value,
-                                        int argFlags ) const
-{
-    const wxChar* format = (const wxChar*) NULL;
-
-    wxDateTime dateTime = value.GetDateTime();
-
-    if ( !dateTime.IsValid() )
-        return wxT("Invalid");
-
-    if ( !ms_defaultDateFormat.length() )
-    {
-#if wxUSE_DATEPICKCTRL
-        bool showCentury = m_dpStyle & wxDP_SHOWCENTURY ? true : false;
-#else
-        bool showCentury = true;
-#endif
-        ms_defaultDateFormat = DetermineDefaultDateFormat( showCentury );
-    }
-
-    if ( m_format.length() &&
-         !(argFlags & wxPG_FULL_VALUE) )
-            format = m_format.c_str();
-
-    // Determine default from locale
-    // NB: This is really simple stuff, but can't figure anything
-    //     better without proper support in wxLocale
-    if ( !format )
-        format = ms_defaultDateFormat.c_str();
-
-    return dateTime.Format(format);
-}
-
-wxString wxDateProperty::DetermineDefaultDateFormat( bool showCentury )
-{
-    // This code is basicly copied from datectlg.cpp's SetFormat
-    //
-    wxString format;
-
-    wxDateTime dt;
-    dt.ParseFormat(wxT("2003-10-13"), wxT("%Y-%m-%d"));
-    wxString str(dt.Format(wxT("%x")));
-
-    const wxChar *p = str.c_str();
-    while ( *p )
-    {
-        int n=wxAtoi(p);
-        if (n == dt.GetDay())
-        {
-            format.Append(wxT("%d"));
-            p += 2;
-        }
-        else if (n == (int)dt.GetMonth()+1)
-        {
-            format.Append(wxT("%m"));
-            p += 2;
-        }
-        else if (n == dt.GetYear())
-        {
-            format.Append(wxT("%Y"));
-            p += 4;
-        }
-        else if (n == (dt.GetYear() % 100))
-        {
-            if (showCentury)
-                format.Append(wxT("%Y"));
-            else
-                format.Append(wxT("%y"));
-            p += 2;
-        }
-        else
-            format.Append(*p++);
-    }
-
-    return format;
-}
-
-bool wxDateProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    if ( name == wxPG_DATE_FORMAT )
-    {
-        m_format = value.GetString();
-        return true;
-    }
-    else if ( name == wxPG_DATE_PICKER_STYLE )
-    {
-        m_dpStyle = value.GetLong();
-        ms_defaultDateFormat.clear();  // This may need recalculation
-        return true;
-    }
-    return false;
-}
-
-#endif  // wxUSE_DATETIME
-
-
-// -----------------------------------------------------------------------
-// wxPropertyGridInterface
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::InitAllTypeHandlers()
-{
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::RegisterAdditionalEditors()
-{
-    // Register editor classes, if necessary.
-    if ( wxPGGlobalVars->m_mapEditorClasses.empty() )
-        wxPropertyGrid::RegisterDefaultEditors();
-
-#if wxUSE_SPINBTN
-    wxPGRegisterEditorClass(SpinCtrl);
-#endif
-#if wxUSE_DATEPICKCTRL
-    wxPGRegisterEditorClass(DatePickerCtrl);
-#endif
-}
-
-// -----------------------------------------------------------------------
-
-#endif  // wxPG_INCLUDE_ADVPROPS
-
-#endif  // wxUSE_PROPGRID
-
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/advprops.cpp
+// Purpose:     wxPropertyGrid Advanced Properties (font, colour, etc.)
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2004-09-25
+// RCS-ID:      $Id: advprops.cpp 59837 2009-03-25 10:27:36Z VZ $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcclient.h"
+    #include "wx/button.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/cursor.h"
+    #include "wx/dialog.h"
+    #include "wx/settings.h"
+    #include "wx/msgdlg.h"
+    #include "wx/choice.h"
+    #include "wx/stattext.h"
+    #include "wx/textctrl.h"
+    #include "wx/scrolwin.h"
+    #include "wx/dirdlg.h"
+    #include "wx/combobox.h"
+    #include "wx/sizer.h"
+    #include "wx/textdlg.h"
+    #include "wx/filedlg.h"
+    #include "wx/intl.h"
+    #include "wx/wxcrtvararg.h"
+#endif
+
+#define __wxPG_SOURCE_FILE__
+
+#include "wx/propgrid/propgrid.h"
+
+#if wxPG_INCLUDE_ADVPROPS
+
+#include "wx/propgrid/advprops.h"
+
+#ifdef __WXMSW__
+    #include "wx/msw/private.h"
+    #include "wx/msw/dc.h"
+#endif
+
+// -----------------------------------------------------------------------
+
+#if defined(__WXMSW__)
+    #define wxPG_CAN_DRAW_CURSOR           1
+#elif defined(__WXGTK__)
+    #define wxPG_CAN_DRAW_CURSOR           0
+#elif defined(__WXMAC__)
+    #define wxPG_CAN_DRAW_CURSOR           0
+#else
+    #define wxPG_CAN_DRAW_CURSOR           0
+#endif
+
+
+// -----------------------------------------------------------------------
+// Value type related
+// -----------------------------------------------------------------------
+
+
+// Implement dynamic class for type value.
+IMPLEMENT_DYNAMIC_CLASS(wxColourPropertyValue, wxObject)
+
+bool operator == (const wxColourPropertyValue& a, const wxColourPropertyValue& b)
+{
+    return ( ( a.m_colour == b.m_colour ) && (a.m_type == b.m_type) );
+}
+
+bool operator == (const wxArrayInt& array1, const wxArrayInt& array2)
+{
+    if ( array1.size() != array2.size() )
+        return false;
+    size_t i;
+    for ( i=0; i<array1.size(); i++ )
+    {
+        if ( array1[i] != array2[i] )
+            return false;
+    }
+    return true;
+}
+
+// -----------------------------------------------------------------------
+// wxSpinCtrl-based property editor
+// -----------------------------------------------------------------------
+
+#if wxUSE_SPINBTN
+
+
+#ifdef __WXMSW__
+  #define IS_MOTION_SPIN_SUPPORTED  1
+#else
+  #define IS_MOTION_SPIN_SUPPORTED  0
+#endif
+
+#if IS_MOTION_SPIN_SUPPORTED
+
+//
+// This class implements ability to rapidly change "spin" value
+// by moving mouse when one of the spin buttons is depressed.
+class wxPGSpinButton : public wxSpinButton
+{
+public:
+    wxPGSpinButton() : wxSpinButton()
+    {
+        m_bLeftDown = false;
+        m_hasCapture = false;
+        m_spins = 1;
+
+        Connect( wxEVT_LEFT_DOWN,
+                 wxMouseEventHandler(wxPGSpinButton::OnMouseEvent) );
+        Connect( wxEVT_LEFT_UP,
+                 wxMouseEventHandler(wxPGSpinButton::OnMouseEvent) );
+        Connect( wxEVT_MOTION,
+                 wxMouseEventHandler(wxPGSpinButton::OnMouseEvent) );
+        Connect( wxEVT_MOUSE_CAPTURE_LOST,
+          wxMouseCaptureLostEventHandler(wxPGSpinButton::OnMouseCaptureLost) );
+    }
+
+    int GetSpins() const
+    {
+        return m_spins;
+    }
+
+private:
+    wxPoint m_ptPosition;
+
+    // Having a separate spins variable allows us to handle validation etc. for
+    // multiple spin events at once (with quick mouse movements there could be
+    // hundreds of 'spins' being done at once). Technically things like this
+    // should be stored in event (wxSpinEvent in this case), but there probably
+    // isn't anything there that can be reliably reused.
+    int     m_spins;
+
+    bool    m_bLeftDown;
+
+    // SpinButton seems to be a special for mouse capture, so we may need track
+    // privately whether mouse is actually captured.
+    bool    m_hasCapture;
+
+    void Capture()
+    {
+        if ( !m_hasCapture )
+        {
+            CaptureMouse();
+            m_hasCapture = true;
+        }
+
+        SetCursor(wxCURSOR_SIZENS);
+    }
+    void Release()
+    {
+        m_bLeftDown = false;
+
+        if ( m_hasCapture )
+        {
+            ReleaseMouse();
+            m_hasCapture = false;
+        }
+
+        wxWindow *parent = GetParent();
+        if ( parent )
+            SetCursor(parent->GetCursor());
+        else
+            SetCursor(wxNullCursor);
+    }
+
+    void OnMouseEvent(wxMouseEvent& event)
+    {
+        if ( event.GetEventType() == wxEVT_LEFT_DOWN )
+        {
+            m_bLeftDown = true;
+            m_ptPosition = event.GetPosition();
+        }
+        else if ( event.GetEventType() == wxEVT_LEFT_UP )
+        {
+            Release();
+            m_bLeftDown = false;
+        }
+        else if ( event.GetEventType() == wxEVT_MOTION )
+        {
+            if ( m_bLeftDown )
+            {
+                int dy = m_ptPosition.y - event.GetPosition().y;
+                if ( dy )
+                {
+                    Capture();
+                    m_ptPosition = event.GetPosition();
+
+                    wxSpinEvent evtscroll( (dy >= 0) ? wxEVT_SCROLL_LINEUP :
+                                                       wxEVT_SCROLL_LINEDOWN,
+                                           GetId() );
+                    evtscroll.SetEventObject(this);
+
+                    wxASSERT( m_spins == 1 );
+
+                    m_spins = abs(dy);
+                    GetEventHandler()->ProcessEvent(evtscroll);
+                    m_spins = 1;
+                }
+            }
+        }
+
+        event.Skip();
+    }
+    void OnMouseCaptureLost(wxMouseCaptureLostEvent& WXUNUSED(event))
+    {
+        Release();
+    }
+};
+
+#endif  // IS_MOTION_SPIN_SUPPORTED
+
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(SpinCtrl,
+                                      wxPGSpinCtrlEditor,
+                                      wxPGEditor)
+
+
+// Trivial destructor.
+wxPGSpinCtrlEditor::~wxPGSpinCtrlEditor()
+{
+}
+
+
+// Create controls and initialize event handling.
+wxPGWindowList wxPGSpinCtrlEditor::CreateControls( wxPropertyGrid* propgrid, wxPGProperty* property,
+                                                   const wxPoint& pos, const wxSize& sz ) const
+{
+    const int margin = 1;
+    wxSize butSz(18, sz.y);
+    wxSize tcSz(sz.x - butSz.x - margin, sz.y);
+    wxPoint butPos(pos.x + tcSz.x + margin, pos.y);
+
+    wxSpinButton* wnd2;
+
+#if IS_MOTION_SPIN_SUPPORTED
+    if ( property->GetAttributeAsLong(wxT("MotionSpin"), 0) )
+    {
+        wnd2 = new wxPGSpinButton();
+    }
+    else
+#endif
+    {
+        wnd2 = new wxSpinButton();
+    }
+
+#ifdef __WXMSW__
+    wnd2->Hide();
+#endif
+    wnd2->Create( propgrid->GetPanel(), wxPG_SUBID2, butPos, butSz, wxSP_VERTICAL );
+
+    wnd2->SetRange( INT_MIN, INT_MAX );
+    wnd2->SetValue( 0 );
+
+    // Let's add validator to make sure only numbers can be entered
+    wxTextValidator validator(wxFILTER_NUMERIC, &m_tempString);
+
+    wxTextCtrl* wnd1 = (wxTextCtrl*) wxPGTextCtrlEditor::CreateControls( propgrid, property, pos, tcSz ).m_primary;
+    wnd1->SetValidator(validator);
+
+    return wxPGWindowList(wnd1, wnd2);
+}
+
+// Control's events are redirected here
+bool wxPGSpinCtrlEditor::OnEvent( wxPropertyGrid* propgrid, wxPGProperty* property,
+                                  wxWindow* wnd, wxEvent& event ) const
+{
+    int evtType = event.GetEventType();
+    int keycode = -1;
+    int spins = 1;
+    bool bigStep = false;
+
+    if ( evtType == wxEVT_KEY_DOWN )
+    {
+        wxKeyEvent& keyEvent = (wxKeyEvent&)event;
+        keycode = keyEvent.GetKeyCode();
+
+        if ( keycode == WXK_UP )
+            evtType = wxEVT_SCROLL_LINEUP;
+        else if ( keycode == WXK_DOWN )
+            evtType = wxEVT_SCROLL_LINEDOWN;
+        else if ( keycode == WXK_PAGEUP )
+        {
+            evtType = wxEVT_SCROLL_LINEUP;
+            bigStep = true;
+        }
+        else if ( keycode == WXK_PAGEDOWN )
+        {
+            evtType = wxEVT_SCROLL_LINEDOWN;
+            bigStep = true;
+        }
+    }
+
+    if ( evtType == wxEVT_SCROLL_LINEUP || evtType == wxEVT_SCROLL_LINEDOWN )
+    {
+    #if IS_MOTION_SPIN_SUPPORTED
+        if ( property->GetAttributeAsLong(wxT("MotionSpin"), 0) )
+        {
+            wxPGSpinButton* spinButton =
+                (wxPGSpinButton*) propgrid->GetEditorControlSecondary();
+
+            if ( spinButton )
+                spins = spinButton->GetSpins();
+        }
+    #endif
+
+        wxString s;
+        // Can't use wnd since it might be clipper window
+        wxTextCtrl* tc = wxDynamicCast(propgrid->GetEditorControl(), wxTextCtrl);
+
+        if ( tc )
+            s = tc->GetValue();
+        else
+            s = property->GetValueAsString(wxPG_FULL_VALUE);
+
+        int mode = wxPG_PROPERTY_VALIDATION_SATURATE;
+
+        if ( property->GetAttributeAsLong(wxT("Wrap"), 0) )
+            mode = wxPG_PROPERTY_VALIDATION_WRAP;
+
+        if ( property->GetValueType() == wxT("double") )
+        {
+            double v_d;
+            double step = property->GetAttributeAsDouble(wxT("Step"), 1.0);
+
+            // Try double
+            if ( s.ToDouble(&v_d) )
+            {
+                if ( bigStep )
+                    step *= 10.0;
+
+                step *= (double) spins;
+
+                if ( evtType == wxEVT_SCROLL_LINEUP ) v_d += step;
+                else v_d -= step;
+
+                // Min/Max check
+                wxFloatProperty::DoValidation(property, v_d, NULL, mode);
+
+                wxPropertyGrid::DoubleToString(s, v_d, 6, true, NULL);
+            }
+            else
+            {
+                return false;
+            }
+        }
+        else
+        {
+            wxLongLong_t v_ll;
+            wxLongLong_t step = property->GetAttributeAsLong(wxT("Step"), 1);
+
+            // Try (long) long
+            if ( s.ToLongLong(&v_ll, 10) )
+            {
+                if ( bigStep )
+                    step *= 10;
+
+                step *= spins;
+
+                if ( evtType == wxEVT_SCROLL_LINEUP ) v_ll += step;
+                else v_ll -= step;
+
+                // Min/Max check
+                wxIntProperty::DoValidation(property, v_ll, NULL, mode);
+
+                s = wxLongLong(v_ll).ToString();
+            }
+            else
+            {
+                return false;
+            }
+        }
+
+        if ( tc )
+        {
+            int ip = tc->GetInsertionPoint();
+            int lp = tc->GetLastPosition();
+            tc->SetValue(s);
+            tc->SetInsertionPoint(ip+(tc->GetLastPosition()-lp));
+        }
+
+        return true;
+    }
+
+    return wxPGTextCtrlEditor::OnEvent(propgrid,property,wnd,event);
+}
+
+#endif // wxUSE_SPINBTN
+
+
+// -----------------------------------------------------------------------
+// wxDatePickerCtrl-based property editor
+// -----------------------------------------------------------------------
+
+#if wxUSE_DATEPICKCTRL
+
+
+#include "wx/datectrl.h"
+#include "wx/dateevt.h"
+
+class wxPGDatePickerCtrlEditor : public wxPGEditor
+{
+    DECLARE_DYNAMIC_CLASS(wxPGDatePickerCtrlEditor)
+public:
+    virtual ~wxPGDatePickerCtrlEditor();
+
+    wxString GetName() const;
+    virtual wxPGWindowList CreateControls(wxPropertyGrid* propgrid,
+                                          wxPGProperty* property,
+                                          const wxPoint& pos,
+                                          const wxSize& size) const;
+    virtual void UpdateControl( wxPGProperty* property, wxWindow* wnd ) const;
+    virtual bool OnEvent( wxPropertyGrid* propgrid, wxPGProperty* property,
+        wxWindow* wnd, wxEvent& event ) const;
+    virtual bool GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* wnd ) const;
+    virtual void SetValueToUnspecified( wxPGProperty* WXUNUSED(property), wxWindow* wnd ) const;
+};
+
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(DatePickerCtrl,
+                                      wxPGDatePickerCtrlEditor,
+                                      wxPGEditor)
+
+
+wxPGDatePickerCtrlEditor::~wxPGDatePickerCtrlEditor()
+{
+}
+
+wxPGWindowList wxPGDatePickerCtrlEditor::CreateControls( wxPropertyGrid* propgrid,
+                                                         wxPGProperty* property,
+                                                         const wxPoint& pos,
+                                                         const wxSize& sz ) const
+{
+    wxCHECK_MSG( property->IsKindOf(CLASSINFO(wxDateProperty)),
+                 NULL,
+                 wxT("DatePickerCtrl editor can only be used with wxDateProperty or derivative.") );
+
+    wxDateProperty* prop = wxDynamicCast(property, wxDateProperty);
+
+    // Use two stage creation to allow cleaner display on wxMSW
+    wxDatePickerCtrl* ctrl = new wxDatePickerCtrl();
+#ifdef __WXMSW__
+    ctrl->Hide();
+    wxSize useSz = wxDefaultSize;
+    useSz.x = sz.x;
+#else
+    wxSize useSz = sz;
+#endif
+
+    wxDateTime dateValue(wxInvalidDateTime);
+
+    wxVariant value = prop->GetValue();
+    if ( value.GetType() == wxT("datetime") )
+        dateValue = value.GetDateTime();
+
+    ctrl->Create(propgrid->GetPanel(),
+                 wxPG_SUBID1,
+                 dateValue,
+                 pos,
+                 useSz,
+                 prop->GetDatePickerStyle() | wxNO_BORDER);
+
+#ifdef __WXMSW__
+    ctrl->Show();
+#endif
+
+    return ctrl;
+}
+
+// Copies value from property to control
+void wxPGDatePickerCtrlEditor::UpdateControl( wxPGProperty* property,
+                                              wxWindow* wnd ) const
+{
+    wxDatePickerCtrl* ctrl = (wxDatePickerCtrl*) wnd;
+    wxASSERT( ctrl && ctrl->IsKindOf(CLASSINFO(wxDatePickerCtrl)) );
+
+    wxDateTime dateValue(wxInvalidDateTime);
+    wxVariant v(property->GetValue());
+    if ( v.GetType() == wxT("datetime") )
+        dateValue = v.GetDateTime();
+
+    ctrl->SetValue( dateValue );
+}
+
+// Control's events are redirected here
+bool wxPGDatePickerCtrlEditor::OnEvent( wxPropertyGrid* WXUNUSED(propgrid),
+                                        wxPGProperty* WXUNUSED(property),
+                                        wxWindow* WXUNUSED(wnd),
+                                        wxEvent& event ) const
+{
+    if ( event.GetEventType() == wxEVT_DATE_CHANGED )
+        return true;
+
+    return false;
+}
+
+bool wxPGDatePickerCtrlEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* WXUNUSED(property), wxWindow* wnd ) const
+{
+    wxDatePickerCtrl* ctrl = (wxDatePickerCtrl*) wnd;
+    wxASSERT( ctrl && ctrl->IsKindOf(CLASSINFO(wxDatePickerCtrl)) );
+
+    variant = ctrl->GetValue();
+
+    return true;
+}
+
+void wxPGDatePickerCtrlEditor::SetValueToUnspecified( wxPGProperty* property,
+                                                      wxWindow* wnd ) const
+{
+    wxDatePickerCtrl* ctrl = (wxDatePickerCtrl*) wnd;
+    wxASSERT( ctrl && ctrl->IsKindOf(CLASSINFO(wxDatePickerCtrl)) );
+
+    wxDateProperty* prop = wxDynamicCast(property, wxDateProperty);
+
+    if ( prop )
+    {
+        int datePickerStyle = prop->GetDatePickerStyle();
+        if ( datePickerStyle & wxDP_ALLOWNONE )
+            ctrl->SetValue(wxInvalidDateTime);
+    }
+}
+
+#endif // wxUSE_DATEPICKCTRL
+
+
+// -----------------------------------------------------------------------
+// wxFontProperty
+// -----------------------------------------------------------------------
+
+#include "wx/fontdlg.h"
+#include "wx/fontenum.h"
+
+static const wxChar* gs_fp_es_family_labels[] = {
+    wxT("Default"), wxT("Decorative"),
+    wxT("Roman"), wxT("Script"),
+    wxT("Swiss"), wxT("Modern"),
+    (const wxChar*) NULL
+};
+
+static long gs_fp_es_family_values[] = {
+    wxDEFAULT, wxDECORATIVE,
+    wxROMAN, wxSCRIPT,
+    wxSWISS, wxMODERN
+};
+
+static const wxChar* gs_fp_es_style_labels[] = {
+    wxT("Normal"),
+    wxT("Slant"),
+    wxT("Italic"),
+    (const wxChar*) NULL
+};
+
+static long gs_fp_es_style_values[] = {
+    wxNORMAL,
+    wxSLANT,
+    wxITALIC
+};
+
+static const wxChar* gs_fp_es_weight_labels[] = {
+    wxT("Normal"),
+    wxT("Light"),
+    wxT("Bold"),
+    (const wxChar*) NULL
+};
+
+static long gs_fp_es_weight_values[] = {
+    wxNORMAL,
+    wxLIGHT,
+    wxBOLD
+};
+
+// Class body is in advprops.h
+
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxFontProperty,wxPGProperty,
+                               wxFont,const wxFont&,TextCtrlAndButton)
+
+
+wxFontProperty::wxFontProperty( const wxString& label, const wxString& name,
+                                const wxFont& value )
+    : wxPGProperty(label,name)
+{
+    SetValue(WXVARIANT(value));
+
+    // Initialize font family choices list
+    if ( !wxPGGlobalVars->m_fontFamilyChoices )
+    {
+        wxArrayString faceNames = wxFontEnumerator::GetFacenames();
+
+        faceNames.Sort();
+
+        wxPGGlobalVars->m_fontFamilyChoices = new wxPGChoices(faceNames);
+    }
+
+    wxString emptyString(wxEmptyString);
+
+    wxFont font;
+    font << m_value;
+
+    AddPrivateChild( new wxIntProperty( _("Point Size"),
+                     wxS("Point Size"),(long)font.GetPointSize() ) );
+
+    AddPrivateChild( new wxEnumProperty(_("Family"), wxS("PointSize"),
+                     gs_fp_es_family_labels,gs_fp_es_family_values,
+                     font.GetFamily()) );
+
+    wxString faceName = font.GetFaceName();
+    // If font was not in there, add it now
+    if ( faceName.length() &&
+         wxPGGlobalVars->m_fontFamilyChoices->Index(faceName) == wxNOT_FOUND )
+        wxPGGlobalVars->m_fontFamilyChoices->AddAsSorted(faceName);
+
+    wxPGProperty* p = new wxEnumProperty(_("Face Name"), wxS("Face Name"),
+                                         *wxPGGlobalVars->m_fontFamilyChoices);
+
+    p->SetValueFromString(faceName, wxPG_FULL_VALUE);
+
+    AddPrivateChild( p );
+
+    AddPrivateChild( new wxEnumProperty(_("Style"), wxS("Style"),
+                     gs_fp_es_style_labels,gs_fp_es_style_values,
+                     font.GetStyle()) );
+
+    AddPrivateChild( new wxEnumProperty(_("Weight"), wxS("Weight"),
+                     gs_fp_es_weight_labels,gs_fp_es_weight_values,
+                     font.GetWeight()) );
+
+    AddPrivateChild( new wxBoolProperty(_("Underlined"), wxS("Underlined"),
+                     font.GetUnderlined()) );
+}
+
+wxFontProperty::~wxFontProperty() { }
+
+void wxFontProperty::OnSetValue()
+{
+    wxFont font;
+    font << m_value;
+
+    if ( !font.Ok() )
+    {
+        font = wxFont(10,wxSWISS,wxNORMAL,wxNORMAL);
+        m_value << font;
+    }
+}
+
+wxString wxFontProperty::ValueToString( wxVariant& value,
+                                        int argFlags ) const
+{
+    return wxPGProperty::ValueToString(value, argFlags);
+}
+
+bool wxFontProperty::OnEvent( wxPropertyGrid* propgrid, wxWindow* WXUNUSED(primary),
+                              wxEvent& event )
+{
+    if ( propgrid->IsMainButtonEvent(event) )
+    {
+        // Update value from last minute changes
+        wxVariant useValue = propgrid->GetUncommittedPropertyValue();
+
+        wxFontData data;
+        wxFont font;
+        font << useValue;
+        data.SetInitialFont( font );
+        data.SetColour(*wxBLACK);
+
+        wxFontDialog dlg(propgrid, data);
+        if ( dlg.ShowModal() == wxID_OK )
+        {
+            propgrid->EditorsValueWasModified();
+
+            wxVariant variant;
+            variant << dlg.GetFontData().GetChosenFont();
+            SetValueInEvent( variant );
+            return true;
+        }
+    }
+    return false;
+}
+
+void wxFontProperty::RefreshChildren()
+{
+    if ( !GetChildCount() ) return;
+    wxFont font;
+    font << m_value;
+    Item(0)->SetValue( (long)font.GetPointSize() );
+    Item(1)->SetValue( (long)font.GetFamily() );
+    Item(2)->SetValueFromString( font.GetFaceName(), wxPG_FULL_VALUE );
+    Item(3)->SetValue( (long)font.GetStyle() );
+    Item(4)->SetValue( (long)font.GetWeight() );
+    Item(5)->SetValue( font.GetUnderlined() );
+}
+
+void wxFontProperty::ChildChanged( wxVariant& thisValue, int ind, wxVariant& childValue ) const
+{
+    wxFont font;
+    font << thisValue;
+
+    if ( ind == 0 )
+    {
+        font.SetPointSize( wxPGVariantToInt(childValue) );
+    }
+    else if ( ind == 1 )
+    {
+        int fam = childValue.GetLong();
+        if ( fam < wxDEFAULT ||
+             fam > wxTELETYPE )
+             fam = wxDEFAULT;
+        font.SetFamily( fam );
+    }
+    else if ( ind == 2 )
+    {
+        wxString faceName;
+        int faceIndex = childValue.GetLong();
+
+        if ( faceIndex >= 0 )
+            faceName = wxPGGlobalVars->m_fontFamilyChoices->GetLabel(faceIndex);
+
+        font.SetFaceName( faceName );
+    }
+    else if ( ind == 3 )
+    {
+        int st = childValue.GetLong();
+        if ( st != wxFONTSTYLE_NORMAL &&
+             st != wxFONTSTYLE_SLANT &&
+             st != wxFONTSTYLE_ITALIC )
+             st = wxFONTWEIGHT_NORMAL;
+        font.SetStyle( st );
+    }
+    else if ( ind == 4 )
+    {
+        int wt = childValue.GetLong();
+        if ( wt != wxFONTWEIGHT_NORMAL &&
+             wt != wxFONTWEIGHT_LIGHT &&
+             wt != wxFONTWEIGHT_BOLD )
+             wt = wxFONTWEIGHT_NORMAL;
+        font.SetWeight( wt );
+    }
+    else if ( ind == 5 )
+    {
+        font.SetUnderlined( childValue.GetBool() );
+    }
+
+    thisValue << font;
+}
+
+/*
+wxSize wxFontProperty::OnMeasureImage() const
+{
+    return wxSize(-1,-1);
+}
+
+void wxFontProperty::OnCustomPaint(wxDC& dc,
+                                        const wxRect& rect,
+                                        wxPGPaintData& paintData)
+{
+    wxString drawFace;
+    if ( paintData.m_choiceItem >= 0 )
+        drawFace = wxPGGlobalVars->m_fontFamilyChoices->GetLabel(paintData.m_choiceItem);
+    else
+        drawFace = m_value_wxFont.GetFaceName();
+
+    if ( drawFace.length() )
+    {
+        // Draw the background
+        dc.SetBrush( wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE)) );
+        //dc.SetBrush( *wxWHITE_BRUSH );
+        //dc.SetPen( *wxMEDIUM_GREY_PEN );
+        dc.DrawRectangle( rect );
+
+        wxFont oldFont = dc.GetFont();
+        wxFont drawFont(oldFont.GetPointSize(),
+                        wxDEFAULT,wxNORMAL,wxBOLD,false,drawFace);
+        dc.SetFont(drawFont);
+
+        dc.SetTextForeground( wxSystemSettings::GetColour(wxSYS_COLOUR_BTNTEXT) );
+        dc.DrawText( wxT("Aa"), rect.x+2, rect.y+1 );
+
+        dc.SetFont(oldFont);
+    }
+    else
+    {
+        // No file - just draw a white box
+        dc.SetBrush ( *wxWHITE_BRUSH );
+        dc.DrawRectangle ( rect );
+    }
+}
+*/
+
+
+// -----------------------------------------------------------------------
+// wxSystemColourProperty
+// -----------------------------------------------------------------------
+
+// wxEnumProperty based classes cannot use wxPG_PROP_CLASS_SPECIFIC_1
+#define wxPG_PROP_HIDE_CUSTOM_COLOUR        wxPG_PROP_CLASS_SPECIFIC_2
+
+#include "wx/colordlg.h"
+
+//#define wx_cp_es_syscolours_len 25
+static const wxChar* gs_cp_es_syscolour_labels[] = {
+    wxT("AppWorkspace"),
+    wxT("ActiveBorder"),
+    wxT("ActiveCaption"),
+    wxT("ButtonFace"),
+    wxT("ButtonHighlight"),
+    wxT("ButtonShadow"),
+    wxT("ButtonText"),
+    wxT("CaptionText"),
+    wxT("ControlDark"),
+    wxT("ControlLight"),
+    wxT("Desktop"),
+    wxT("GrayText"),
+    wxT("Highlight"),
+    wxT("HighlightText"),
+    wxT("InactiveBorder"),
+    wxT("InactiveCaption"),
+    wxT("InactiveCaptionText"),
+    wxT("Menu"),
+    wxT("Scrollbar"),
+    wxT("Tooltip"),
+    wxT("TooltipText"),
+    wxT("Window"),
+    wxT("WindowFrame"),
+    wxT("WindowText"),
+    wxT("Custom"),
+    (const wxChar*) NULL
+};
+
+static long gs_cp_es_syscolour_values[] = {
+    wxSYS_COLOUR_APPWORKSPACE,
+    wxSYS_COLOUR_ACTIVEBORDER,
+    wxSYS_COLOUR_ACTIVECAPTION,
+    wxSYS_COLOUR_BTNFACE,
+    wxSYS_COLOUR_BTNHIGHLIGHT,
+    wxSYS_COLOUR_BTNSHADOW,
+    wxSYS_COLOUR_BTNTEXT ,
+    wxSYS_COLOUR_CAPTIONTEXT,
+    wxSYS_COLOUR_3DDKSHADOW,
+    wxSYS_COLOUR_3DLIGHT,
+    wxSYS_COLOUR_BACKGROUND,
+    wxSYS_COLOUR_GRAYTEXT,
+    wxSYS_COLOUR_HIGHLIGHT,
+    wxSYS_COLOUR_HIGHLIGHTTEXT,
+    wxSYS_COLOUR_INACTIVEBORDER,
+    wxSYS_COLOUR_INACTIVECAPTION,
+    wxSYS_COLOUR_INACTIVECAPTIONTEXT,
+    wxSYS_COLOUR_MENU,
+    wxSYS_COLOUR_SCROLLBAR,
+    wxSYS_COLOUR_INFOBK,
+    wxSYS_COLOUR_INFOTEXT,
+    wxSYS_COLOUR_WINDOW,
+    wxSYS_COLOUR_WINDOWFRAME,
+    wxSYS_COLOUR_WINDOWTEXT,
+    wxPG_COLOUR_CUSTOM
+};
+
+
+IMPLEMENT_VARIANT_OBJECT_EXPORTED_SHALLOWCMP(wxColourPropertyValue, WXDLLIMPEXP_PROPGRID)
+
+
+// Class body is in advprops.h
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxSystemColourProperty,wxEnumProperty,
+                               wxColourPropertyValue,const wxColourPropertyValue&,Choice)
+
+
+void wxSystemColourProperty::Init( int type, const wxColour& colour )
+{
+    wxColourPropertyValue cpv;
+
+    if ( colour.Ok() )
+        cpv.Init( type, colour );
+    else
+        cpv.Init( type, *wxWHITE );
+
+    m_flags |= wxPG_PROP_STATIC_CHOICES; // Colour selection cannot be changed.
+
+    m_value << cpv;
+
+    OnSetValue();
+}
+
+
+static wxPGChoices gs_wxSystemColourProperty_choicesCache;
+
+
+wxSystemColourProperty::wxSystemColourProperty( const wxString& label, const wxString& name,
+    const wxColourPropertyValue& value )
+    : wxEnumProperty( label,
+                      name,
+                      gs_cp_es_syscolour_labels,
+                      gs_cp_es_syscolour_values,
+                      &gs_wxSystemColourProperty_choicesCache )
+{
+    if ( &value )
+        Init( value.m_type, value.m_colour );
+    else
+        Init( wxPG_COLOUR_CUSTOM, *wxWHITE );
+}
+
+
+wxSystemColourProperty::wxSystemColourProperty( const wxString& label, const wxString& name,
+    const wxChar** labels, const long* values, wxPGChoices* choicesCache,
+    const wxColourPropertyValue& value )
+    : wxEnumProperty( label, name, labels, values, choicesCache )
+{
+    if ( &value )
+        Init( value.m_type, value.m_colour );
+    else
+        Init( wxPG_COLOUR_CUSTOM, *wxWHITE );
+}
+
+
+wxSystemColourProperty::wxSystemColourProperty( const wxString& label, const wxString& name,
+    const wxChar** labels, const long* values, wxPGChoices* choicesCache,
+    const wxColour& value )
+    : wxEnumProperty( label, name, labels, values, choicesCache )
+{
+    if ( &value )
+        Init( wxPG_COLOUR_CUSTOM, value );
+    else
+        Init( wxPG_COLOUR_CUSTOM, *wxWHITE );
+}
+
+
+wxSystemColourProperty::~wxSystemColourProperty() { }
+
+
+wxColourPropertyValue wxSystemColourProperty::GetVal( const wxVariant* pVariant ) const
+{
+    if ( !pVariant )
+        pVariant = &m_value;
+
+    if ( pVariant->IsNull() )
+        return wxColourPropertyValue(wxPG_COLOUR_UNSPECIFIED, wxColour());
+
+    if ( pVariant->GetType() == wxS("wxColourPropertyValue") )
+    {
+        wxColourPropertyValue v;
+        v << *pVariant;
+        return v;
+    }
+
+    wxColour col;
+    bool variantProcessed = true;
+
+    if ( pVariant->GetType() == wxS("wxColour*") )
+    {
+        wxColour* pCol = wxStaticCast(pVariant->GetWxObjectPtr(), wxColour);
+        col = *pCol;
+    }
+    else if ( pVariant->GetType() == wxS("wxColour") )
+    {
+        col << *pVariant;
+    }
+    else if ( pVariant->GetType() == wxArrayInt_VariantType )
+    {
+        // This code is mostly needed for wxPython bindings, which
+        // may offer tuple of integers as colour value.
+        wxArrayInt arr;
+        arr << *pVariant;
+
+        if ( arr.size() >= 3 )
+        {
+            int r, g, b;
+            int a = 255;
+
+            r = arr[0];
+            g = arr[1];
+            b = arr[2];
+            if ( arr.size() >= 4 )
+                a = arr[3];
+
+            col = wxColour(r, g, b, a);
+        }
+        else
+        {
+            variantProcessed = false;
+        }
+    }
+    else
+    {
+        variantProcessed = false;
+    }
+
+    if ( !variantProcessed )
+        return wxColourPropertyValue(wxPG_COLOUR_UNSPECIFIED, wxColour());
+
+    wxColourPropertyValue v2( wxPG_COLOUR_CUSTOM, col );
+
+    int colInd = ColToInd(col);
+    if ( colInd != wxNOT_FOUND )
+        v2.m_type = colInd;
+
+    return v2;
+}
+
+wxVariant wxSystemColourProperty::DoTranslateVal( wxColourPropertyValue& v ) const
+{
+    wxVariant variant;
+    variant << v;
+    return variant;
+}
+
+int wxSystemColourProperty::ColToInd( const wxColour& colour ) const
+{
+    size_t i;
+    size_t i_max = m_choices.GetCount() - 1;
+
+    for ( i=0; i<i_max; i++ )
+    {
+        int ind = m_choices[i].GetValue();
+
+        if ( colour == GetColour(ind) )
+        {
+            /*wxLogDebug(wxT("%s(%s): Index %i for ( getcolour(%i,%i,%i), colour(%i,%i,%i))"),
+                GetClassName(),GetLabel().c_str(),
+                (int)i,(int)GetColour(ind).Red(),(int)GetColour(ind).Green(),(int)GetColour(ind).Blue(),
+                (int)colour.Red(),(int)colour.Green(),(int)colour.Blue());*/
+            return ind;
+        }
+    }
+    return wxNOT_FOUND;
+}
+
+void wxSystemColourProperty::OnSetValue()
+{
+    // Convert from generic wxobject ptr to wxPGVariantDataColour
+    if ( m_value.GetType() == wxS("wxColour*") )
+    {
+        wxColour* pCol = wxStaticCast(m_value.GetWxObjectPtr(), wxColour);
+        m_value << *pCol;
+    }
+
+    wxColourPropertyValue val = GetVal(&m_value);
+
+    if ( val.m_type == wxPG_COLOUR_UNSPECIFIED )
+    {
+        m_value.MakeNull();
+        return;
+    }
+    else
+    {
+
+        if ( val.m_type < wxPG_COLOUR_WEB_BASE )
+            val.m_colour = GetColour( val.m_type );
+
+        m_value = TranslateVal(val);
+    }
+
+    int ind = wxNOT_FOUND;
+
+    if ( m_value.GetType() == wxS("wxColourPropertyValue") )
+    {
+        wxColourPropertyValue cpv;
+        cpv << m_value;
+        wxColour col = cpv.m_colour;
+
+        if ( !col.Ok() )
+        {
+            SetValueToUnspecified();
+            SetIndex(wxNOT_FOUND);
+            return;
+        }
+
+        if ( cpv.m_type < wxPG_COLOUR_WEB_BASE )
+        {
+            ind = GetIndexForValue(cpv.m_type);
+        }
+        else
+        {
+            cpv.m_type = wxPG_COLOUR_CUSTOM;
+            ind = GetCustomColourIndex();
+        }
+    }
+    else
+    {
+        wxColour col;
+        col << m_value;
+
+        if ( !col.Ok() )
+        {
+            SetValueToUnspecified();
+            SetIndex(wxNOT_FOUND);
+            return;
+        }
+
+        ind = ColToInd(col);
+
+        if ( ind == wxNOT_FOUND )
+            ind = GetCustomColourIndex();
+    }
+
+    SetIndex(ind);
+}
+
+
+wxColour wxSystemColourProperty::GetColour( int index ) const
+{
+    return wxSystemSettings::GetColour( (wxSystemColour)index );
+}
+
+wxString wxSystemColourProperty::ColourToString( const wxColour& col, int index ) const
+{
+    if ( index == wxNOT_FOUND )
+        return wxString::Format(wxT("(%i,%i,%i)"),
+                                (int)col.Red(),
+                                (int)col.Green(),
+                                (int)col.Blue());
+    else
+        return m_choices.GetLabel(index);
+}
+
+wxString wxSystemColourProperty::ValueToString( wxVariant& value,
+                                                int argFlags ) const
+{
+    wxColourPropertyValue val = GetVal(&value);
+
+    int index;
+
+    if ( argFlags & wxPG_VALUE_IS_CURRENT )
+    {
+        // GetIndex() only works reliably if wxPG_VALUE_IS_CURRENT flag is set,
+        // but we should use it whenever possible.
+        index = GetIndex();
+
+        // If custom colour was selected, use invalid index, so that
+        // ColourToString() will return properly formatted colour text.
+        if ( index == GetCustomColourIndex() )
+            index = wxNOT_FOUND;
+    }
+    else
+    {
+        index = m_choices.Index(val.m_type);
+    }
+
+    return ColourToString(val.m_colour, index);
+}
+
+
+wxSize wxSystemColourProperty::OnMeasureImage( int ) const
+{
+    return wxPG_DEFAULT_IMAGE_SIZE;
+}
+
+
+int wxSystemColourProperty::GetCustomColourIndex() const
+{
+    return m_choices.GetCount() - 1;
+}
+
+
+bool wxSystemColourProperty::QueryColourFromUser( wxVariant& variant ) const
+{
+    wxASSERT( m_value.GetType() != wxPG_VARIANT_TYPE_STRING );
+    bool res = false;
+
+    wxPropertyGrid* propgrid = GetGrid();
+    wxASSERT( propgrid );
+
+    // Must only occur when user triggers event
+    if ( !(propgrid->GetInternalFlags() & wxPG_FL_IN_HANDLECUSTOMEDITOREVENT) )
+        return res;
+
+    wxColourPropertyValue val = GetVal();
+
+    val.m_type = wxPG_COLOUR_CUSTOM;
+
+    wxColourData data;
+    data.SetChooseFull(true);
+    data.SetColour(val.m_colour);
+    int i;
+    for ( i = 0; i < 16; i++)
+    {
+        wxColour colour(i*16, i*16, i*16);
+        data.SetCustomColour(i, colour);
+    }
+
+    wxColourDialog dialog(propgrid, &data);
+    if ( dialog.ShowModal() == wxID_OK )
+    {
+        wxColourData retData = dialog.GetColourData();
+        val.m_colour = retData.GetColour();
+
+        variant = DoTranslateVal(val);
+
+        SetValueInEvent(variant);
+
+        res = true;
+    }
+
+    return res;
+}
+
+
+bool wxSystemColourProperty::IntToValue( wxVariant& variant, int number, int WXUNUSED(argFlags) ) const
+{
+    int index = number;
+    int type = m_choices.GetValue(index);
+
+    if ( type == wxPG_COLOUR_CUSTOM )
+    {
+        QueryColourFromUser(variant);
+    }
+    else
+    {
+        variant = TranslateVal( type, GetColour(type) );
+    }
+
+    return true;
+}
+
+// Need to do some extra event handling.
+bool wxSystemColourProperty::OnEvent( wxPropertyGrid* propgrid, wxWindow* WXUNUSED(primary), wxEvent& event )
+{
+    if ( propgrid->IsMainButtonEvent(event) )
+    {
+        // We need to handle button click in case editor has been
+        // switched to one that has wxButton as well.
+        wxVariant variant;
+        if ( QueryColourFromUser(variant) )
+            return true;
+    }
+    return false;
+}
+
+/*class wxPGColourPropertyRenderer : public wxPGDefaultRenderer
+{
+public:
+    virtual void Render( wxDC& dc, const wxRect& rect,
+                         const wxPropertyGrid* propertyGrid, wxPGProperty* property,
+                         int WXUNUSED(column), int item, int WXUNUSED(flags) ) const
+    {
+        wxASSERT( property->IsKindOf(CLASSINFO(wxSystemColourProperty)) );
+        wxSystemColourProperty* prop = wxStaticCast(property, wxSystemColourProperty);
+
+        dc.SetPen(*wxBLACK_PEN);
+        if ( item >= 0 &&
+             ( item < (int)(GetCustomColourIndex) || (prop->HasFlag(wxPG_PROP_HIDE_CUSTOM_COLOUR)))
+           )
+        {
+            int colInd;
+            const wxArrayInt& values = prop->GetValues();
+            if ( values.GetChildCount() )
+                colInd = values[item];
+            else
+                colInd = item;
+            dc.SetBrush( wxColour( prop->GetColour( colInd ) ) );
+        }
+        else if ( !prop->IsValueUnspecified() )
+            dc.SetBrush( prop->GetVal().m_colour );
+        else
+            dc.SetBrush( *wxWHITE );
+
+        wxRect imageRect = propertyGrid->GetImageRect(property, item);
+        wxLogDebug(wxT("%i, %i"),imageRect.x,imageRect.y);
+        dc.DrawRectangle( rect.x+imageRect.x, rect.y+imageRect.y,
+                          imageRect.width, imageRect.height );
+
+        wxString text;
+        if ( item == -1 )
+            text = property->GetValueAsString();
+        else
+            text = property->GetChoiceString(item);
+        DrawText( dc, rect, imageRect.width, text );
+    }
+protected:
+};
+
+wxPGColourPropertyRenderer g_wxPGColourPropertyRenderer;
+
+wxPGCellRenderer* wxSystemColourProperty::GetCellRenderer( int column ) const
+{
+    if ( column == 1 )
+        return &g_wxPGColourPropertyRenderer;
+    return wxEnumProperty::GetCellRenderer(column);
+}*/
+
+void wxSystemColourProperty::OnCustomPaint( wxDC& dc, const wxRect& rect,
+                                            wxPGPaintData& paintdata )
+{
+    wxColour col;
+
+    if ( paintdata.m_choiceItem >= 0 && paintdata.m_choiceItem < (int)m_choices.GetCount() &&
+         paintdata.m_choiceItem != GetCustomColourIndex() )
+    {
+        int colInd = m_choices[paintdata.m_choiceItem].GetValue();
+        col = GetColour( colInd );
+    }
+    else if ( !IsValueUnspecified() )
+    {
+        col = GetVal().m_colour;
+    }
+
+    if ( col.Ok() )
+    {
+        dc.SetBrush(col);
+        dc.DrawRectangle(rect);
+    }
+}
+
+
+bool wxSystemColourProperty::StringToValue( wxVariant& value, const wxString& text, int argFlags ) const
+{
+    //
+    // Accept colour format "[Name] [(R,G,B)]"
+    // Name takes precedence.
+    //
+    wxString colourName;
+    wxString colourRGB;
+
+    int ppos = text.Find(wxT("("));
+
+    if ( ppos == wxNOT_FOUND )
+    {
+        colourName = text;
+    }
+    else
+    {
+        colourName = text.substr(0, ppos);
+        colourRGB = text.substr(ppos, text.length()-ppos);
+    }
+
+    // Strip spaces from extremities
+    colourName.Trim(true);
+    colourName.Trim(false);
+    colourRGB.Trim(true);
+
+    // Validate colourRGB string - (1,1,1) is shortest allowed
+    if ( colourRGB.length() < 7 )
+        colourRGB.clear();
+
+    if ( colourRGB.length() == 0 && m_choices.GetCount() &&
+         colourName == m_choices.GetLabel(GetCustomColourIndex()) )
+    {
+        if ( !(argFlags & wxPG_EDITABLE_VALUE ))
+        {
+            // This really should not occurr...
+            // wxASSERT(false);
+            ResetNextIndex();
+            return false;
+        }
+
+        QueryColourFromUser(value);
+    }
+    else
+    {
+        wxColourPropertyValue val;
+
+        bool done = false;
+
+        if ( colourName.length() )
+        {
+            // Try predefined colour first
+            bool res = wxEnumProperty::StringToValue(value, colourName, argFlags);
+            if ( res && GetIndex() >= 0 )
+            {
+                val.m_type = GetIndex();
+                if ( val.m_type < m_choices.GetCount() )
+                    val.m_type = m_choices[val.m_type].GetValue();
+
+                // Get proper colour for type.
+                val.m_colour = GetColour(val.m_type);
+
+                done = true;
+            }
+        }
+        if ( colourRGB.length() && !done )
+        {
+            // Then check custom colour.
+            val.m_type = wxPG_COLOUR_CUSTOM;
+
+            int r = -1, g = -1, b = -1;
+            wxSscanf(colourRGB.c_str(),wxT("(%i,%i,%i)"),&r,&g,&b);
+
+            if ( r >= 0 && r <= 255 &&
+                 g >= 0 && g <= 255 &&
+                 b >= 0 && b <= 255 )
+            {
+                val.m_colour.Set(r,g,b);
+
+                done = true;
+            }
+        }
+
+        if ( !done )
+        {
+            ResetNextIndex();
+            return false;
+        }
+
+        value = DoTranslateVal(val);
+    }
+
+    return true;
+}
+
+
+bool wxSystemColourProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    if ( name == wxPG_COLOUR_ALLOW_CUSTOM )
+    {
+        int ival = wxPGVariantToInt(value);
+
+        if ( ival && (m_flags & wxPG_PROP_HIDE_CUSTOM_COLOUR) )
+        {
+            // Show custom choice
+            m_choices.Insert(wxT("Custom"), GetCustomColourIndex(), wxPG_COLOUR_CUSTOM);
+            m_flags &= ~(wxPG_PROP_HIDE_CUSTOM_COLOUR);
+        }
+        else if ( !ival && !(m_flags & wxPG_PROP_HIDE_CUSTOM_COLOUR) )
+        {
+            // Hide custom choice
+            m_choices.RemoveAt(GetCustomColourIndex());
+            m_flags |= wxPG_PROP_HIDE_CUSTOM_COLOUR;
+        }
+        return true;
+    }
+    return false;
+}
+
+
+// -----------------------------------------------------------------------
+// wxColourProperty
+// -----------------------------------------------------------------------
+
+static const wxChar* gs_cp_es_normcolour_labels[] = {
+    wxT("Black"),
+    wxT("Maroon"),
+    wxT("Navy"),
+    wxT("Purple"),
+    wxT("Teal"),
+    wxT("Gray"),
+    wxT("Green"),
+    wxT("Olive"),
+    wxT("Brown"),
+    wxT("Blue"),
+    wxT("Fuchsia"),
+    wxT("Red"),
+    wxT("Orange"),
+    wxT("Silver"),
+    wxT("Lime"),
+    wxT("Aqua"),
+    wxT("Yellow"),
+    wxT("White"),
+    wxT("Custom"),
+    (const wxChar*) NULL
+};
+
+static unsigned long gs_cp_es_normcolour_colours[] = {
+    wxPG_COLOUR(0,0,0),
+    wxPG_COLOUR(128,0,0),
+    wxPG_COLOUR(0,0,128),
+    wxPG_COLOUR(128,0,128),
+    wxPG_COLOUR(0,128,128),
+    wxPG_COLOUR(128,128,128),
+    wxPG_COLOUR(0,128,0),
+    wxPG_COLOUR(128,128,0),
+    wxPG_COLOUR(166,124,81),
+    wxPG_COLOUR(0,0,255),
+    wxPG_COLOUR(255,0,255),
+    wxPG_COLOUR(255,0,0),
+    wxPG_COLOUR(247,148,28),
+    wxPG_COLOUR(192,192,192),
+    wxPG_COLOUR(0,255,0),
+    wxPG_COLOUR(0,255,255),
+    wxPG_COLOUR(255,255,0),
+    wxPG_COLOUR(255,255,255),
+    wxPG_COLOUR(0,0,0)
+};
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxColourProperty, wxSystemColourProperty,
+                               wxColour, const wxColour&, TextCtrlAndButton)
+
+static wxPGChoices gs_wxColourProperty_choicesCache;
+
+wxColourProperty::wxColourProperty( const wxString& label,
+                      const wxString& name,
+                      const wxColour& value )
+    : wxSystemColourProperty(label, name, gs_cp_es_normcolour_labels,
+                             NULL,
+                             &gs_wxColourProperty_choicesCache, value )
+{
+    Init( value );
+
+    m_flags |= wxPG_PROP_TRANSLATE_CUSTOM;
+}
+
+wxColourProperty::~wxColourProperty()
+{
+}
+
+void wxColourProperty::Init( wxColour colour )
+{
+    if ( !colour.Ok() )
+        colour = *wxWHITE;
+    wxVariant variant;
+    variant << colour;
+    m_value = variant;
+    int ind = ColToInd(colour);
+    if ( ind < 0 )
+        ind = m_choices.GetCount() - 1;
+    SetIndex( ind );
+}
+
+wxString wxColourProperty::ValueToString( wxVariant& value,
+                                          int argFlags ) const
+{
+    const wxPGEditor* editor = GetEditorClass();
+    if ( editor != wxPGEditor_Choice &&
+         editor != wxPGEditor_ChoiceAndButton &&
+         editor != wxPGEditor_ComboBox )
+        argFlags |= wxPG_PROPERTY_SPECIFIC;
+
+    return wxSystemColourProperty::ValueToString(value, argFlags);
+}
+
+wxColour wxColourProperty::GetColour( int index ) const
+{
+    return gs_cp_es_normcolour_colours[m_choices.GetValue(index)];
+}
+
+wxVariant wxColourProperty::DoTranslateVal( wxColourPropertyValue& v ) const
+{
+    wxVariant variant;
+    variant << v.m_colour;
+    return variant;
+}
+
+// -----------------------------------------------------------------------
+// wxCursorProperty
+// -----------------------------------------------------------------------
+
+#define wxPG_CURSOR_IMAGE_WIDTH     32
+
+#define NUM_CURSORS 28
+
+//#define wx_cp_es_syscursors_len 28
+static const wxChar* gs_cp_es_syscursors_labels[NUM_CURSORS+1] = {
+    wxT("Default"),
+    wxT("Arrow"),
+    wxT("Right Arrow"),
+    wxT("Blank"),
+    wxT("Bullseye"),
+    wxT("Character"),
+    wxT("Cross"),
+    wxT("Hand"),
+    wxT("I-Beam"),
+    wxT("Left Button"),
+    wxT("Magnifier"),
+    wxT("Middle Button"),
+    wxT("No Entry"),
+    wxT("Paint Brush"),
+    wxT("Pencil"),
+    wxT("Point Left"),
+    wxT("Point Right"),
+    wxT("Question Arrow"),
+    wxT("Right Button"),
+    wxT("Sizing NE-SW"),
+    wxT("Sizing N-S"),
+    wxT("Sizing NW-SE"),
+    wxT("Sizing W-E"),
+    wxT("Sizing"),
+    wxT("Spraycan"),
+    wxT("Wait"),
+    wxT("Watch"),
+    wxT("Wait Arrow"),
+    (const wxChar*) NULL
+};
+
+static long gs_cp_es_syscursors_values[NUM_CURSORS] = {
+    wxCURSOR_NONE,
+    wxCURSOR_ARROW,
+    wxCURSOR_RIGHT_ARROW,
+    wxCURSOR_BLANK,
+    wxCURSOR_BULLSEYE,
+    wxCURSOR_CHAR,
+    wxCURSOR_CROSS,
+    wxCURSOR_HAND,
+    wxCURSOR_IBEAM,
+    wxCURSOR_LEFT_BUTTON,
+    wxCURSOR_MAGNIFIER,
+    wxCURSOR_MIDDLE_BUTTON,
+    wxCURSOR_NO_ENTRY,
+    wxCURSOR_PAINT_BRUSH,
+    wxCURSOR_PENCIL,
+    wxCURSOR_POINT_LEFT,
+    wxCURSOR_POINT_RIGHT,
+    wxCURSOR_QUESTION_ARROW,
+    wxCURSOR_RIGHT_BUTTON,
+    wxCURSOR_SIZENESW,
+    wxCURSOR_SIZENS,
+    wxCURSOR_SIZENWSE,
+    wxCURSOR_SIZEWE,
+    wxCURSOR_SIZING,
+    wxCURSOR_SPRAYCAN,
+    wxCURSOR_WAIT,
+    wxCURSOR_WATCH,
+    wxCURSOR_ARROWWAIT
+};
+
+IMPLEMENT_DYNAMIC_CLASS(wxCursorProperty, wxEnumProperty)
+
+wxCursorProperty::wxCursorProperty( const wxString& label, const wxString& name,
+    int value )
+    : wxEnumProperty( label,
+                      name,
+                      gs_cp_es_syscursors_labels,
+                      gs_cp_es_syscursors_values,
+                      value )
+{
+    m_flags |= wxPG_PROP_STATIC_CHOICES; // Cursor selection cannot be changed.
+}
+
+wxCursorProperty::~wxCursorProperty()
+{
+}
+
+wxSize wxCursorProperty::OnMeasureImage( int item ) const
+{
+#if wxPG_CAN_DRAW_CURSOR
+    if ( item != -1 && item < NUM_CURSORS )
+        return wxSize(wxPG_CURSOR_IMAGE_WIDTH,wxPG_CURSOR_IMAGE_WIDTH);
+#else
+    wxUnusedVar(item);
+#endif
+    return wxSize(0,0);
+}
+
+#if wxPG_CAN_DRAW_CURSOR
+
+void wxCursorProperty::OnCustomPaint( wxDC& dc,
+                                      const wxRect& rect,
+                                      wxPGPaintData& paintdata )
+{
+    // Background brush
+    dc.SetBrush( wxSystemSettings::GetColour( wxSYS_COLOUR_BTNFACE ) );
+
+    if ( paintdata.m_choiceItem >= 0 )
+    {
+        dc.DrawRectangle( rect );
+
+        if ( paintdata.m_choiceItem < NUM_CURSORS )
+        {
+            wxStockCursor cursorIndex =
+                (wxStockCursor) gs_cp_es_syscursors_values[paintdata.m_choiceItem];
+
+            {
+                if ( cursorIndex == wxCURSOR_NONE )
+                    cursorIndex = wxCURSOR_ARROW;
+
+                wxCursor cursor( cursorIndex );
+
+            #ifdef __WXMSW__
+                HDC hDc = (HDC)((const wxMSWDCImpl *)dc.GetImpl())->GetHDC();
+                ::DrawIconEx( hDc,
+                              rect.x,
+                              rect.y,
+                              (HICON)cursor.GetHandle(),
+                              0,
+                              0,
+                              0,
+                              NULL,
+            #if !defined(__WXWINCE__)
+                              DI_COMPAT | DI_DEFAULTSIZE |
+            #endif
+                              DI_NORMAL
+                            );
+            #endif
+            }
+        }
+    }
+}
+
+#else
+void wxCursorProperty::OnCustomPaint( wxDC&, const wxRect&, wxPGPaintData& ) { }
+/*wxPGCellRenderer* wxCursorProperty::GetCellRenderer( int column ) const
+{
+    return wxEnumProperty::GetCellRenderer(column);
+}*/
+#endif
+
+// -----------------------------------------------------------------------
+// wxImageFileProperty
+// -----------------------------------------------------------------------
+
+#if wxUSE_IMAGE
+
+const wxString& wxPGGetDefaultImageWildcard()
+{
+    // Form the wildcard, if not done yet
+    if ( !wxPGGlobalVars->m_pDefaultImageWildcard.length() )
+    {
+
+        wxString str;
+
+        // TODO: This section may require locking (using global).
+
+        wxList& handlers = wxImage::GetHandlers();
+
+        wxList::iterator node;
+
+        // Let's iterate over the image handler list.
+        //for ( wxList::Node *node = handlers.GetFirst(); node; node = node->GetNext() )
+        for ( node = handlers.begin(); node != handlers.end(); ++node )
+        {
+            wxImageHandler *handler = (wxImageHandler*)*node;
+
+            wxString ext_lo = handler->GetExtension();
+            wxString ext_up = ext_lo.Upper();
+
+            str.append( ext_up );
+            str.append( wxT(" files (*.") );
+            str.append( ext_up );
+            str.append( wxT(")|*.") );
+            str.append( ext_lo );
+            str.append( wxT("|") );
+        }
+
+        str.append ( wxT("All files (*.*)|*.*") );
+
+        wxPGGlobalVars->m_pDefaultImageWildcard = str;
+    }
+
+    return wxPGGlobalVars->m_pDefaultImageWildcard;
+}
+
+IMPLEMENT_DYNAMIC_CLASS(wxImageFileProperty, wxFileProperty)
+
+wxImageFileProperty::wxImageFileProperty( const wxString& label, const wxString& name,
+    const wxString& value )
+    : wxFileProperty(label,name,value)
+{
+    SetAttribute( wxPG_FILE_WILDCARD, wxPGGetDefaultImageWildcard() );
+
+    m_pImage = NULL;
+    m_pBitmap = NULL;
+}
+
+wxImageFileProperty::~wxImageFileProperty()
+{
+    if ( m_pBitmap )
+        delete m_pBitmap;
+    if ( m_pImage )
+        delete m_pImage;
+}
+
+void wxImageFileProperty::OnSetValue()
+{
+    wxFileProperty::OnSetValue();
+
+    // Delete old image
+    if ( m_pImage )
+    {
+        delete m_pImage;
+        m_pImage = NULL;
+    }
+    if ( m_pBitmap )
+    {
+        delete m_pBitmap;
+        m_pBitmap = NULL;
+    }
+
+    wxFileName filename = GetFileName();
+
+    // Create the image thumbnail
+    if ( filename.FileExists() )
+    {
+        m_pImage = new wxImage( filename.GetFullPath() );
+    }
+}
+
+wxSize wxImageFileProperty::OnMeasureImage( int ) const
+{
+    return wxPG_DEFAULT_IMAGE_SIZE;
+}
+
+void wxImageFileProperty::OnCustomPaint( wxDC& dc,
+                                         const wxRect& rect,
+                                         wxPGPaintData& )
+{
+    if ( m_pBitmap || (m_pImage && m_pImage->Ok() ) )
+    {
+        // Draw the thumbnail
+
+        // Create the bitmap here because required size is not known in OnSetValue().
+        if ( !m_pBitmap )
+        {
+            m_pImage->Rescale( rect.width, rect.height );
+            m_pBitmap = new wxBitmap( *m_pImage );
+            delete m_pImage;
+            m_pImage = NULL;
+        }
+
+        dc.DrawBitmap( *m_pBitmap, rect.x, rect.y, false );
+    }
+    else
+    {
+        // No file - just draw a white box
+        dc.SetBrush( *wxWHITE_BRUSH );
+        dc.DrawRectangle ( rect );
+    }
+}
+
+#endif // wxUSE_IMAGE
+
+// -----------------------------------------------------------------------
+// wxMultiChoiceProperty
+// -----------------------------------------------------------------------
+
+#if wxUSE_CHOICEDLG
+
+#include "wx/choicdlg.h"
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxMultiChoiceProperty,wxPGProperty,
+                               wxArrayInt,const wxArrayInt&,TextCtrlAndButton)
+
+wxMultiChoiceProperty::wxMultiChoiceProperty( const wxString& label,
+                                              const wxString& name,
+                                              const wxPGChoices& choices,
+                                              const wxArrayString& value)
+                                                : wxPGProperty(label,name)
+{
+    m_choices.Assign(choices);
+    SetValue(value);
+}
+
+wxMultiChoiceProperty::wxMultiChoiceProperty( const wxString& label,
+                                              const wxString& name,
+                                              const wxArrayString& strings,
+                                              const wxArrayString& value)
+                                                : wxPGProperty(label,name)
+{
+    m_choices.Set(strings);
+    SetValue(value);
+}
+
+wxMultiChoiceProperty::wxMultiChoiceProperty( const wxString& label,
+                                              const wxString& name,
+                                              const wxArrayString& value)
+                                                : wxPGProperty(label,name)
+{
+    wxArrayString strings;
+    m_choices.Set(strings);
+    SetValue(value);
+}
+
+wxMultiChoiceProperty::~wxMultiChoiceProperty()
+{
+}
+
+void wxMultiChoiceProperty::OnSetValue()
+{
+    GenerateValueAsString(m_value, &m_display);
+}
+
+wxString wxMultiChoiceProperty::ValueToString( wxVariant& value,
+                                               int argFlags ) const
+{
+    // If possible, use cached string
+    if ( argFlags & wxPG_VALUE_IS_CURRENT )
+        return m_display;
+
+    wxString s;
+    GenerateValueAsString(value, &s);
+    return s;
+}
+
+void wxMultiChoiceProperty::GenerateValueAsString( wxVariant& value,
+                                                   wxString* target ) const
+{
+    wxArrayString strings;
+
+    if ( value.GetType() == wxPG_VARIANT_TYPE_ARRSTRING )
+        strings = value.GetArrayString();
+
+    wxString& tempStr = *target;
+    unsigned int i;
+    unsigned int itemCount = strings.size();
+
+    tempStr.Empty();
+
+    if ( itemCount )
+        tempStr.append( wxT("\"") );
+
+    for ( i = 0; i < itemCount; i++ )
+    {
+        tempStr.append( strings[i] );
+        tempStr.append( wxT("\"") );
+        if ( i < (itemCount-1) )
+            tempStr.append ( wxT(" \"") );
+    }
+}
+
+wxArrayInt wxMultiChoiceProperty::GetValueAsIndices() const
+{
+    wxVariant variant = GetValue();
+    const wxArrayInt& valueArr = wxArrayIntRefFromVariant(variant);
+    unsigned int i;
+
+    // Translate values to string indices.
+    wxArrayInt selections;
+
+    if ( !m_choices.IsOk() || !m_choices.GetCount() || !(&valueArr) )
+    {
+        for ( i=0; i<valueArr.size(); i++ )
+            selections.Add(-1);
+    }
+    else
+    {
+        for ( i=0; i<valueArr.size(); i++ )
+        {
+            int sIndex = m_choices.Index(valueArr[i]);
+            if ( sIndex >= 0 )
+                selections.Add(sIndex);
+        }
+    }
+
+    return selections;
+}
+
+bool wxMultiChoiceProperty::OnEvent( wxPropertyGrid* propgrid,
+                                     wxWindow* WXUNUSED(primary),
+                                     wxEvent& event )
+{
+    if ( propgrid->IsMainButtonEvent(event) )
+    {
+        // Update the value
+        wxVariant useValue = propgrid->GetUncommittedPropertyValue();
+
+        wxArrayString labels = m_choices.GetLabels();
+        unsigned int choiceCount;
+
+        if ( m_choices.IsOk() )
+            choiceCount = m_choices.GetCount();
+        else
+            choiceCount = 0;
+
+        // launch editor dialog
+        wxMultiChoiceDialog dlg( propgrid,
+                                 _("Make a selection:"),
+                                 m_label,
+                                 choiceCount,
+                                 choiceCount?&labels[0]:NULL,
+                                 wxCHOICEDLG_STYLE );
+
+        dlg.Move( propgrid->GetGoodEditorDialogPosition(this,dlg.GetSize()) );
+
+        wxArrayString strings = useValue.GetArrayString();
+        wxArrayString extraStrings;
+
+        dlg.SetSelections(m_choices.GetIndicesForStrings(strings, &extraStrings));
+
+        if ( dlg.ShowModal() == wxID_OK && choiceCount )
+        {
+            int userStringMode = GetAttributeAsLong(wxT("UserStringMode"), 0);
+
+            wxArrayInt arrInt = dlg.GetSelections();
+
+            wxVariant variant;
+
+            // Strings that were not in list of choices
+            wxArrayString value;
+
+            // Translate string indices to strings
+
+            unsigned int n;
+            if ( userStringMode == 1 )
+            {
+                for (n=0;n<extraStrings.size();n++)
+                    value.push_back(extraStrings[n]);
+            }
+
+            unsigned int i;
+            for ( i=0; i<arrInt.size(); i++ )
+                value.Add(m_choices.GetLabel(arrInt.Item(i)));
+
+            if ( userStringMode == 2 )
+            {
+                for (n=0;n<extraStrings.size();n++)
+                    value.push_back(extraStrings[n]);
+            }
+
+            variant = WXVARIANT(value);
+
+            SetValueInEvent(variant);
+
+            return true;
+        }
+    }
+    return false;
+}
+
+bool wxMultiChoiceProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
+{
+    wxArrayString arr;
+
+    int userStringMode = GetAttributeAsLong(wxT("UserStringMode"), 0);
+
+    WX_PG_TOKENIZER2_BEGIN(text,wxT('"'))
+        if ( userStringMode > 0 || (m_choices.IsOk() && m_choices.Index( token ) != wxNOT_FOUND) )
+            arr.Add(token);
+    WX_PG_TOKENIZER2_END()
+
+    wxVariant v( WXVARIANT(arr) );
+    variant = v;
+
+    return true;
+}
+
+#endif // wxUSE_CHOICEDLG
+
+
+// -----------------------------------------------------------------------
+// wxDateProperty
+// -----------------------------------------------------------------------
+
+#if wxUSE_DATETIME
+
+
+#if wxUSE_DATEPICKCTRL
+    #define dtCtrl      DatePickerCtrl
+#else
+    #define dtCtrl      TextCtrl
+#endif
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxDateProperty,
+                               wxPGProperty,
+                               wxDateTime,
+                               const wxDateTime&,
+                               dtCtrl)
+
+
+wxString wxDateProperty::ms_defaultDateFormat;
+
+
+wxDateProperty::wxDateProperty( const wxString& label,
+                                const wxString& name,
+                                const wxDateTime& value )
+    : wxPGProperty(label,name)
+{
+    //wxPGRegisterDefaultValueType(wxDateTime)
+
+#if wxUSE_DATEPICKCTRL
+    wxPGRegisterEditorClass(DatePickerCtrl);
+
+    m_dpStyle = wxDP_DEFAULT | wxDP_SHOWCENTURY;
+#else
+    m_dpStyle = 0;
+#endif
+
+    SetValue( value );
+}
+
+wxDateProperty::~wxDateProperty()
+{
+}
+
+void wxDateProperty::OnSetValue()
+{
+    //
+    // Convert invalid dates to unspecified value
+    if ( m_value.GetType() == wxT("datetime") )
+    {
+        if ( !m_value.GetDateTime().IsValid() )
+            m_value.MakeNull();
+    }
+}
+
+bool wxDateProperty::StringToValue( wxVariant& variant, const wxString& text,
+                                    int WXUNUSED(argFlags) ) const
+{
+    wxDateTime dt;
+
+    // FIXME: do we really want to return true from here if only part of the
+    //        string was parsed?
+    const char* c = dt.ParseFormat(text);
+
+    if ( c )
+    {
+        variant = dt;
+        return true;
+    }
+
+    return false;
+}
+
+wxString wxDateProperty::ValueToString( wxVariant& value,
+                                        int argFlags ) const
+{
+    const wxChar* format = (const wxChar*) NULL;
+
+    wxDateTime dateTime = value.GetDateTime();
+
+    if ( !dateTime.IsValid() )
+        return wxT("Invalid");
+
+    if ( !ms_defaultDateFormat.length() )
+    {
+#if wxUSE_DATEPICKCTRL
+        bool showCentury = m_dpStyle & wxDP_SHOWCENTURY ? true : false;
+#else
+        bool showCentury = true;
+#endif
+        ms_defaultDateFormat = DetermineDefaultDateFormat( showCentury );
+    }
+
+    if ( m_format.length() &&
+         !(argFlags & wxPG_FULL_VALUE) )
+            format = m_format.c_str();
+
+    // Determine default from locale
+    // NB: This is really simple stuff, but can't figure anything
+    //     better without proper support in wxLocale
+    if ( !format )
+        format = ms_defaultDateFormat.c_str();
+
+    return dateTime.Format(format);
+}
+
+wxString wxDateProperty::DetermineDefaultDateFormat( bool showCentury )
+{
+    // This code is basicly copied from datectlg.cpp's SetFormat
+    //
+    wxString format;
+
+    wxDateTime dt;
+    dt.ParseFormat(wxT("2003-10-13"), wxT("%Y-%m-%d"));
+    wxString str(dt.Format(wxT("%x")));
+
+    const wxChar *p = str.c_str();
+    while ( *p )
+    {
+        int n=wxAtoi(p);
+        if (n == dt.GetDay())
+        {
+            format.Append(wxT("%d"));
+            p += 2;
+        }
+        else if (n == (int)dt.GetMonth()+1)
+        {
+            format.Append(wxT("%m"));
+            p += 2;
+        }
+        else if (n == dt.GetYear())
+        {
+            format.Append(wxT("%Y"));
+            p += 4;
+        }
+        else if (n == (dt.GetYear() % 100))
+        {
+            if (showCentury)
+                format.Append(wxT("%Y"));
+            else
+                format.Append(wxT("%y"));
+            p += 2;
+        }
+        else
+            format.Append(*p++);
+    }
+
+    return format;
+}
+
+bool wxDateProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    if ( name == wxPG_DATE_FORMAT )
+    {
+        m_format = value.GetString();
+        return true;
+    }
+    else if ( name == wxPG_DATE_PICKER_STYLE )
+    {
+        m_dpStyle = value.GetLong();
+        ms_defaultDateFormat.clear();  // This may need recalculation
+        return true;
+    }
+    return false;
+}
+
+#endif  // wxUSE_DATETIME
+
+
+// -----------------------------------------------------------------------
+// wxPropertyGridInterface
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::InitAllTypeHandlers()
+{
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::RegisterAdditionalEditors()
+{
+    // Register editor classes, if necessary.
+    if ( wxPGGlobalVars->m_mapEditorClasses.empty() )
+        wxPropertyGrid::RegisterDefaultEditors();
+
+#if wxUSE_SPINBTN
+    wxPGRegisterEditorClass(SpinCtrl);
+#endif
+#if wxUSE_DATEPICKCTRL
+    wxPGRegisterEditorClass(DatePickerCtrl);
+#endif
+}
+
+// -----------------------------------------------------------------------
+
+#endif  // wxPG_INCLUDE_ADVPROPS
+
+#endif  // wxUSE_PROPGRID
+
Index: editors.cpp
===================================================================
--- editors.cpp	(revision 102)
+++ editors.cpp	(working copy)
@@ -1,1907 +1,1907 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/editors.cpp
-// Purpose:     wxPropertyGrid editors
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2007-04-14
-// RCS-ID:      $Id: editors.cpp 59451 2009-03-09 18:33:41Z JMS $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcclient.h"
-    #include "wx/dcmemory.h"
-    #include "wx/button.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/cursor.h"
-    #include "wx/dialog.h"
-    #include "wx/settings.h"
-    #include "wx/msgdlg.h"
-    #include "wx/choice.h"
-    #include "wx/stattext.h"
-    #include "wx/scrolwin.h"
-    #include "wx/dirdlg.h"
-    #include "wx/sizer.h"
-    #include "wx/textdlg.h"
-    #include "wx/filedlg.h"
-    #include "wx/statusbr.h"
-    #include "wx/intl.h"
-    #include "wx/frame.h"
-#endif
-
-
-#include "wx/timer.h"
-#include "wx/dcbuffer.h"
-#include "wx/bmpbuttn.h"
-
-
-// This define is necessary to prevent macro clearing
-#define __wxPG_SOURCE_FILE__
-
-#include "wx/propgrid/propgrid.h"
-#include "wx/propgrid/editors.h"
-#include "wx/propgrid/props.h"
-
-#if wxPG_USE_RENDERER_NATIVE
-    #include "wx/renderer.h"
-#endif
-
-// How many pixels between textctrl and button
-#ifdef __WXMAC__
-    #define wxPG_TEXTCTRL_AND_BUTTON_SPACING        4
-#else
-    #define wxPG_TEXTCTRL_AND_BUTTON_SPACING        2
-#endif 
-
-#define wxPG_BUTTON_SIZEDEC                         0
-
-#include "wx/odcombo.h"
-
-#ifdef __WXMSW__
-    #include "wx/msw/private.h"
-#endif
-
-// -----------------------------------------------------------------------
-
-#if defined(__WXMSW__)
-    // tested
-    #define wxPG_NAT_BUTTON_BORDER_ANY          1
-    #define wxPG_NAT_BUTTON_BORDER_X            1
-    #define wxPG_NAT_BUTTON_BORDER_Y            1
-
-    #define wxPG_CHECKMARK_XADJ                 1
-    #define wxPG_CHECKMARK_YADJ                 (-1)
-    #define wxPG_CHECKMARK_WADJ                 0
-    #define wxPG_CHECKMARK_HADJ                 0
-    #define wxPG_CHECKMARK_DEFLATE              0
-
-    #define wxPG_TEXTCTRLYADJUST                (m_spacingy+0)
-
-#elif defined(__WXGTK__)
-    // tested
-    #define wxPG_CHECKMARK_XADJ                 0
-    #define wxPG_CHECKMARK_YADJ                 0
-    #define wxPG_CHECKMARK_WADJ                 (-1)
-    #define wxPG_CHECKMARK_HADJ                 (-1)
-    #define wxPG_CHECKMARK_DEFLATE              3
-
-    #define wxPG_NAT_BUTTON_BORDER_ANY      1
-    #define wxPG_NAT_BUTTON_BORDER_X        1
-    #define wxPG_NAT_BUTTON_BORDER_Y        1
-
-    #define wxPG_TEXTCTRLYADJUST            0
-
-#elif defined(__WXMAC__)
-    // *not* tested
-    #define wxPG_CHECKMARK_XADJ                 0
-    #define wxPG_CHECKMARK_YADJ                 0
-    #define wxPG_CHECKMARK_WADJ                 0
-    #define wxPG_CHECKMARK_HADJ                 0
-    #define wxPG_CHECKMARK_DEFLATE              0
-
-    #define wxPG_NAT_BUTTON_BORDER_ANY      0
-    #define wxPG_NAT_BUTTON_BORDER_X        0
-    #define wxPG_NAT_BUTTON_BORDER_Y        0
-
-    #define wxPG_TEXTCTRLYADJUST            0
-
-#else
-    // defaults
-    #define wxPG_CHECKMARK_XADJ                 0
-    #define wxPG_CHECKMARK_YADJ                 0
-    #define wxPG_CHECKMARK_WADJ                 0
-    #define wxPG_CHECKMARK_HADJ                 0
-    #define wxPG_CHECKMARK_DEFLATE              0
-
-    #define wxPG_NAT_BUTTON_BORDER_ANY      0
-    #define wxPG_NAT_BUTTON_BORDER_X        0
-    #define wxPG_NAT_BUTTON_BORDER_Y        0
-
-    #define wxPG_TEXTCTRLYADJUST            0
-
-#endif
-
-// for odcombo
-#ifdef __WXMAC__
-#define wxPG_CHOICEXADJUST           -3 // required because wxComboCtrl reserves 3pixels for wxTextCtrl's focus ring
-#define wxPG_CHOICEYADJUST           -3 
-#else
-#define wxPG_CHOICEXADJUST           0
-#define wxPG_CHOICEYADJUST           0
-#endif
-
-#define ODCB_CUST_PAINT_MARGIN               6  // Number added to image width for SetCustomPaintWidth
-
-// Milliseconds to wait for two mouse-ups after focus inorder
-// to trigger a double-click.
-#define DOUBLE_CLICK_CONVERSION_TRESHOLD        500
-
-// -----------------------------------------------------------------------
-// wxPGEditor
-// -----------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(wxPGEditor, wxObject)
-
-
-wxPGEditor::~wxPGEditor()
-{
-}
-
-wxString wxPGEditor::GetName() const
-{
-    return GetClassInfo()->GetClassName();
-}
-
-void wxPGEditor::DrawValue( wxDC& dc, const wxRect& rect, wxPGProperty* property, const wxString& text ) const
-{
-    if ( !property->IsValueUnspecified() )
-        dc.DrawText( text, rect.x+wxPG_XBEFORETEXT, rect.y );
-}
-
-bool wxPGEditor::GetValueFromControl( wxVariant&, wxPGProperty*, wxWindow* ) const
-{
-    return false;
-}
-
-void wxPGEditor::SetControlStringValue( wxPGProperty* WXUNUSED(property), wxWindow*, const wxString& ) const
-{
-}
-
-
-void wxPGEditor::SetControlIntValue( wxPGProperty* WXUNUSED(property), wxWindow*, int ) const
-{
-}
-
-
-int wxPGEditor::InsertItem( wxWindow*, const wxString&, int ) const
-{
-    return -1;
-}
-
-
-void wxPGEditor::DeleteItem( wxWindow*, int ) const
-{
-    return;
-}
-
-
-void wxPGEditor::OnFocus( wxPGProperty*, wxWindow* ) const
-{
-}
-
-
-bool wxPGEditor::CanContainCustomImage() const
-{
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPGTextCtrlEditor
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(TextCtrl,wxPGTextCtrlEditor,wxPGEditor)
-
-
-wxPGWindowList wxPGTextCtrlEditor::CreateControls( wxPropertyGrid* propGrid,
-                                                   wxPGProperty* property,
-                                                   const wxPoint& pos,
-                                                   const wxSize& sz ) const
-{
-    wxString text;
-
-    //
-    // If has children, and limited editing is specified, then don't create.
-    if ( (property->GetFlags() & wxPG_PROP_NOEDITOR) &&
-         property->GetChildCount() )
-        return NULL;
-
-    if ( !property->IsValueUnspecified() )
-        text = property->GetValueAsString(property->HasFlag(wxPG_PROP_READONLY) ?
-                                            0 : wxPG_EDITABLE_VALUE);
-
-    int flags = 0;
-    if ( (property->GetFlags() & wxPG_PROP_PASSWORD) &&
-         property->IsKindOf(CLASSINFO(wxStringProperty)) )
-        flags |= wxTE_PASSWORD;
-
-    wxWindow* wnd = propGrid->GenerateEditorTextCtrl(pos,sz,text,NULL,flags,
-                                                     property->GetMaxLength());
-
-    return wnd;
-}
-
-#if 0
-void wxPGTextCtrlEditor::DrawValue( wxDC& dc, wxPGProperty* property, const wxRect& rect ) const
-{
-    if ( !property->IsValueUnspecified() )
-    {
-        wxString drawStr = property->GetDisplayedString();
-
-        // Code below should no longer be needed, as the obfuscation
-        // is now done in GetValueAsString.
-        /*if ( (property->GetFlags() & wxPG_PROP_PASSWORD) &&
-             property->IsKindOf(WX_PG_CLASSINFO(wxStringProperty)) )
-        {
-            size_t a = drawStr.length();
-            drawStr.Empty();
-            drawStr.Append(wxS('*'),a);
-        }*/
-        dc.DrawText( drawStr, rect.x+wxPG_XBEFORETEXT, rect.y );
-    }
-}
-#endif
-
-void wxPGTextCtrlEditor::UpdateControl( wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxTextCtrl* tc = wxDynamicCast(ctrl, wxTextCtrl);
-    if (!tc) return;
-
-    wxString s;
-
-    if ( tc->HasFlag(wxTE_PASSWORD) )
-        s = property->GetValueAsString(wxPG_FULL_VALUE);
-    else
-        s = property->GetDisplayedString();
-
-    tc->SetValue(s);
-
-    //
-    // Fix indentation, just in case (change in font boldness is one good
-    // reason).
-#if defined(__WXMSW__) && !defined(__WXWINCE__)
-    ::SendMessage(GetHwndOf(tc),
-                  EM_SETMARGINS,
-                  EC_LEFTMARGIN | EC_RIGHTMARGIN,
-                  MAKELONG(0, 0));
-#endif
-}
-
-// Provided so that, for example, ComboBox editor can use the same code
-// (multiple inheritance would get way too messy).
-bool wxPGTextCtrlEditor::OnTextCtrlEvent( wxPropertyGrid* propGrid,
-                                          wxPGProperty* WXUNUSED(property),
-                                          wxWindow* ctrl,
-                                          wxEvent& event )
-{
-    if ( !ctrl )
-        return false;
-
-    if ( event.GetEventType() == wxEVT_COMMAND_TEXT_ENTER )
-    {
-        if ( propGrid->IsEditorsValueModified() )
-        {
-            return true;
-        }
-    }
-    else if ( event.GetEventType() == wxEVT_COMMAND_TEXT_UPDATED )
-    {
-        //
-        // Pass this event outside wxPropertyGrid so that,
-        // if necessary, program can tell when user is editing
-        // a textctrl.
-        // FIXME: Is it safe to change event id in the middle of event
-        //        processing (seems to work, but...)?
-        event.Skip();
-        event.SetId(propGrid->GetId());
-
-        propGrid->EditorsValueWasModified();
-    }
-    return false;
-}
-
-
-bool wxPGTextCtrlEditor::OnEvent( wxPropertyGrid* propGrid,
-                                  wxPGProperty* property,
-                                  wxWindow* ctrl,
-                                  wxEvent& event ) const
-{
-    return wxPGTextCtrlEditor::OnTextCtrlEvent(propGrid,property,ctrl,event);
-}
-
-
-bool wxPGTextCtrlEditor::GetTextCtrlValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl )
-{
-    wxTextCtrl* tc = wxStaticCast(ctrl, wxTextCtrl);
-    wxString textVal = tc->GetValue();
-
-    if ( property->UsesAutoUnspecified() && !textVal.length() )
-    {
-        variant.MakeNull();
-        return true;
-    }
-
-    bool res = property->StringToValue(variant, textVal, wxPG_EDITABLE_VALUE);
-
-    // Changing unspecified always causes event (returning
-    // true here should be enough to trigger it).
-    // TODO: Move to propgrid.cpp
-    if ( !res && variant.IsNull() )
-        res = true;
-
-    return res;
-}
-
-
-bool wxPGTextCtrlEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
-{
-    return wxPGTextCtrlEditor::GetTextCtrlValueFromControl(variant, property, ctrl);
-}
-
-
-void wxPGTextCtrlEditor::SetValueToUnspecified( wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxTextCtrl* tc = wxStaticCast(ctrl, wxTextCtrl);
-
-    wxPropertyGrid* pg = property->GetGrid();
-    wxASSERT(pg);  // Really, property grid should exist if editor does
-    if ( pg )
-        tc->SetValue(wxEmptyString);
-}
-
-
-void wxPGTextCtrlEditor::SetControlStringValue( wxPGProperty* property, wxWindow* ctrl, const wxString& txt ) const
-{
-    wxTextCtrl* tc = wxStaticCast(ctrl, wxTextCtrl);
-
-    wxPropertyGrid* pg = property->GetGrid();
-    wxASSERT(pg);  // Really, property grid should exist if editor does
-    if ( pg )
-        tc->SetValue(txt);
-}
-
-
-void wxPGTextCtrlEditor::OnFocus( wxPGProperty*, wxWindow* wnd ) const
-{
-    wxTextCtrl* tc = wxStaticCast(wnd, wxTextCtrl);
-
-    tc->SetSelection(-1,-1);
-}
-
-
-wxPGTextCtrlEditor::~wxPGTextCtrlEditor() { }
-
-
-// -----------------------------------------------------------------------
-// wxPGChoiceEditor
-// -----------------------------------------------------------------------
-
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(Choice,wxPGChoiceEditor,wxPGEditor)
-
-
-// This is a special enhanced double-click processor class.
-// In essence, it allows for double-clicks for which the
-// first click "created" the control.
-class wxPGDoubleClickProcessor : public wxEvtHandler
-{
-public:
-
-    wxPGDoubleClickProcessor( wxOwnerDrawnComboBox* combo, wxPGProperty* property )
-        : wxEvtHandler()
-    {
-        m_timeLastMouseUp = 0;
-        m_combo = combo;
-        m_property = property;
-        m_downReceived = false;
-    }
-
-protected:
-
-    void OnMouseEvent( wxMouseEvent& event )
-    {
-        wxLongLong t = ::wxGetLocalTimeMillis();
-        int evtType = event.GetEventType();
-
-        if ( m_property->HasFlag(wxPG_PROP_USE_DCC) &&
-             m_property->IsKindOf(CLASSINFO(wxBoolProperty)) &&
-             !m_combo->IsPopupShown() )
-        {
-            // Just check that it is in the text area
-            wxPoint pt = event.GetPosition();
-            if ( m_combo->GetTextRect().Contains(pt) )
-            {
-                if ( evtType == wxEVT_LEFT_DOWN )
-                {
-                    // Set value to avoid up-events without corresponding downs
-                    m_downReceived = true;
-                }
-                else if ( evtType == wxEVT_LEFT_DCLICK )
-                {
-                    // We'll make our own double-clicks
-                    event.SetEventType(0);
-                    return;
-                }
-                else if ( evtType == wxEVT_LEFT_UP )
-                {
-                    if ( m_downReceived || m_timeLastMouseUp == 1 )
-                    {
-                        wxLongLong timeFromLastUp = (t-m_timeLastMouseUp);
-
-                        if ( timeFromLastUp < DOUBLE_CLICK_CONVERSION_TRESHOLD )
-                        {
-                            event.SetEventType(wxEVT_LEFT_DCLICK);
-                            m_timeLastMouseUp = 1;
-                        }
-                        else
-                        {
-                            m_timeLastMouseUp = t;
-                        }
-                    }
-                }
-            }
-        }
-
-        event.Skip();
-    }
-
-    void OnSetFocus( wxFocusEvent& event )
-    {
-        m_timeLastMouseUp = ::wxGetLocalTimeMillis();
-        event.Skip();
-    }
-
-private:
-    wxLongLong                  m_timeLastMouseUp;
-    wxOwnerDrawnComboBox*       m_combo;
-    wxPGProperty*               m_property;  // Selected property
-    bool                        m_downReceived;
-
-    DECLARE_EVENT_TABLE()
-};
-
-BEGIN_EVENT_TABLE(wxPGDoubleClickProcessor, wxEvtHandler)
-    EVT_MOUSE_EVENTS(wxPGDoubleClickProcessor::OnMouseEvent)
-    EVT_SET_FOCUS(wxPGDoubleClickProcessor::OnSetFocus)
-END_EVENT_TABLE()
-
-
-
-class wxPGComboBox : public wxOwnerDrawnComboBox
-{
-public:
-
-    wxPGComboBox()
-        : wxOwnerDrawnComboBox()
-    {
-        m_dclickProcessor = NULL;
-        m_sizeEventCalled = false;
-    }
-
-    ~wxPGComboBox()
-    {
-        if ( m_dclickProcessor )
-        {
-            RemoveEventHandler(m_dclickProcessor);
-            delete m_dclickProcessor;
-        }
-    }
-
-    bool Create(wxWindow *parent,
-                wxWindowID id,
-                const wxString& value,
-                const wxPoint& pos,
-                const wxSize& size,
-                const wxArrayString& choices,
-                long style = 0,
-                const wxValidator& validator = wxDefaultValidator,
-                const wxString& name = wxS("wxOwnerDrawnComboBox"))
-    {
-        if ( !wxOwnerDrawnComboBox::Create( parent,
-                                            id,
-                                            value,
-                                            pos,
-                                            size,
-                                            choices,
-                                            style,
-                                            validator,
-                                            name ) )
-            return false;
-
-        m_dclickProcessor = new
-            wxPGDoubleClickProcessor( this, GetGrid()->GetSelection() );
-
-        PushEventHandler(m_dclickProcessor);
-
-        return true;
-    }
-
-    virtual void OnDrawItem( wxDC& dc,
-                             const wxRect& rect,
-                             int item,
-                             int flags ) const
-    {
-        wxPropertyGrid* pg = GetGrid();
-        pg->OnComboItemPaint( this, item, &dc, (wxRect&)rect, flags );
-    }
-
-    virtual wxCoord OnMeasureItem( size_t item ) const
-    {
-        wxPropertyGrid* pg = GetGrid();
-        wxRect rect;
-        rect.x = -1;
-        rect.width = 0;
-        pg->OnComboItemPaint( this, item, NULL, rect, 0 );
-        return rect.height;
-    }
-
-    wxPropertyGrid* GetGrid() const
-    {
-        wxPropertyGrid* pg = wxDynamicCast(GetParent()->GetParent(),
-                                           wxPropertyGrid);
-        wxASSERT(pg);
-        return pg;
-    }
-
-    virtual wxCoord OnMeasureItemWidth( size_t item ) const
-    {
-        wxPropertyGrid* pg = GetGrid();
-        wxRect rect;
-        rect.x = -1;
-        rect.width = -1;
-        pg->OnComboItemPaint( this, item, NULL, rect, 0 );
-        return rect.width;
-    }
-
-    virtual void PositionTextCtrl( int WXUNUSED(textCtrlXAdjust),
-                                   int WXUNUSED(textCtrlYAdjust) )
-    {
-        wxPropertyGrid* pg = GetGrid();
-        wxOwnerDrawnComboBox::PositionTextCtrl(
-            wxPG_TEXTCTRLXADJUST -
-            (wxPG_XBEFOREWIDGET+wxPG_CONTROL_MARGIN+1) - 1,
-            pg->GetSpacingY() + 2
-        );
-    }
-
-private:
-    wxPGDoubleClickProcessor*   m_dclickProcessor;
-    bool                        m_sizeEventCalled;
-};
-
-
-void wxPropertyGrid::OnComboItemPaint( const wxPGComboBox* pCb,
-                                       int item,
-                                       wxDC* pDc,
-                                       wxRect& rect,
-                                       int flags )
-{
-    // Sanity check
-    wxASSERT( IsKindOf(CLASSINFO(wxPropertyGrid)) );
-
-    wxPGProperty* p = m_selected;
-    wxString text;
-
-    const wxPGChoices& choices = p->GetChoices();
-    const wxPGCommonValue* comVal = NULL;
-    int comVals = p->GetDisplayedCommonValueCount();
-    int comValIndex = -1;
-
-    int choiceCount = 0;
-    if ( choices.IsOk() )
-        choiceCount = choices.GetCount();
-
-    if ( item >= choiceCount && comVals > 0 )
-    {
-        comValIndex = item - choiceCount;
-        comVal = GetCommonValue(comValIndex);
-        if ( !p->IsValueUnspecified() )
-            text = comVal->GetLabel();
-    }
-    else
-    {
-        if ( !(flags & wxODCB_PAINTING_CONTROL) )
-        {
-            text = pCb->GetString(item);
-        }
-        else
-        {
-            if ( !p->IsValueUnspecified() )
-                text = p->GetValueAsString(0);
-        }
-    }
-
-    if ( item < 0 )
-        return;
-
-    wxSize cis;
-
-    const wxBitmap* itemBitmap = NULL;
-
-    if ( item >= 0 && choices.IsOk() && choices.Item(item).GetBitmap().Ok() && comValIndex == -1 )
-        itemBitmap = &choices.Item(item).GetBitmap();
-
-    //
-    // Decide what custom image size to use
-    if ( itemBitmap )
-    {
-        cis.x = itemBitmap->GetWidth();
-        cis.y = itemBitmap->GetHeight();
-    }
-    else
-    {
-        cis = GetImageSize(p, item);
-    }
-
-    if ( rect.x < 0 )
-    {
-        // Default measure behaviour (no flexible, custom paint image only)
-        if ( rect.width < 0 )
-        {
-            wxCoord x, y;
-            pCb->GetTextExtent(text, &x, &y, 0, 0);
-            rect.width = cis.x + wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2 + 9 + x;
-        }
-
-        rect.height = cis.y + 2;
-        return;
-    }
-
-    wxPGPaintData paintdata;
-    paintdata.m_parent = NULL;
-    paintdata.m_choiceItem = item;
-
-    // This is by the current (1.0.0b) spec - if painting control, item is -1
-    if ( (flags & wxODCB_PAINTING_CONTROL) )
-        paintdata.m_choiceItem = -1;
-
-    if ( pDc )
-        pDc->SetBrush(*wxWHITE_BRUSH);
-
-    if ( rect.x >= 0 )
-    {
-        //
-        // DrawItem call
-        wxDC& dc = *pDc;
-
-        wxPoint pt(rect.x + wxPG_CONTROL_MARGIN - wxPG_CHOICEXADJUST - 1,
-                   rect.y + 1);
-
-        int renderFlags = wxPGCellRenderer::DontUseCellColours;
-
-        if ( flags & wxODCB_PAINTING_CONTROL )
-            renderFlags |= wxPGCellRenderer::Control;
-        else
-            renderFlags |= wxPGCellRenderer::ChoicePopup;
-
-        if ( flags & wxODCB_PAINTING_SELECTED )
-            renderFlags |= wxPGCellRenderer::Selected;
-
-        if ( cis.x > 0 && (p->HasFlag(wxPG_PROP_CUSTOMIMAGE) || !(flags & wxODCB_PAINTING_CONTROL)) &&
-             ( !p->m_valueBitmap || item == pCb->GetSelection() ) &&
-             ( item >= 0 || (flags & wxODCB_PAINTING_CONTROL) ) &&
-             !itemBitmap
-           )
-        {
-            pt.x += wxCC_CUSTOM_IMAGE_MARGIN1;
-            wxRect r(pt.x,pt.y,cis.x,cis.y);
-
-            if ( flags & wxODCB_PAINTING_CONTROL )
-            {
-                //r.width = cis.x;
-                r.height = wxPG_STD_CUST_IMAGE_HEIGHT(m_lineHeight);
-            }
-
-            paintdata.m_drawnWidth = r.width;
-
-            dc.SetPen(m_colPropFore);
-            if ( comValIndex >= 0 )
-            {
-                const wxPGCommonValue* cv = GetCommonValue(comValIndex);
-                wxPGCellRenderer* renderer = cv->GetRenderer();
-                r.width = rect.width;
-                renderer->Render( dc, r, this, p, m_selColumn, comValIndex, renderFlags );
-                return;
-            }
-            else if ( item >= 0 )
-            {
-                p->OnCustomPaint( dc, r, paintdata );
-            }
-            else
-            {
-                dc.DrawRectangle( r );
-            }
-
-            pt.x += paintdata.m_drawnWidth + wxCC_CUSTOM_IMAGE_MARGIN2 - 1;
-        }
-        else
-        {
-            // TODO: This aligns text so that it seems to be horizontally
-            //       on the same line as property values. Not really
-            //       sure if its needed, but seems to not cause any harm.
-            pt.x -= 1;
-
-            if ( item < 0 && (flags & wxODCB_PAINTING_CONTROL) )
-                item = pCb->GetSelection();
-
-            if ( choices.IsOk() && item >= 0 && comValIndex < 0 )
-            {
-                const wxPGChoiceEntry& cell = choices.Item(item);
-                wxPGCellRenderer* renderer = wxPGGlobalVars->m_defaultRenderer;
-                int imageOffset = renderer->PreDrawCell( dc, rect, cell, renderFlags );
-                if ( imageOffset )
-                    imageOffset += wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2;
-                pt.x += imageOffset;
-            }
-        }
-
-        //
-        // Draw text
-        //
-
-        pt.y += (rect.height-m_fontHeight)/2 - 1;
-
-        pt.x += 1;
-
-        dc.DrawText( text, pt.x + wxPG_XBEFORETEXT, pt.y );
-    }
-    else
-    {
-        //
-        // MeasureItem call
-        wxDC& dc = *pDc;
-
-        p->OnCustomPaint( dc, rect, paintdata );
-        rect.height = paintdata.m_drawnHeight + 2;
-        rect.width = cis.x + wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2 + 9;
-    }
-}
-
-bool wxPGChoiceEditor_SetCustomPaintWidth( wxPropertyGrid* propGrid, wxPGComboBox* cb, int cmnVal )
-{
-    wxPGProperty* property = propGrid->GetSelectedProperty();
-    wxASSERT( property );
-
-    if ( cmnVal >= 0 )
-    {
-        // Yes, a common value is being selected
-        property->SetCommonValue( cmnVal );
-        wxSize imageSize = propGrid->GetCommonValue(cmnVal)->
-                            GetRenderer()->GetImageSize(property, 1, cmnVal);
-        if ( imageSize.x ) imageSize.x += ODCB_CUST_PAINT_MARGIN;
-        cb->SetCustomPaintWidth( imageSize.x );
-        return false;
-    }
-    else
-    {
-        wxSize imageSize = propGrid->GetImageSize(property, -1);
-        if ( imageSize.x ) imageSize.x += ODCB_CUST_PAINT_MARGIN;
-        cb->SetCustomPaintWidth( imageSize.x );
-        return true;
-    }
-}
-
-// CreateControls calls this with CB_READONLY in extraStyle
-wxWindow* wxPGChoiceEditor::CreateControlsBase( wxPropertyGrid* propGrid,
-                                                wxPGProperty* property,
-                                                const wxPoint& pos,
-                                                const wxSize& sz,
-                                                long extraStyle ) const
-{
-    const wxPGChoices& choices = property->GetChoices();
-    wxString defString;
-    int index = property->GetChoiceSelection();
-
-    bool isUnspecified = property->IsValueUnspecified();
-
-    if ( !isUnspecified )
-        defString = property->GetDisplayedString();
-
-    wxArrayString labels = choices.GetLabels();
-
-    wxPGComboBox* cb;
-
-    wxPoint po(pos);
-    wxSize si(sz);
-    po.y += wxPG_CHOICEYADJUST;
-    si.y -= (wxPG_CHOICEYADJUST*2);
-
-    po.x += wxPG_CHOICEXADJUST;
-    si.x -= wxPG_CHOICEXADJUST;
-    wxWindow* ctrlParent = propGrid->GetPanel();
-
-    int odcbFlags = extraStyle | wxBORDER_NONE | wxTE_PROCESS_ENTER;
-
-    //
-    // If common value specified, use appropriate index
-    unsigned int cmnVals = property->GetDisplayedCommonValueCount();
-    if ( cmnVals )
-    {
-        if ( !isUnspecified )
-        {
-            int cmnVal = property->GetCommonValue();
-            if ( cmnVal >= 0 )
-            {
-                index = labels.size() + cmnVal;
-            }
-        }
-
-        unsigned int i;
-        for ( i=0; i<cmnVals; i++ )
-            labels.Add(propGrid->GetCommonValueLabel(i));
-    }
-
-    cb = new wxPGComboBox();
-#ifdef __WXMSW__
-    cb->Hide();
-#endif
-    cb->Create(ctrlParent,
-               wxPG_SUBID1,
-               wxString(),
-               po,
-               si,
-               labels,
-               odcbFlags);
-
-    cb->SetButtonPosition(si.y,0,wxRIGHT);
-    cb->SetTextIndent(wxPG_XBEFORETEXT-1);
-
-    wxPGChoiceEditor_SetCustomPaintWidth( propGrid, cb, property->GetCommonValue() );
-
-    if ( index >= 0 && index < (int)cb->GetCount() )
-    {
-        cb->SetSelection( index );
-        if ( defString.length() )
-            cb->SetText( defString );
-    }
-    else if ( !(extraStyle & wxCB_READONLY) && defString.length() )
-        cb->SetValue( defString );
-    else
-        cb->SetSelection( -1 );
-
-#ifdef __WXMSW__
-    cb->Show();
-#endif
-
-    return (wxWindow*) cb;
-}
-
-
-void wxPGChoiceEditor::UpdateControl( wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxASSERT( ctrl );
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    wxASSERT( cb->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)));
-    int ind = property->GetChoiceSelection();
-    cb->SetSelection(ind);
-}
-
-wxPGWindowList wxPGChoiceEditor::CreateControls( wxPropertyGrid* propGrid, wxPGProperty* property,
-        const wxPoint& pos, const wxSize& sz ) const
-{
-    return CreateControlsBase(propGrid,property,pos,sz,wxCB_READONLY);
-}
-
-
-int wxPGChoiceEditor::InsertItem( wxWindow* ctrl, const wxString& label, int index ) const
-{
-    wxASSERT( ctrl );
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    wxASSERT( cb->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)));
-
-    if (index < 0)
-        index = cb->GetCount();
-
-    return cb->Insert(label,index);
-}
-
-
-void wxPGChoiceEditor::DeleteItem( wxWindow* ctrl, int index ) const
-{
-    wxASSERT( ctrl );
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    wxASSERT( cb->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)));
-
-    cb->Delete(index);
-}
-
-bool wxPGChoiceEditor::OnEvent( wxPropertyGrid* propGrid, wxPGProperty* property,
-    wxWindow* ctrl, wxEvent& event ) const
-{
-    if ( event.GetEventType() == wxEVT_COMMAND_COMBOBOX_SELECTED )
-    {
-        wxPGComboBox* cb = (wxPGComboBox*)ctrl;
-        int index = cb->GetSelection();
-        int cmnValIndex = -1;
-        int cmnVals = property->GetDisplayedCommonValueCount();
-        int items = cb->GetCount();
-
-        if ( index >= (items-cmnVals) )
-        {
-            // Yes, a common value is being selected
-            cmnValIndex = index - (items-cmnVals);
-            property->SetCommonValue( cmnValIndex );
-
-            // Truly set value to unspecified?
-            if ( propGrid->GetUnspecifiedCommonValue() == cmnValIndex )
-            {
-                if ( !property->IsValueUnspecified() )
-                    propGrid->SetInternalFlag(wxPG_FL_VALUE_CHANGE_IN_EVENT);
-                property->SetValueToUnspecified();
-                if ( !cb->HasFlag(wxCB_READONLY) )
-                    cb->GetTextCtrl()->SetValue(wxEmptyString);
-                return false;
-            }
-        }
-        return wxPGChoiceEditor_SetCustomPaintWidth( propGrid, cb, cmnValIndex );        
-    }
-    return false;
-}
-
-
-bool wxPGChoiceEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-
-    int index = cb->GetSelection();
-
-    if ( index != property->GetChoiceSelection() ||
-        // Changing unspecified always causes event (returning
-        // true here should be enough to trigger it).
-         property->IsValueUnspecified()
-       )
-    {
-        return property->IntToValue( variant, index, 0 );
-    }
-    return false;
-}
-
-
-void wxPGChoiceEditor::SetControlStringValue( wxPGProperty* WXUNUSED(property), wxWindow* ctrl, const wxString& txt ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    wxASSERT( cb );
-    cb->SetValue(txt);
-}
-
-
-void wxPGChoiceEditor::SetControlIntValue( wxPGProperty* WXUNUSED(property), wxWindow* ctrl, int value ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    wxASSERT( cb );
-    cb->SetSelection(value);
-}
-
-
-void wxPGChoiceEditor::SetValueToUnspecified( wxPGProperty* WXUNUSED(property), wxWindow* ctrl ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    cb->SetSelection(-1);
-}
-
-
-bool wxPGChoiceEditor::CanContainCustomImage() const
-{
-    return true;
-}
-
-
-wxPGChoiceEditor::~wxPGChoiceEditor() { }
-
-
-// -----------------------------------------------------------------------
-// wxPGComboBoxEditor
-// -----------------------------------------------------------------------
-
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(ComboBox,
-                                      wxPGComboBoxEditor,
-                                      wxPGChoiceEditor)
-
-
-void wxPGComboBoxEditor::UpdateControl( wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    cb->SetValue(property->GetValueAsString(wxPG_EDITABLE_VALUE));
-
-    // TODO: If string matches any selection, then select that.
-}
-
-
-wxPGWindowList wxPGComboBoxEditor::CreateControls( wxPropertyGrid* propGrid,
-                                                   wxPGProperty* property,
-                                                   const wxPoint& pos,
-                                                   const wxSize& sz ) const
-{
-    return CreateControlsBase(propGrid,property,pos,sz,0);
-}
-
-
-bool wxPGComboBoxEditor::OnEvent( wxPropertyGrid* propGrid,
-                                  wxPGProperty* property,
-                                  wxWindow* ctrl,
-                                  wxEvent& event ) const
-{
-    wxOwnerDrawnComboBox* cb = NULL;
-    wxWindow* textCtrl = NULL;
-
-    if ( ctrl )
-    {
-        cb = (wxOwnerDrawnComboBox*)ctrl;
-        textCtrl = cb->GetTextCtrl();
-    }
-
-    if ( wxPGTextCtrlEditor::OnTextCtrlEvent(propGrid,property,textCtrl,event) )
-        return true;
-
-    return wxPGChoiceEditor::OnEvent(propGrid,property,ctrl,event);
-}
-
-
-bool wxPGComboBoxEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    wxString textVal = cb->GetValue();
-
-    if ( property->UsesAutoUnspecified() && !textVal.length() )
-    {
-        variant.MakeNull();
-        return true;
-    }
-
-    bool res = property->StringToValue(variant, textVal, wxPG_EDITABLE_VALUE);
-
-    // Changing unspecified always causes event (returning
-    // true here should be enough to trigger it).
-    if ( !res && variant.IsNull() )
-        res = true;
-
-    return res;
-}
-
-
-void wxPGComboBoxEditor::OnFocus( wxPGProperty*, wxWindow* ctrl ) const
-{
-    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
-    cb->GetTextCtrl()->SetSelection(-1,-1);
-}
-
-
-wxPGComboBoxEditor::~wxPGComboBoxEditor() { }
-
-
-// -----------------------------------------------------------------------
-// wxPGChoiceAndButtonEditor
-// -----------------------------------------------------------------------
-
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(ChoiceAndButton,
-                                      wxPGChoiceAndButtonEditor,
-                                      wxPGChoiceEditor)
-
-
-wxPGWindowList wxPGChoiceAndButtonEditor::CreateControls( wxPropertyGrid* propGrid,
-                                                          wxPGProperty* property,
-                                                          const wxPoint& pos,
-                                                          const wxSize& sz ) const
-{
-    // Use one two units smaller to match size of the combo's dropbutton.
-    // (normally a bigger button is used because it looks better)
-    int bt_wid = sz.y;
-    bt_wid -= 2;
-    wxSize bt_sz(bt_wid,bt_wid);
-
-    // Position of button.
-    wxPoint bt_pos(pos.x+sz.x-bt_sz.x,pos.y);
-#ifdef __WXMAC__
-    bt_pos.y -= 1;
-#else
-    bt_pos.y += 1;
-#endif
-
-    wxWindow* bt = propGrid->GenerateEditorButton( bt_pos, bt_sz );
-
-    // Size of choice.
-    wxSize ch_sz(sz.x-bt->GetSize().x,sz.y);
-
-#ifdef __WXMAC__
-    ch_sz.x -= wxPG_TEXTCTRL_AND_BUTTON_SPACING;
-#endif
-
-    wxWindow* ch = wxPGEditor_Choice->CreateControls(propGrid,property,
-        pos,ch_sz).m_primary;
-
-#ifdef __WXMSW__
-    bt->Show();
-#endif
-
-    return wxPGWindowList(ch, bt);
-}
-
-
-wxPGChoiceAndButtonEditor::~wxPGChoiceAndButtonEditor() { }
-
-
-// -----------------------------------------------------------------------
-// wxPGTextCtrlAndButtonEditor
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(TextCtrlAndButton,
-                                      wxPGTextCtrlAndButtonEditor,
-                                      wxPGTextCtrlEditor)
-
-
-wxPGWindowList wxPGTextCtrlAndButtonEditor::CreateControls( wxPropertyGrid* propGrid,
-                                                            wxPGProperty* property,
-                                                            const wxPoint& pos,
-                                                            const wxSize& sz ) const
-{
-    wxWindow* wnd2;
-    wxWindow* wnd = propGrid->GenerateEditorTextCtrlAndButton( pos, sz, &wnd2,
-        property->GetFlags() & wxPG_PROP_NOEDITOR, property);
-
-    return wxPGWindowList(wnd, wnd2);
-}
-
-
-wxPGTextCtrlAndButtonEditor::~wxPGTextCtrlAndButtonEditor() { }
-
-
-// -----------------------------------------------------------------------
-// wxPGCheckBoxEditor
-// -----------------------------------------------------------------------
-
-#if wxPG_INCLUDE_CHECKBOX
-
-WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(CheckBox,
-                                      wxPGCheckBoxEditor,
-                                      wxPGEditor)
-
-
-// Check box state flags
-enum
-{
-    wxSCB_STATE_UNCHECKED   = 0,
-    wxSCB_STATE_CHECKED     = 1,
-    wxSCB_STATE_BOLD        = 2,
-    wxSCB_STATE_UNSPECIFIED = 4
-};
-
-const int wxSCB_SETVALUE_CYCLE = 2;
-
-
-static void DrawSimpleCheckBox( wxDC& dc, const wxRect& rect, int box_hei,
-                                int state, const wxColour& lineCol )
-{
-    // Box rectangle.
-    wxRect r(rect.x+wxPG_XBEFORETEXT,rect.y+((rect.height-box_hei)/2),
-             box_hei,box_hei);
-    wxColour useCol = lineCol;
-
-    if ( state & wxSCB_STATE_UNSPECIFIED )
-    {
-        useCol = wxColour(220, 220, 220);
-    }
-
-    // Draw check mark first because it is likely to overdraw the
-    // surrounding rectangle.
-    if ( state & wxSCB_STATE_CHECKED )
-    {
-        wxRect r2(r.x+wxPG_CHECKMARK_XADJ,
-                  r.y+wxPG_CHECKMARK_YADJ,
-                  r.width+wxPG_CHECKMARK_WADJ,
-                  r.height+wxPG_CHECKMARK_HADJ);
-    #if wxPG_CHECKMARK_DEFLATE
-        r2.Deflate(wxPG_CHECKMARK_DEFLATE);
-    #endif
-        dc.DrawCheckMark(r2);
-
-        // This would draw a simple cross check mark.
-        // dc.DrawLine(r.x,r.y,r.x+r.width-1,r.y+r.height-1);
-        // dc.DrawLine(r.x,r.y+r.height-1,r.x+r.width-1,r.y);
-    }
-
-    if ( !(state & wxSCB_STATE_BOLD) )
-    {
-        // Pen for thin rectangle.
-        dc.SetPen(useCol);
-    }
-    else
-    {
-        // Pen for bold rectangle.
-        wxPen linepen(useCol,2,wxSOLID);
-        linepen.SetJoin(wxJOIN_MITER); // This prevents round edges.
-        dc.SetPen(linepen);
-        r.x++;
-        r.y++;
-        r.width--;
-        r.height--;
-    }
-
-    dc.SetBrush(*wxTRANSPARENT_BRUSH);
-
-    dc.DrawRectangle(r);
-    dc.SetPen(*wxTRANSPARENT_PEN);
-}
-
-//
-// Real simple custom-drawn checkbox-without-label class.
-//
-class wxSimpleCheckBox : public wxControl
-{
-public:
-
-    void SetValue( int value );
-
-    wxSimpleCheckBox( wxWindow* parent,
-                      wxWindowID id,
-                      const wxPoint& pos = wxDefaultPosition,
-                      const wxSize& size = wxDefaultSize )
-        : wxControl(parent,id,pos,size,wxBORDER_NONE|wxWANTS_CHARS)
-    {
-        // Due to SetOwnFont stuff necessary for GTK+ 1.2, we need to have this
-        SetFont( parent->GetFont() );
-
-        m_state = 0;
-        m_boxHeight = 12;
-
-        SetBackgroundStyle( wxBG_STYLE_CUSTOM );
-    }
-
-    virtual ~wxSimpleCheckBox();
-
-    int m_state;
-    int m_boxHeight;
-
-private:
-    void OnPaint( wxPaintEvent& event );
-    void OnLeftClick( wxMouseEvent& event );
-    void OnKeyDown( wxKeyEvent& event );
-
-    void OnResize( wxSizeEvent& event )
-    {
-        Refresh();
-        event.Skip();
-    }
-
-    static wxBitmap* ms_doubleBuffer;
-
-    DECLARE_EVENT_TABLE()
-};
-
-BEGIN_EVENT_TABLE(wxSimpleCheckBox, wxControl)
-    EVT_PAINT(wxSimpleCheckBox::OnPaint)
-    EVT_LEFT_DOWN(wxSimpleCheckBox::OnLeftClick)
-    EVT_LEFT_DCLICK(wxSimpleCheckBox::OnLeftClick)
-    EVT_KEY_DOWN(wxSimpleCheckBox::OnKeyDown)
-    EVT_SIZE(wxSimpleCheckBox::OnResize)
-END_EVENT_TABLE()
-
-wxSimpleCheckBox::~wxSimpleCheckBox()
-{
-    delete ms_doubleBuffer;
-    ms_doubleBuffer = NULL;
-}
-
-wxBitmap* wxSimpleCheckBox::ms_doubleBuffer = NULL;
-
-void wxSimpleCheckBox::OnPaint( wxPaintEvent& WXUNUSED(event) )
-{
-    wxSize clientSize = GetClientSize();
-    wxAutoBufferedPaintDC dc(this);
-
-    dc.Clear();
-    wxRect rect(0,0,clientSize.x,clientSize.y);
-    rect.y += 1;
-    rect.width += 1;
-
-    wxColour bgcol = GetBackgroundColour();
-    dc.SetBrush( bgcol );
-    dc.SetPen( bgcol );
-    dc.DrawRectangle( rect );
-
-    wxColour txcol = GetForegroundColour();
-
-    int state = m_state;
-    if ( !(state & wxSCB_STATE_UNSPECIFIED) &&
-         GetFont().GetWeight() == wxBOLD )
-        state |= wxSCB_STATE_BOLD;
-
-    DrawSimpleCheckBox(dc,rect,m_boxHeight,state,txcol);
-}
-
-void wxSimpleCheckBox::OnLeftClick( wxMouseEvent& event )
-{
-    if ( (event.m_x > (wxPG_XBEFORETEXT-2)) &&
-         (event.m_x <= (wxPG_XBEFORETEXT-2+m_boxHeight)) )
-    {
-        SetValue(wxSCB_SETVALUE_CYCLE);
-    }
-}
-
-void wxSimpleCheckBox::OnKeyDown( wxKeyEvent& event )
-{
-    if ( event.GetKeyCode() == WXK_SPACE )
-    {
-        SetValue(wxSCB_SETVALUE_CYCLE);
-    }
-}
-
-void wxSimpleCheckBox::SetValue( int value )
-{
-    if ( value == wxSCB_SETVALUE_CYCLE )
-    {
-        if ( m_state & wxSCB_STATE_CHECKED )
-            m_state &= ~wxSCB_STATE_CHECKED;
-        else
-            m_state |= wxSCB_STATE_CHECKED;
-    }
-    else
-    {
-        m_state = value;
-    }
-    Refresh();
-
-    wxCommandEvent evt(wxEVT_COMMAND_CHECKBOX_CLICKED,GetParent()->GetId());
-
-    wxPropertyGrid* propGrid = (wxPropertyGrid*) GetParent()->GetParent();
-    wxASSERT( propGrid->IsKindOf(CLASSINFO(wxPropertyGrid)) );
-    propGrid->HandleCustomEditorEvent(evt);
-}
-
-wxPGWindowList wxPGCheckBoxEditor::CreateControls( wxPropertyGrid* propGrid,
-                                                   wxPGProperty* property,
-                                                   const wxPoint& pos,
-                                                   const wxSize& size ) const
-{
-    wxPoint pt = pos;
-    pt.x -= wxPG_XBEFOREWIDGET;
-    wxSize sz = size;
-    sz.x = propGrid->GetFontHeight() + (wxPG_XBEFOREWIDGET*2) + 4;
-
-    wxSimpleCheckBox* cb = new wxSimpleCheckBox(propGrid->GetPanel(),
-                                                wxPG_SUBID1, pt, sz);
-
-    cb->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW));
-
-    UpdateControl(property, cb);
-
-    if ( !property->IsValueUnspecified() )
-    {
-        // If mouse cursor was on the item, toggle the value now.
-        if ( propGrid->GetInternalFlags() & wxPG_FL_ACTIVATION_BY_CLICK )
-        {
-            wxPoint pt = cb->ScreenToClient(::wxGetMousePosition());
-            if ( pt.x <= (wxPG_XBEFORETEXT-2+cb->m_boxHeight) )
-            {
-                if ( cb->m_state & wxSCB_STATE_CHECKED )
-                    cb->m_state &= ~wxSCB_STATE_CHECKED;
-                else
-                    cb->m_state |= wxSCB_STATE_CHECKED;
-
-                // Makes sure wxPG_EVT_CHANGING etc. is sent for this initial
-                // click 
-                propGrid->ChangePropertyValue(property,
-                                              wxPGVariant_Bool(cb->m_state));
-            }
-        }
-    }
-
-    propGrid->SetInternalFlag( wxPG_FL_FIXED_WIDTH_EDITOR );
-
-    return cb;
-}
-
-void wxPGCheckBoxEditor::DrawValue( wxDC& dc, const wxRect& rect,
-                                    wxPGProperty* property,
-                                    const wxString& WXUNUSED(text) ) const
-{
-    int state = wxSCB_STATE_UNCHECKED;
-    wxColour rectCol = dc.GetTextForeground();
-
-    if ( !property->IsValueUnspecified() )
-    {
-        state = property->GetChoiceSelection();
-        if ( dc.GetFont().GetWeight() == wxBOLD )
-            state |= wxSCB_STATE_BOLD;
-    }
-    else
-    {
-        state |= wxSCB_STATE_UNSPECIFIED;
-    }
-
-    DrawSimpleCheckBox(dc, rect, dc.GetCharHeight(), state, rectCol);
-}
-
-void wxPGCheckBoxEditor::UpdateControl( wxPGProperty* property,
-                                        wxWindow* ctrl ) const
-{
-    wxSimpleCheckBox* cb = (wxSimpleCheckBox*) ctrl;
-    wxASSERT( cb );
-
-    if ( !property->IsValueUnspecified() )
-        cb->m_state = property->GetChoiceSelection();
-    else
-        cb->m_state = wxSCB_STATE_UNSPECIFIED;
-
-    wxPropertyGrid* propGrid = property->GetGrid();
-    cb->m_boxHeight = propGrid->GetFontHeight();
-
-    cb->Refresh();
-}
-
-bool wxPGCheckBoxEditor::OnEvent( wxPropertyGrid* WXUNUSED(propGrid), wxPGProperty* WXUNUSED(property),
-    wxWindow* WXUNUSED(ctrl), wxEvent& event ) const
-{
-    if ( event.GetEventType() == wxEVT_COMMAND_CHECKBOX_CLICKED )
-    {
-        return true;
-    }
-    return false;
-}
-
-
-bool wxPGCheckBoxEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
-{
-    wxSimpleCheckBox* cb = (wxSimpleCheckBox*)ctrl;
-
-    int index = cb->m_state;
-
-    if ( index != property->GetChoiceSelection() ||
-         // Changing unspecified always causes event (returning
-         // true here should be enough to trigger it).
-         property->IsValueUnspecified()
-       )
-    {
-        return property->IntToValue(variant, index, 0);
-    }
-    return false;
-}
-
-
-void wxPGCheckBoxEditor::SetControlIntValue( wxPGProperty* WXUNUSED(property), wxWindow* ctrl, int value ) const
-{
-    if ( value != 0 ) value = 1;
-    ((wxSimpleCheckBox*)ctrl)->m_state = value;
-    ctrl->Refresh();
-}
-
-
-void wxPGCheckBoxEditor::SetValueToUnspecified( wxPGProperty* WXUNUSED(property), wxWindow* ctrl ) const
-{
-    ((wxSimpleCheckBox*)ctrl)->m_state = 0;
-    ctrl->Refresh();
-}
-
-
-wxPGCheckBoxEditor::~wxPGCheckBoxEditor() { }
-
-
-#endif // wxPG_INCLUDE_CHECKBOX
-
-// -----------------------------------------------------------------------
-
-wxWindow* wxPropertyGrid::GetEditorControl() const
-{
-    wxWindow* ctrl = m_wndEditor;
-
-    if ( !ctrl )
-        return ctrl;
-
-    return ctrl;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::CorrectEditorWidgetSizeX()
-{
-    if ( m_selColumn == -1 )
-        return;
-
-    int secWid = 0;
-    int newSplitterx = m_pState->DoGetSplitterPosition(m_selColumn-1);
-    int newWidth = newSplitterx + m_pState->m_colWidths[m_selColumn];
-
-    if ( m_wndEditor2 )
-    {
-        // if width change occurred, move secondary wnd by that amount
-        wxRect r = m_wndEditor2->GetRect();
-        secWid = r.width;
-        r.x = newWidth - secWid;
-
-        m_wndEditor2->SetSize( r );
-
-        // if primary is textctrl, then we have to add some extra space
-#ifdef __WXMAC__
-        if ( m_wndEditor )
-#else
-        if ( m_wndEditor && m_wndEditor->IsKindOf(CLASSINFO(wxTextCtrl)) )
-#endif
-            secWid += wxPG_TEXTCTRL_AND_BUTTON_SPACING;
-    }
-
-    if ( m_wndEditor )
-    {
-        wxRect r = m_wndEditor->GetRect();
-
-        r.x = newSplitterx+m_ctrlXAdjust;
-
-        if ( !(m_iFlags & wxPG_FL_FIXED_WIDTH_EDITOR) )
-            r.width = newWidth - r.x - secWid;
-
-        m_wndEditor->SetSize(r);
-    }
-
-    if ( m_wndEditor2 )
-        m_wndEditor2->Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::CorrectEditorWidgetPosY()
-{
-    if ( m_selColumn == -1 )
-        return;
-
-    if ( m_selected && (m_wndEditor || m_wndEditor2) ) 
-    {
-        wxRect r = GetEditorWidgetRect(m_selected, m_selColumn);
-
-        if ( m_wndEditor )
-        {
-            wxPoint pos = m_wndEditor->GetPosition();
-
-            // Calculate y offset
-            int offset = pos.y % m_lineHeight;
-
-            m_wndEditor->Move(pos.x, r.y + offset);
-        }
-
-        if ( m_wndEditor2 )
-        {
-            wxPoint pos = m_wndEditor2->GetPosition();
-
-            m_wndEditor2->Move(pos.x, r.y);
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-// Fixes position of wxTextCtrl-like control (wxSpinCtrl usually
-// fits into that category as well).
-void wxPropertyGrid::FixPosForTextCtrl( wxWindow* ctrl, const wxPoint& offset )
-{
-    // Center the control vertically
-    wxRect finalPos = ctrl->GetRect();
-    int y_adj = (m_lineHeight - finalPos.height)/2 + wxPG_TEXTCTRLYADJUST;
-
-    // Prevent over-sized control
-    int sz_dec = (y_adj + finalPos.height) - m_lineHeight;
-    if ( sz_dec < 0 ) sz_dec = 0;
-
-    finalPos.y += y_adj;
-    finalPos.height -= (y_adj+sz_dec);
-
-    const int textCtrlXAdjust = wxPG_TEXTCTRLXADJUST;
-
-    finalPos.x += textCtrlXAdjust;
-    finalPos.width -= textCtrlXAdjust;
-
-    finalPos.x += offset.x;
-    finalPos.y += offset.y;
-
-    ctrl->SetSize(finalPos);
-}
-
-// -----------------------------------------------------------------------
-
-wxWindow* wxPropertyGrid::GenerateEditorTextCtrl( const wxPoint& pos,
-                                                  const wxSize& sz,
-                                                  const wxString& value,
-                                                  wxWindow* secondary,
-                                                  int extraStyle,
-                                                  int maxLen )
-{
-    wxWindowID id = wxPG_SUBID1;
-    wxPGProperty* prop = m_selected;
-    wxASSERT(prop);
-
-    int tcFlags = wxTE_PROCESS_ENTER | extraStyle;
-
-    if ( prop->HasFlag(wxPG_PROP_READONLY) )
-        tcFlags |= wxTE_READONLY;
-
-    wxPoint p(pos.x,pos.y);
-    wxSize s(sz.x,sz.y);
-
-   // Need to reduce width of text control on Mac
-#if defined(__WXMAC__)
-    s.x -= 8;
-#endif
-
-     // Take button into acccount
-    if ( secondary )
-    {
-        s.x -= (secondary->GetSize().x + wxPG_TEXTCTRL_AND_BUTTON_SPACING);
-        m_iFlags &= ~(wxPG_FL_PRIMARY_FILLS_ENTIRE);
-    }
-
-    // If the height is significantly higher, then use border, and fill the rect exactly.
-    bool hasSpecialSize = false;
-
-    if ( (sz.y - m_lineHeight) > 5 )
-        hasSpecialSize = true;
-
-    wxWindow* ctrlParent = GetPanel();
-
-    if ( !hasSpecialSize )
-        tcFlags |= wxBORDER_NONE;
-
-    wxTextCtrl* tc = new wxTextCtrl();
-
-#if defined(__WXMSW__)
-    tc->Hide();
-#endif
-    SetupTextCtrlValue(value);
-    tc->Create(ctrlParent,id,value, p, s,tcFlags);
-    
-    // Center the control vertically
-    if ( !hasSpecialSize )
-        FixPosForTextCtrl(tc);
-
-#ifdef __WXMSW__
-    tc->Show();
-    if ( secondary )
-        secondary->Show();
-#endif
-
-    // Set maximum length
-    if ( maxLen > 0 )
-        tc->SetMaxLength( maxLen );
-
-    wxVariant attrVal = prop->GetAttribute(wxPG_ATTR_AUTOCOMPLETE);
-    if ( !attrVal.IsNull() )
-    {
-        wxASSERT(attrVal.GetType() == wxS("arrstring"));
-        tc->AutoComplete(attrVal.GetArrayString());
-    }
-
-    return tc;
-}
-
-// -----------------------------------------------------------------------
-
-wxWindow* wxPropertyGrid::GenerateEditorButton( const wxPoint& pos, const wxSize& sz )
-{
-    wxWindowID id = wxPG_SUBID2;
-    wxPGProperty* selected = m_selected;
-    wxASSERT(selected);
-
-#ifdef __WXMAC__
-   // Decorations are chunky on Mac, and we can't make the button square, so
-   // do things a bit differently on this platform.
-
-   wxPoint p(pos.x+sz.x,
-             pos.y+wxPG_BUTTON_SIZEDEC-wxPG_NAT_BUTTON_BORDER_Y);
-   wxSize s(25, -1);
-
-   wxButton* but = new wxButton();
-   but->Create(GetPanel(),id,wxS("..."),p,s,wxWANTS_CHARS);
-
-   // Now that we know the size, move to the correct position
-   p.x = pos.x + sz.x - but->GetSize().x - 2;
-   but->Move(p);
-
-#else 
-    wxSize s(sz.y-(wxPG_BUTTON_SIZEDEC*2)+(wxPG_NAT_BUTTON_BORDER_Y*2),
-        sz.y-(wxPG_BUTTON_SIZEDEC*2)+(wxPG_NAT_BUTTON_BORDER_Y*2));
-
-    // Reduce button width to lineheight
-    if ( s.x > m_lineHeight )
-        s.x = m_lineHeight;
-
-#ifdef __WXGTK__
-    // On wxGTK, take fixed button margins into account
-    if ( s.x < 25 )
-        s.x = 25;
-#endif
-
-    wxPoint p(pos.x+sz.x-s.x,
-        pos.y+wxPG_BUTTON_SIZEDEC-wxPG_NAT_BUTTON_BORDER_Y);
-
-    wxButton* but = new wxButton();
-  #ifdef __WXMSW__
-    but->Hide();
-  #endif
-    but->Create(GetPanel(),id,wxS("..."),p,s,wxWANTS_CHARS);
-
-  #ifdef __WXGTK__
-    wxFont font = GetFont();
-    font.SetPointSize(font.GetPointSize()-2);
-    but->SetFont(font);
-  #else
-    but->SetFont(GetFont());
-  #endif
-#endif
-
-    if ( selected->HasFlag(wxPG_PROP_READONLY) )
-        but->Disable();
-
-    return but;
-}
-
-// -----------------------------------------------------------------------
-
-wxWindow* wxPropertyGrid::GenerateEditorTextCtrlAndButton( const wxPoint& pos,
-                                                           const wxSize& sz,
-                                                           wxWindow** psecondary,
-                                                           int limitedEditing,
-                                                           wxPGProperty* property )
-{
-    wxButton* but = (wxButton*)GenerateEditorButton(pos,sz);
-    *psecondary = (wxWindow*)but;
-
-    if ( limitedEditing )
-    {
-    #ifdef __WXMSW__
-        // There is button Show in GenerateEditorTextCtrl as well
-        but->Show();
-    #endif
-        return NULL;
-    }
-
-    wxString text;
-
-    if ( !property->IsValueUnspecified() )
-        text = property->GetValueAsString(property->HasFlag(wxPG_PROP_READONLY)?0:wxPG_EDITABLE_VALUE);
-
-    return GenerateEditorTextCtrl(pos,sz,text,but,property->m_maxLen);
-}
-
-// -----------------------------------------------------------------------
-
-wxTextCtrl* wxPropertyGrid::GetEditorTextCtrl() const
-{
-    wxWindow* wnd = GetEditorControl();
-
-    if ( !wnd )
-        return NULL;
-
-    if ( wnd->IsKindOf(CLASSINFO(wxTextCtrl)) )
-        return wxStaticCast(wnd, wxTextCtrl);
-
-    if ( wnd->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)) )
-    {
-        wxOwnerDrawnComboBox* cb = wxStaticCast(wnd, wxOwnerDrawnComboBox);
-        return cb->GetTextCtrl();
-    }
-
-    return NULL;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGEditor* wxPropertyGridInterface::GetEditorByName( const wxString& editorName )
-{
-    wxPGHashMapS2P::const_iterator it;
-
-    it = wxPGGlobalVars->m_mapEditorClasses.find(editorName);
-    if ( it == wxPGGlobalVars->m_mapEditorClasses.end() )
-        return NULL;
-    return (wxPGEditor*) it->second;
-}
-
-// -----------------------------------------------------------------------
-// wxPGEditorDialogAdapter
-// -----------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(wxPGEditorDialogAdapter, wxObject)
-
-bool wxPGEditorDialogAdapter::ShowDialog( wxPropertyGrid* propGrid, wxPGProperty* property )
-{
-    if ( !propGrid->EditorValidate() )
-        return false;
-
-    bool res = DoShowDialog( propGrid, property );
-
-    if ( res )
-    {
-        propGrid->ValueChangeInEvent( m_value );
-        return true;
-    }
-
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPGMultiButton
-// -----------------------------------------------------------------------
-
-wxPGMultiButton::wxPGMultiButton( wxPropertyGrid* pg, const wxSize& sz )
-    : wxWindow( pg->GetPanel(), wxPG_SUBID2, wxPoint(-100,-100), wxSize(0, sz.y) ),
-      m_fullEditorSize(sz), m_buttonsWidth(0)
-{
-    SetBackgroundColour(pg->GetCellBackgroundColour());
-}
-
-void wxPGMultiButton::Finalize( wxPropertyGrid* WXUNUSED(propGrid),
-                                const wxPoint& pos )
-{
-    Move( pos.x + m_fullEditorSize.x - m_buttonsWidth, pos.y );
-}
-
-int wxPGMultiButton::GenId( int id ) const
-{
-    if ( id < -1 )
-    {
-        if ( m_buttons.size() )
-            id = GetButton(m_buttons.size()-1)->GetId() + 1;
-        else
-            id = wxPG_SUBID2;
-    }
-    return id;
-}
-
-#if wxUSE_BMPBUTTON
-void wxPGMultiButton::Add( const wxBitmap& bitmap, int id )
-{
-    id = GenId(id);
-    wxSize sz = GetSize();
-    wxButton* button = new wxBitmapButton( this, id, bitmap,
-                                           wxPoint(sz.x, 0),
-                                           wxSize(sz.y, sz.y) );
-    DoAddButton( button, sz );
-}
-#endif
-
-void wxPGMultiButton::Add( const wxString& label, int id )
-{
-    id = GenId(id);
-    wxSize sz = GetSize();
-    wxButton* button = new wxButton( this, id, label, wxPoint(sz.x, 0),
-                                     wxSize(sz.y, sz.y) );
-    DoAddButton( button, sz );
-}
-
-void wxPGMultiButton::DoAddButton( wxWindow* button,
-                                   const wxSize& sz )
-{
-    m_buttons.push_back(button);
-    int bw = button->GetSize().x;
-    SetSize(wxSize(sz.x+bw,sz.y));
-    m_buttonsWidth += bw;
-}
-
-// -----------------------------------------------------------------------
-
-#endif  // wxUSE_PROPGRID
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/editors.cpp
+// Purpose:     wxPropertyGrid editors
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2007-04-14
+// RCS-ID:      $Id: editors.cpp 59451 2009-03-09 18:33:41Z JMS $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcclient.h"
+    #include "wx/dcmemory.h"
+    #include "wx/button.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/cursor.h"
+    #include "wx/dialog.h"
+    #include "wx/settings.h"
+    #include "wx/msgdlg.h"
+    #include "wx/choice.h"
+    #include "wx/stattext.h"
+    #include "wx/scrolwin.h"
+    #include "wx/dirdlg.h"
+    #include "wx/sizer.h"
+    #include "wx/textdlg.h"
+    #include "wx/filedlg.h"
+    #include "wx/statusbr.h"
+    #include "wx/intl.h"
+    #include "wx/frame.h"
+#endif
+
+
+#include "wx/timer.h"
+#include "wx/dcbuffer.h"
+#include "wx/bmpbuttn.h"
+
+
+// This define is necessary to prevent macro clearing
+#define __wxPG_SOURCE_FILE__
+
+#include "wx/propgrid/propgrid.h"
+#include "wx/propgrid/editors.h"
+#include "wx/propgrid/props.h"
+
+#if wxPG_USE_RENDERER_NATIVE
+    #include "wx/renderer.h"
+#endif
+
+// How many pixels between textctrl and button
+#ifdef __WXMAC__
+    #define wxPG_TEXTCTRL_AND_BUTTON_SPACING        4
+#else
+    #define wxPG_TEXTCTRL_AND_BUTTON_SPACING        2
+#endif 
+
+#define wxPG_BUTTON_SIZEDEC                         0
+
+#include "wx/odcombo.h"
+
+#ifdef __WXMSW__
+    #include "wx/msw/private.h"
+#endif
+
+// -----------------------------------------------------------------------
+
+#if defined(__WXMSW__)
+    // tested
+    #define wxPG_NAT_BUTTON_BORDER_ANY          1
+    #define wxPG_NAT_BUTTON_BORDER_X            1
+    #define wxPG_NAT_BUTTON_BORDER_Y            1
+
+    #define wxPG_CHECKMARK_XADJ                 1
+    #define wxPG_CHECKMARK_YADJ                 (-1)
+    #define wxPG_CHECKMARK_WADJ                 0
+    #define wxPG_CHECKMARK_HADJ                 0
+    #define wxPG_CHECKMARK_DEFLATE              0
+
+    #define wxPG_TEXTCTRLYADJUST                (m_spacingy+0)
+
+#elif defined(__WXGTK__)
+    // tested
+    #define wxPG_CHECKMARK_XADJ                 0
+    #define wxPG_CHECKMARK_YADJ                 0
+    #define wxPG_CHECKMARK_WADJ                 (-1)
+    #define wxPG_CHECKMARK_HADJ                 (-1)
+    #define wxPG_CHECKMARK_DEFLATE              3
+
+    #define wxPG_NAT_BUTTON_BORDER_ANY      1
+    #define wxPG_NAT_BUTTON_BORDER_X        1
+    #define wxPG_NAT_BUTTON_BORDER_Y        1
+
+    #define wxPG_TEXTCTRLYADJUST            0
+
+#elif defined(__WXMAC__)
+    // *not* tested
+    #define wxPG_CHECKMARK_XADJ                 0
+    #define wxPG_CHECKMARK_YADJ                 0
+    #define wxPG_CHECKMARK_WADJ                 0
+    #define wxPG_CHECKMARK_HADJ                 0
+    #define wxPG_CHECKMARK_DEFLATE              0
+
+    #define wxPG_NAT_BUTTON_BORDER_ANY      0
+    #define wxPG_NAT_BUTTON_BORDER_X        0
+    #define wxPG_NAT_BUTTON_BORDER_Y        0
+
+    #define wxPG_TEXTCTRLYADJUST            0
+
+#else
+    // defaults
+    #define wxPG_CHECKMARK_XADJ                 0
+    #define wxPG_CHECKMARK_YADJ                 0
+    #define wxPG_CHECKMARK_WADJ                 0
+    #define wxPG_CHECKMARK_HADJ                 0
+    #define wxPG_CHECKMARK_DEFLATE              0
+
+    #define wxPG_NAT_BUTTON_BORDER_ANY      0
+    #define wxPG_NAT_BUTTON_BORDER_X        0
+    #define wxPG_NAT_BUTTON_BORDER_Y        0
+
+    #define wxPG_TEXTCTRLYADJUST            0
+
+#endif
+
+// for odcombo
+#ifdef __WXMAC__
+#define wxPG_CHOICEXADJUST           -3 // required because wxComboCtrl reserves 3pixels for wxTextCtrl's focus ring
+#define wxPG_CHOICEYADJUST           -3 
+#else
+#define wxPG_CHOICEXADJUST           0
+#define wxPG_CHOICEYADJUST           0
+#endif
+
+#define ODCB_CUST_PAINT_MARGIN               6  // Number added to image width for SetCustomPaintWidth
+
+// Milliseconds to wait for two mouse-ups after focus inorder
+// to trigger a double-click.
+#define DOUBLE_CLICK_CONVERSION_TRESHOLD        500
+
+// -----------------------------------------------------------------------
+// wxPGEditor
+// -----------------------------------------------------------------------
+
+IMPLEMENT_ABSTRACT_CLASS(wxPGEditor, wxObject)
+
+
+wxPGEditor::~wxPGEditor()
+{
+}
+
+wxString wxPGEditor::GetName() const
+{
+    return GetClassInfo()->GetClassName();
+}
+
+void wxPGEditor::DrawValue( wxDC& dc, const wxRect& rect, wxPGProperty* property, const wxString& text ) const
+{
+    if ( !property->IsValueUnspecified() )
+        dc.DrawText( text, rect.x+wxPG_XBEFORETEXT, rect.y );
+}
+
+bool wxPGEditor::GetValueFromControl( wxVariant&, wxPGProperty*, wxWindow* ) const
+{
+    return false;
+}
+
+void wxPGEditor::SetControlStringValue( wxPGProperty* WXUNUSED(property), wxWindow*, const wxString& ) const
+{
+}
+
+
+void wxPGEditor::SetControlIntValue( wxPGProperty* WXUNUSED(property), wxWindow*, int ) const
+{
+}
+
+
+int wxPGEditor::InsertItem( wxWindow*, const wxString&, int ) const
+{
+    return -1;
+}
+
+
+void wxPGEditor::DeleteItem( wxWindow*, int ) const
+{
+    return;
+}
+
+
+void wxPGEditor::OnFocus( wxPGProperty*, wxWindow* ) const
+{
+}
+
+
+bool wxPGEditor::CanContainCustomImage() const
+{
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPGTextCtrlEditor
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(TextCtrl,wxPGTextCtrlEditor,wxPGEditor)
+
+
+wxPGWindowList wxPGTextCtrlEditor::CreateControls( wxPropertyGrid* propGrid,
+                                                   wxPGProperty* property,
+                                                   const wxPoint& pos,
+                                                   const wxSize& sz ) const
+{
+    wxString text;
+
+    //
+    // If has children, and limited editing is specified, then don't create.
+    if ( (property->GetFlags() & wxPG_PROP_NOEDITOR) &&
+         property->GetChildCount() )
+        return NULL;
+
+    if ( !property->IsValueUnspecified() )
+        text = property->GetValueAsString(property->HasFlag(wxPG_PROP_READONLY) ?
+                                            0 : wxPG_EDITABLE_VALUE);
+
+    int flags = 0;
+    if ( (property->GetFlags() & wxPG_PROP_PASSWORD) &&
+         property->IsKindOf(CLASSINFO(wxStringProperty)) )
+        flags |= wxTE_PASSWORD;
+
+    wxWindow* wnd = propGrid->GenerateEditorTextCtrl(pos,sz,text,NULL,flags,
+                                                     property->GetMaxLength());
+
+    return wnd;
+}
+
+#if 0
+void wxPGTextCtrlEditor::DrawValue( wxDC& dc, wxPGProperty* property, const wxRect& rect ) const
+{
+    if ( !property->IsValueUnspecified() )
+    {
+        wxString drawStr = property->GetDisplayedString();
+
+        // Code below should no longer be needed, as the obfuscation
+        // is now done in GetValueAsString.
+        /*if ( (property->GetFlags() & wxPG_PROP_PASSWORD) &&
+             property->IsKindOf(WX_PG_CLASSINFO(wxStringProperty)) )
+        {
+            size_t a = drawStr.length();
+            drawStr.Empty();
+            drawStr.Append(wxS('*'),a);
+        }*/
+        dc.DrawText( drawStr, rect.x+wxPG_XBEFORETEXT, rect.y );
+    }
+}
+#endif
+
+void wxPGTextCtrlEditor::UpdateControl( wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxTextCtrl* tc = wxDynamicCast(ctrl, wxTextCtrl);
+    if (!tc) return;
+
+    wxString s;
+
+    if ( tc->HasFlag(wxTE_PASSWORD) )
+        s = property->GetValueAsString(wxPG_FULL_VALUE);
+    else
+        s = property->GetDisplayedString();
+
+    tc->SetValue(s);
+
+    //
+    // Fix indentation, just in case (change in font boldness is one good
+    // reason).
+#if defined(__WXMSW__) && !defined(__WXWINCE__)
+    ::SendMessage(GetHwndOf(tc),
+                  EM_SETMARGINS,
+                  EC_LEFTMARGIN | EC_RIGHTMARGIN,
+                  MAKELONG(0, 0));
+#endif
+}
+
+// Provided so that, for example, ComboBox editor can use the same code
+// (multiple inheritance would get way too messy).
+bool wxPGTextCtrlEditor::OnTextCtrlEvent( wxPropertyGrid* propGrid,
+                                          wxPGProperty* WXUNUSED(property),
+                                          wxWindow* ctrl,
+                                          wxEvent& event )
+{
+    if ( !ctrl )
+        return false;
+
+    if ( event.GetEventType() == wxEVT_COMMAND_TEXT_ENTER )
+    {
+        if ( propGrid->IsEditorsValueModified() )
+        {
+            return true;
+        }
+    }
+    else if ( event.GetEventType() == wxEVT_COMMAND_TEXT_UPDATED )
+    {
+        //
+        // Pass this event outside wxPropertyGrid so that,
+        // if necessary, program can tell when user is editing
+        // a textctrl.
+        // FIXME: Is it safe to change event id in the middle of event
+        //        processing (seems to work, but...)?
+        event.Skip();
+        event.SetId(propGrid->GetId());
+
+        propGrid->EditorsValueWasModified();
+    }
+    return false;
+}
+
+
+bool wxPGTextCtrlEditor::OnEvent( wxPropertyGrid* propGrid,
+                                  wxPGProperty* property,
+                                  wxWindow* ctrl,
+                                  wxEvent& event ) const
+{
+    return wxPGTextCtrlEditor::OnTextCtrlEvent(propGrid,property,ctrl,event);
+}
+
+
+bool wxPGTextCtrlEditor::GetTextCtrlValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl )
+{
+    wxTextCtrl* tc = wxStaticCast(ctrl, wxTextCtrl);
+    wxString textVal = tc->GetValue();
+
+    if ( property->UsesAutoUnspecified() && !textVal.length() )
+    {
+        variant.MakeNull();
+        return true;
+    }
+
+    bool res = property->StringToValue(variant, textVal, wxPG_EDITABLE_VALUE);
+
+    // Changing unspecified always causes event (returning
+    // true here should be enough to trigger it).
+    // TODO: Move to propgrid.cpp
+    if ( !res && variant.IsNull() )
+        res = true;
+
+    return res;
+}
+
+
+bool wxPGTextCtrlEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
+{
+    return wxPGTextCtrlEditor::GetTextCtrlValueFromControl(variant, property, ctrl);
+}
+
+
+void wxPGTextCtrlEditor::SetValueToUnspecified( wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxTextCtrl* tc = wxStaticCast(ctrl, wxTextCtrl);
+
+    wxPropertyGrid* pg = property->GetGrid();
+    wxASSERT(pg);  // Really, property grid should exist if editor does
+    if ( pg )
+        tc->SetValue(wxEmptyString);
+}
+
+
+void wxPGTextCtrlEditor::SetControlStringValue( wxPGProperty* property, wxWindow* ctrl, const wxString& txt ) const
+{
+    wxTextCtrl* tc = wxStaticCast(ctrl, wxTextCtrl);
+
+    wxPropertyGrid* pg = property->GetGrid();
+    wxASSERT(pg);  // Really, property grid should exist if editor does
+    if ( pg )
+        tc->SetValue(txt);
+}
+
+
+void wxPGTextCtrlEditor::OnFocus( wxPGProperty*, wxWindow* wnd ) const
+{
+    wxTextCtrl* tc = wxStaticCast(wnd, wxTextCtrl);
+
+    tc->SetSelection(-1,-1);
+}
+
+
+wxPGTextCtrlEditor::~wxPGTextCtrlEditor() { }
+
+
+// -----------------------------------------------------------------------
+// wxPGChoiceEditor
+// -----------------------------------------------------------------------
+
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(Choice,wxPGChoiceEditor,wxPGEditor)
+
+
+// This is a special enhanced double-click processor class.
+// In essence, it allows for double-clicks for which the
+// first click "created" the control.
+class wxPGDoubleClickProcessor : public wxEvtHandler
+{
+public:
+
+    wxPGDoubleClickProcessor( wxOwnerDrawnComboBox* combo, wxPGProperty* property )
+        : wxEvtHandler()
+    {
+        m_timeLastMouseUp = 0;
+        m_combo = combo;
+        m_property = property;
+        m_downReceived = false;
+    }
+
+protected:
+
+    void OnMouseEvent( wxMouseEvent& event )
+    {
+        wxLongLong t = ::wxGetLocalTimeMillis();
+        int evtType = event.GetEventType();
+
+        if ( m_property->HasFlag(wxPG_PROP_USE_DCC) &&
+             m_property->IsKindOf(CLASSINFO(wxBoolProperty)) &&
+             !m_combo->IsPopupShown() )
+        {
+            // Just check that it is in the text area
+            wxPoint pt = event.GetPosition();
+            if ( m_combo->GetTextRect().Contains(pt) )
+            {
+                if ( evtType == wxEVT_LEFT_DOWN )
+                {
+                    // Set value to avoid up-events without corresponding downs
+                    m_downReceived = true;
+                }
+                else if ( evtType == wxEVT_LEFT_DCLICK )
+                {
+                    // We'll make our own double-clicks
+                    event.SetEventType(0);
+                    return;
+                }
+                else if ( evtType == wxEVT_LEFT_UP )
+                {
+                    if ( m_downReceived || m_timeLastMouseUp == 1 )
+                    {
+                        wxLongLong timeFromLastUp = (t-m_timeLastMouseUp);
+
+                        if ( timeFromLastUp < DOUBLE_CLICK_CONVERSION_TRESHOLD )
+                        {
+                            event.SetEventType(wxEVT_LEFT_DCLICK);
+                            m_timeLastMouseUp = 1;
+                        }
+                        else
+                        {
+                            m_timeLastMouseUp = t;
+                        }
+                    }
+                }
+            }
+        }
+
+        event.Skip();
+    }
+
+    void OnSetFocus( wxFocusEvent& event )
+    {
+        m_timeLastMouseUp = ::wxGetLocalTimeMillis();
+        event.Skip();
+    }
+
+private:
+    wxLongLong                  m_timeLastMouseUp;
+    wxOwnerDrawnComboBox*       m_combo;
+    wxPGProperty*               m_property;  // Selected property
+    bool                        m_downReceived;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(wxPGDoubleClickProcessor, wxEvtHandler)
+    EVT_MOUSE_EVENTS(wxPGDoubleClickProcessor::OnMouseEvent)
+    EVT_SET_FOCUS(wxPGDoubleClickProcessor::OnSetFocus)
+END_EVENT_TABLE()
+
+
+
+class wxPGComboBox : public wxOwnerDrawnComboBox
+{
+public:
+
+    wxPGComboBox()
+        : wxOwnerDrawnComboBox()
+    {
+        m_dclickProcessor = NULL;
+        m_sizeEventCalled = false;
+    }
+
+    ~wxPGComboBox()
+    {
+        if ( m_dclickProcessor )
+        {
+            RemoveEventHandler(m_dclickProcessor);
+            delete m_dclickProcessor;
+        }
+    }
+
+    bool Create(wxWindow *parent,
+                wxWindowID id,
+                const wxString& value,
+                const wxPoint& pos,
+                const wxSize& size,
+                const wxArrayString& choices,
+                long style = 0,
+                const wxValidator& validator = wxDefaultValidator,
+                const wxString& name = wxS("wxOwnerDrawnComboBox"))
+    {
+        if ( !wxOwnerDrawnComboBox::Create( parent,
+                                            id,
+                                            value,
+                                            pos,
+                                            size,
+                                            choices,
+                                            style,
+                                            validator,
+                                            name ) )
+            return false;
+
+        m_dclickProcessor = new
+            wxPGDoubleClickProcessor( this, GetGrid()->GetSelection() );
+
+        PushEventHandler(m_dclickProcessor);
+
+        return true;
+    }
+
+    virtual void OnDrawItem( wxDC& dc,
+                             const wxRect& rect,
+                             int item,
+                             int flags ) const
+    {
+        wxPropertyGrid* pg = GetGrid();
+        pg->OnComboItemPaint( this, item, &dc, (wxRect&)rect, flags );
+    }
+
+    virtual wxCoord OnMeasureItem( size_t item ) const
+    {
+        wxPropertyGrid* pg = GetGrid();
+        wxRect rect;
+        rect.x = -1;
+        rect.width = 0;
+        pg->OnComboItemPaint( this, item, NULL, rect, 0 );
+        return rect.height;
+    }
+
+    wxPropertyGrid* GetGrid() const
+    {
+        wxPropertyGrid* pg = wxDynamicCast(GetParent()->GetParent(),
+                                           wxPropertyGrid);
+        wxASSERT(pg);
+        return pg;
+    }
+
+    virtual wxCoord OnMeasureItemWidth( size_t item ) const
+    {
+        wxPropertyGrid* pg = GetGrid();
+        wxRect rect;
+        rect.x = -1;
+        rect.width = -1;
+        pg->OnComboItemPaint( this, item, NULL, rect, 0 );
+        return rect.width;
+    }
+
+    virtual void PositionTextCtrl( int WXUNUSED(textCtrlXAdjust),
+                                   int WXUNUSED(textCtrlYAdjust) )
+    {
+        wxPropertyGrid* pg = GetGrid();
+        wxOwnerDrawnComboBox::PositionTextCtrl(
+            wxPG_TEXTCTRLXADJUST -
+            (wxPG_XBEFOREWIDGET+wxPG_CONTROL_MARGIN+1) - 1,
+            pg->GetSpacingY() + 2
+        );
+    }
+
+private:
+    wxPGDoubleClickProcessor*   m_dclickProcessor;
+    bool                        m_sizeEventCalled;
+};
+
+
+void wxPropertyGrid::OnComboItemPaint( const wxPGComboBox* pCb,
+                                       int item,
+                                       wxDC* pDc,
+                                       wxRect& rect,
+                                       int flags )
+{
+    // Sanity check
+    wxASSERT( IsKindOf(CLASSINFO(wxPropertyGrid)) );
+
+    wxPGProperty* p = m_selected;
+    wxString text;
+
+    const wxPGChoices& choices = p->GetChoices();
+    const wxPGCommonValue* comVal = NULL;
+    int comVals = p->GetDisplayedCommonValueCount();
+    int comValIndex = -1;
+
+    int choiceCount = 0;
+    if ( choices.IsOk() )
+        choiceCount = choices.GetCount();
+
+    if ( item >= choiceCount && comVals > 0 )
+    {
+        comValIndex = item - choiceCount;
+        comVal = GetCommonValue(comValIndex);
+        if ( !p->IsValueUnspecified() )
+            text = comVal->GetLabel();
+    }
+    else
+    {
+        if ( !(flags & wxODCB_PAINTING_CONTROL) )
+        {
+            text = pCb->GetString(item);
+        }
+        else
+        {
+            if ( !p->IsValueUnspecified() )
+                text = p->GetValueAsString(0);
+        }
+    }
+
+    if ( item < 0 )
+        return;
+
+    wxSize cis;
+
+    const wxBitmap* itemBitmap = NULL;
+
+    if ( item >= 0 && choices.IsOk() && choices.Item(item).GetBitmap().Ok() && comValIndex == -1 )
+        itemBitmap = &choices.Item(item).GetBitmap();
+
+    //
+    // Decide what custom image size to use
+    if ( itemBitmap )
+    {
+        cis.x = itemBitmap->GetWidth();
+        cis.y = itemBitmap->GetHeight();
+    }
+    else
+    {
+        cis = GetImageSize(p, item);
+    }
+
+    if ( rect.x < 0 )
+    {
+        // Default measure behaviour (no flexible, custom paint image only)
+        if ( rect.width < 0 )
+        {
+            wxCoord x, y;
+            pCb->GetTextExtent(text, &x, &y, 0, 0);
+            rect.width = cis.x + wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2 + 9 + x;
+        }
+
+        rect.height = cis.y + 2;
+        return;
+    }
+
+    wxPGPaintData paintdata;
+    paintdata.m_parent = NULL;
+    paintdata.m_choiceItem = item;
+
+    // This is by the current (1.0.0b) spec - if painting control, item is -1
+    if ( (flags & wxODCB_PAINTING_CONTROL) )
+        paintdata.m_choiceItem = -1;
+
+    if ( pDc )
+        pDc->SetBrush(*wxWHITE_BRUSH);
+
+    if ( rect.x >= 0 )
+    {
+        //
+        // DrawItem call
+        wxDC& dc = *pDc;
+
+        wxPoint pt(rect.x + wxPG_CONTROL_MARGIN - wxPG_CHOICEXADJUST - 1,
+                   rect.y + 1);
+
+        int renderFlags = wxPGCellRenderer::DontUseCellColours;
+
+        if ( flags & wxODCB_PAINTING_CONTROL )
+            renderFlags |= wxPGCellRenderer::Control;
+        else
+            renderFlags |= wxPGCellRenderer::ChoicePopup;
+
+        if ( flags & wxODCB_PAINTING_SELECTED )
+            renderFlags |= wxPGCellRenderer::Selected;
+
+        if ( cis.x > 0 && (p->HasFlag(wxPG_PROP_CUSTOMIMAGE) || !(flags & wxODCB_PAINTING_CONTROL)) &&
+             ( !p->m_valueBitmap || item == pCb->GetSelection() ) &&
+             ( item >= 0 || (flags & wxODCB_PAINTING_CONTROL) ) &&
+             !itemBitmap
+           )
+        {
+            pt.x += wxCC_CUSTOM_IMAGE_MARGIN1;
+            wxRect r(pt.x,pt.y,cis.x,cis.y);
+
+            if ( flags & wxODCB_PAINTING_CONTROL )
+            {
+                //r.width = cis.x;
+                r.height = wxPG_STD_CUST_IMAGE_HEIGHT(m_lineHeight);
+            }
+
+            paintdata.m_drawnWidth = r.width;
+
+            dc.SetPen(m_colPropFore);
+            if ( comValIndex >= 0 )
+            {
+                const wxPGCommonValue* cv = GetCommonValue(comValIndex);
+                wxPGCellRenderer* renderer = cv->GetRenderer();
+                r.width = rect.width;
+                renderer->Render( dc, r, this, p, m_selColumn, comValIndex, renderFlags );
+                return;
+            }
+            else if ( item >= 0 )
+            {
+                p->OnCustomPaint( dc, r, paintdata );
+            }
+            else
+            {
+                dc.DrawRectangle( r );
+            }
+
+            pt.x += paintdata.m_drawnWidth + wxCC_CUSTOM_IMAGE_MARGIN2 - 1;
+        }
+        else
+        {
+            // TODO: This aligns text so that it seems to be horizontally
+            //       on the same line as property values. Not really
+            //       sure if its needed, but seems to not cause any harm.
+            pt.x -= 1;
+
+            if ( item < 0 && (flags & wxODCB_PAINTING_CONTROL) )
+                item = pCb->GetSelection();
+
+            if ( choices.IsOk() && item >= 0 && comValIndex < 0 )
+            {
+                const wxPGChoiceEntry& cell = choices.Item(item);
+                wxPGCellRenderer* renderer = wxPGGlobalVars->m_defaultRenderer;
+                int imageOffset = renderer->PreDrawCell( dc, rect, cell, renderFlags );
+                if ( imageOffset )
+                    imageOffset += wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2;
+                pt.x += imageOffset;
+            }
+        }
+
+        //
+        // Draw text
+        //
+
+        pt.y += (rect.height-m_fontHeight)/2 - 1;
+
+        pt.x += 1;
+
+        dc.DrawText( text, pt.x + wxPG_XBEFORETEXT, pt.y );
+    }
+    else
+    {
+        //
+        // MeasureItem call
+        wxDC& dc = *pDc;
+
+        p->OnCustomPaint( dc, rect, paintdata );
+        rect.height = paintdata.m_drawnHeight + 2;
+        rect.width = cis.x + wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2 + 9;
+    }
+}
+
+bool wxPGChoiceEditor_SetCustomPaintWidth( wxPropertyGrid* propGrid, wxPGComboBox* cb, int cmnVal )
+{
+    wxPGProperty* property = propGrid->GetSelectedProperty();
+    wxASSERT( property );
+
+    if ( cmnVal >= 0 )
+    {
+        // Yes, a common value is being selected
+        property->SetCommonValue( cmnVal );
+        wxSize imageSize = propGrid->GetCommonValue(cmnVal)->
+                            GetRenderer()->GetImageSize(property, 1, cmnVal);
+        if ( imageSize.x ) imageSize.x += ODCB_CUST_PAINT_MARGIN;
+        cb->SetCustomPaintWidth( imageSize.x );
+        return false;
+    }
+    else
+    {
+        wxSize imageSize = propGrid->GetImageSize(property, -1);
+        if ( imageSize.x ) imageSize.x += ODCB_CUST_PAINT_MARGIN;
+        cb->SetCustomPaintWidth( imageSize.x );
+        return true;
+    }
+}
+
+// CreateControls calls this with CB_READONLY in extraStyle
+wxWindow* wxPGChoiceEditor::CreateControlsBase( wxPropertyGrid* propGrid,
+                                                wxPGProperty* property,
+                                                const wxPoint& pos,
+                                                const wxSize& sz,
+                                                long extraStyle ) const
+{
+    const wxPGChoices& choices = property->GetChoices();
+    wxString defString;
+    int index = property->GetChoiceSelection();
+
+    bool isUnspecified = property->IsValueUnspecified();
+
+    if ( !isUnspecified )
+        defString = property->GetDisplayedString();
+
+    wxArrayString labels = choices.GetLabels();
+
+    wxPGComboBox* cb;
+
+    wxPoint po(pos);
+    wxSize si(sz);
+    po.y += wxPG_CHOICEYADJUST;
+    si.y -= (wxPG_CHOICEYADJUST*2);
+
+    po.x += wxPG_CHOICEXADJUST;
+    si.x -= wxPG_CHOICEXADJUST;
+    wxWindow* ctrlParent = propGrid->GetPanel();
+
+    int odcbFlags = extraStyle | wxBORDER_NONE | wxTE_PROCESS_ENTER;
+
+    //
+    // If common value specified, use appropriate index
+    unsigned int cmnVals = property->GetDisplayedCommonValueCount();
+    if ( cmnVals )
+    {
+        if ( !isUnspecified )
+        {
+            int cmnVal = property->GetCommonValue();
+            if ( cmnVal >= 0 )
+            {
+                index = labels.size() + cmnVal;
+            }
+        }
+
+        unsigned int i;
+        for ( i=0; i<cmnVals; i++ )
+            labels.Add(propGrid->GetCommonValueLabel(i));
+    }
+
+    cb = new wxPGComboBox();
+#ifdef __WXMSW__
+    cb->Hide();
+#endif
+    cb->Create(ctrlParent,
+               wxPG_SUBID1,
+               wxString(),
+               po,
+               si,
+               labels,
+               odcbFlags);
+
+    cb->SetButtonPosition(si.y,0,wxRIGHT);
+    cb->SetTextIndent(wxPG_XBEFORETEXT-1);
+
+    wxPGChoiceEditor_SetCustomPaintWidth( propGrid, cb, property->GetCommonValue() );
+
+    if ( index >= 0 && index < (int)cb->GetCount() )
+    {
+        cb->SetSelection( index );
+        if ( defString.length() )
+            cb->SetText( defString );
+    }
+    else if ( !(extraStyle & wxCB_READONLY) && defString.length() )
+        cb->SetValue( defString );
+    else
+        cb->SetSelection( -1 );
+
+#ifdef __WXMSW__
+    cb->Show();
+#endif
+
+    return (wxWindow*) cb;
+}
+
+
+void wxPGChoiceEditor::UpdateControl( wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxASSERT( ctrl );
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    wxASSERT( cb->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)));
+    int ind = property->GetChoiceSelection();
+    cb->SetSelection(ind);
+}
+
+wxPGWindowList wxPGChoiceEditor::CreateControls( wxPropertyGrid* propGrid, wxPGProperty* property,
+        const wxPoint& pos, const wxSize& sz ) const
+{
+    return CreateControlsBase(propGrid,property,pos,sz,wxCB_READONLY);
+}
+
+
+int wxPGChoiceEditor::InsertItem( wxWindow* ctrl, const wxString& label, int index ) const
+{
+    wxASSERT( ctrl );
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    wxASSERT( cb->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)));
+
+    if (index < 0)
+        index = cb->GetCount();
+
+    return cb->Insert(label,index);
+}
+
+
+void wxPGChoiceEditor::DeleteItem( wxWindow* ctrl, int index ) const
+{
+    wxASSERT( ctrl );
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    wxASSERT( cb->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)));
+
+    cb->Delete(index);
+}
+
+bool wxPGChoiceEditor::OnEvent( wxPropertyGrid* propGrid, wxPGProperty* property,
+    wxWindow* ctrl, wxEvent& event ) const
+{
+    if ( event.GetEventType() == wxEVT_COMMAND_COMBOBOX_SELECTED )
+    {
+        wxPGComboBox* cb = (wxPGComboBox*)ctrl;
+        int index = cb->GetSelection();
+        int cmnValIndex = -1;
+        int cmnVals = property->GetDisplayedCommonValueCount();
+        int items = cb->GetCount();
+
+        if ( index >= (items-cmnVals) )
+        {
+            // Yes, a common value is being selected
+            cmnValIndex = index - (items-cmnVals);
+            property->SetCommonValue( cmnValIndex );
+
+            // Truly set value to unspecified?
+            if ( propGrid->GetUnspecifiedCommonValue() == cmnValIndex )
+            {
+                if ( !property->IsValueUnspecified() )
+                    propGrid->SetInternalFlag(wxPG_FL_VALUE_CHANGE_IN_EVENT);
+                property->SetValueToUnspecified();
+                if ( !cb->HasFlag(wxCB_READONLY) )
+                    cb->GetTextCtrl()->SetValue(wxEmptyString);
+                return false;
+            }
+        }
+        return wxPGChoiceEditor_SetCustomPaintWidth( propGrid, cb, cmnValIndex );        
+    }
+    return false;
+}
+
+
+bool wxPGChoiceEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+
+    int index = cb->GetSelection();
+
+    if ( index != property->GetChoiceSelection() ||
+        // Changing unspecified always causes event (returning
+        // true here should be enough to trigger it).
+         property->IsValueUnspecified()
+       )
+    {
+        return property->IntToValue( variant, index, 0 );
+    }
+    return false;
+}
+
+
+void wxPGChoiceEditor::SetControlStringValue( wxPGProperty* WXUNUSED(property), wxWindow* ctrl, const wxString& txt ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    wxASSERT( cb );
+    cb->SetValue(txt);
+}
+
+
+void wxPGChoiceEditor::SetControlIntValue( wxPGProperty* WXUNUSED(property), wxWindow* ctrl, int value ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    wxASSERT( cb );
+    cb->SetSelection(value);
+}
+
+
+void wxPGChoiceEditor::SetValueToUnspecified( wxPGProperty* WXUNUSED(property), wxWindow* ctrl ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    cb->SetSelection(-1);
+}
+
+
+bool wxPGChoiceEditor::CanContainCustomImage() const
+{
+    return true;
+}
+
+
+wxPGChoiceEditor::~wxPGChoiceEditor() { }
+
+
+// -----------------------------------------------------------------------
+// wxPGComboBoxEditor
+// -----------------------------------------------------------------------
+
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(ComboBox,
+                                      wxPGComboBoxEditor,
+                                      wxPGChoiceEditor)
+
+
+void wxPGComboBoxEditor::UpdateControl( wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    cb->SetValue(property->GetValueAsString(wxPG_EDITABLE_VALUE));
+
+    // TODO: If string matches any selection, then select that.
+}
+
+
+wxPGWindowList wxPGComboBoxEditor::CreateControls( wxPropertyGrid* propGrid,
+                                                   wxPGProperty* property,
+                                                   const wxPoint& pos,
+                                                   const wxSize& sz ) const
+{
+    return CreateControlsBase(propGrid,property,pos,sz,0);
+}
+
+
+bool wxPGComboBoxEditor::OnEvent( wxPropertyGrid* propGrid,
+                                  wxPGProperty* property,
+                                  wxWindow* ctrl,
+                                  wxEvent& event ) const
+{
+    wxOwnerDrawnComboBox* cb = NULL;
+    wxWindow* textCtrl = NULL;
+
+    if ( ctrl )
+    {
+        cb = (wxOwnerDrawnComboBox*)ctrl;
+        textCtrl = cb->GetTextCtrl();
+    }
+
+    if ( wxPGTextCtrlEditor::OnTextCtrlEvent(propGrid,property,textCtrl,event) )
+        return true;
+
+    return wxPGChoiceEditor::OnEvent(propGrid,property,ctrl,event);
+}
+
+
+bool wxPGComboBoxEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    wxString textVal = cb->GetValue();
+
+    if ( property->UsesAutoUnspecified() && !textVal.length() )
+    {
+        variant.MakeNull();
+        return true;
+    }
+
+    bool res = property->StringToValue(variant, textVal, wxPG_EDITABLE_VALUE);
+
+    // Changing unspecified always causes event (returning
+    // true here should be enough to trigger it).
+    if ( !res && variant.IsNull() )
+        res = true;
+
+    return res;
+}
+
+
+void wxPGComboBoxEditor::OnFocus( wxPGProperty*, wxWindow* ctrl ) const
+{
+    wxOwnerDrawnComboBox* cb = (wxOwnerDrawnComboBox*)ctrl;
+    cb->GetTextCtrl()->SetSelection(-1,-1);
+}
+
+
+wxPGComboBoxEditor::~wxPGComboBoxEditor() { }
+
+
+// -----------------------------------------------------------------------
+// wxPGChoiceAndButtonEditor
+// -----------------------------------------------------------------------
+
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(ChoiceAndButton,
+                                      wxPGChoiceAndButtonEditor,
+                                      wxPGChoiceEditor)
+
+
+wxPGWindowList wxPGChoiceAndButtonEditor::CreateControls( wxPropertyGrid* propGrid,
+                                                          wxPGProperty* property,
+                                                          const wxPoint& pos,
+                                                          const wxSize& sz ) const
+{
+    // Use one two units smaller to match size of the combo's dropbutton.
+    // (normally a bigger button is used because it looks better)
+    int bt_wid = sz.y;
+    bt_wid -= 2;
+    wxSize bt_sz(bt_wid,bt_wid);
+
+    // Position of button.
+    wxPoint bt_pos(pos.x+sz.x-bt_sz.x,pos.y);
+#ifdef __WXMAC__
+    bt_pos.y -= 1;
+#else
+    bt_pos.y += 1;
+#endif
+
+    wxWindow* bt = propGrid->GenerateEditorButton( bt_pos, bt_sz );
+
+    // Size of choice.
+    wxSize ch_sz(sz.x-bt->GetSize().x,sz.y);
+
+#ifdef __WXMAC__
+    ch_sz.x -= wxPG_TEXTCTRL_AND_BUTTON_SPACING;
+#endif
+
+    wxWindow* ch = wxPGEditor_Choice->CreateControls(propGrid,property,
+        pos,ch_sz).m_primary;
+
+#ifdef __WXMSW__
+    bt->Show();
+#endif
+
+    return wxPGWindowList(ch, bt);
+}
+
+
+wxPGChoiceAndButtonEditor::~wxPGChoiceAndButtonEditor() { }
+
+
+// -----------------------------------------------------------------------
+// wxPGTextCtrlAndButtonEditor
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(TextCtrlAndButton,
+                                      wxPGTextCtrlAndButtonEditor,
+                                      wxPGTextCtrlEditor)
+
+
+wxPGWindowList wxPGTextCtrlAndButtonEditor::CreateControls( wxPropertyGrid* propGrid,
+                                                            wxPGProperty* property,
+                                                            const wxPoint& pos,
+                                                            const wxSize& sz ) const
+{
+    wxWindow* wnd2;
+    wxWindow* wnd = propGrid->GenerateEditorTextCtrlAndButton( pos, sz, &wnd2,
+        property->GetFlags() & wxPG_PROP_NOEDITOR, property);
+
+    return wxPGWindowList(wnd, wnd2);
+}
+
+
+wxPGTextCtrlAndButtonEditor::~wxPGTextCtrlAndButtonEditor() { }
+
+
+// -----------------------------------------------------------------------
+// wxPGCheckBoxEditor
+// -----------------------------------------------------------------------
+
+#if wxPG_INCLUDE_CHECKBOX
+
+WX_PG_IMPLEMENT_INTERNAL_EDITOR_CLASS(CheckBox,
+                                      wxPGCheckBoxEditor,
+                                      wxPGEditor)
+
+
+// Check box state flags
+enum
+{
+    wxSCB_STATE_UNCHECKED   = 0,
+    wxSCB_STATE_CHECKED     = 1,
+    wxSCB_STATE_BOLD        = 2,
+    wxSCB_STATE_UNSPECIFIED = 4
+};
+
+const int wxSCB_SETVALUE_CYCLE = 2;
+
+
+static void DrawSimpleCheckBox( wxDC& dc, const wxRect& rect, int box_hei,
+                                int state, const wxColour& lineCol )
+{
+    // Box rectangle.
+    wxRect r(rect.x+wxPG_XBEFORETEXT,rect.y+((rect.height-box_hei)/2),
+             box_hei,box_hei);
+    wxColour useCol = lineCol;
+
+    if ( state & wxSCB_STATE_UNSPECIFIED )
+    {
+        useCol = wxColour(220, 220, 220);
+    }
+
+    // Draw check mark first because it is likely to overdraw the
+    // surrounding rectangle.
+    if ( state & wxSCB_STATE_CHECKED )
+    {
+        wxRect r2(r.x+wxPG_CHECKMARK_XADJ,
+                  r.y+wxPG_CHECKMARK_YADJ,
+                  r.width+wxPG_CHECKMARK_WADJ,
+                  r.height+wxPG_CHECKMARK_HADJ);
+    #if wxPG_CHECKMARK_DEFLATE
+        r2.Deflate(wxPG_CHECKMARK_DEFLATE);
+    #endif
+        dc.DrawCheckMark(r2);
+
+        // This would draw a simple cross check mark.
+        // dc.DrawLine(r.x,r.y,r.x+r.width-1,r.y+r.height-1);
+        // dc.DrawLine(r.x,r.y+r.height-1,r.x+r.width-1,r.y);
+    }
+
+    if ( !(state & wxSCB_STATE_BOLD) )
+    {
+        // Pen for thin rectangle.
+        dc.SetPen(useCol);
+    }
+    else
+    {
+        // Pen for bold rectangle.
+        wxPen linepen(useCol,2,wxSOLID);
+        linepen.SetJoin(wxJOIN_MITER); // This prevents round edges.
+        dc.SetPen(linepen);
+        r.x++;
+        r.y++;
+        r.width--;
+        r.height--;
+    }
+
+    dc.SetBrush(*wxTRANSPARENT_BRUSH);
+
+    dc.DrawRectangle(r);
+    dc.SetPen(*wxTRANSPARENT_PEN);
+}
+
+//
+// Real simple custom-drawn checkbox-without-label class.
+//
+class wxSimpleCheckBox : public wxControl
+{
+public:
+
+    void SetValue( int value );
+
+    wxSimpleCheckBox( wxWindow* parent,
+                      wxWindowID id,
+                      const wxPoint& pos = wxDefaultPosition,
+                      const wxSize& size = wxDefaultSize )
+        : wxControl(parent,id,pos,size,wxBORDER_NONE|wxWANTS_CHARS)
+    {
+        // Due to SetOwnFont stuff necessary for GTK+ 1.2, we need to have this
+        SetFont( parent->GetFont() );
+
+        m_state = 0;
+        m_boxHeight = 12;
+
+        SetBackgroundStyle( wxBG_STYLE_CUSTOM );
+    }
+
+    virtual ~wxSimpleCheckBox();
+
+    int m_state;
+    int m_boxHeight;
+
+private:
+    void OnPaint( wxPaintEvent& event );
+    void OnLeftClick( wxMouseEvent& event );
+    void OnKeyDown( wxKeyEvent& event );
+
+    void OnResize( wxSizeEvent& event )
+    {
+        Refresh();
+        event.Skip();
+    }
+
+    static wxBitmap* ms_doubleBuffer;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(wxSimpleCheckBox, wxControl)
+    EVT_PAINT(wxSimpleCheckBox::OnPaint)
+    EVT_LEFT_DOWN(wxSimpleCheckBox::OnLeftClick)
+    EVT_LEFT_DCLICK(wxSimpleCheckBox::OnLeftClick)
+    EVT_KEY_DOWN(wxSimpleCheckBox::OnKeyDown)
+    EVT_SIZE(wxSimpleCheckBox::OnResize)
+END_EVENT_TABLE()
+
+wxSimpleCheckBox::~wxSimpleCheckBox()
+{
+    delete ms_doubleBuffer;
+    ms_doubleBuffer = NULL;
+}
+
+wxBitmap* wxSimpleCheckBox::ms_doubleBuffer = NULL;
+
+void wxSimpleCheckBox::OnPaint( wxPaintEvent& WXUNUSED(event) )
+{
+    wxSize clientSize = GetClientSize();
+    wxAutoBufferedPaintDC dc(this);
+
+    dc.Clear();
+    wxRect rect(0,0,clientSize.x,clientSize.y);
+    rect.y += 1;
+    rect.width += 1;
+
+    wxColour bgcol = GetBackgroundColour();
+    dc.SetBrush( bgcol );
+    dc.SetPen( bgcol );
+    dc.DrawRectangle( rect );
+
+    wxColour txcol = GetForegroundColour();
+
+    int state = m_state;
+    if ( !(state & wxSCB_STATE_UNSPECIFIED) &&
+         GetFont().GetWeight() == wxBOLD )
+        state |= wxSCB_STATE_BOLD;
+
+    DrawSimpleCheckBox(dc,rect,m_boxHeight,state,txcol);
+}
+
+void wxSimpleCheckBox::OnLeftClick( wxMouseEvent& event )
+{
+    if ( (event.m_x > (wxPG_XBEFORETEXT-2)) &&
+         (event.m_x <= (wxPG_XBEFORETEXT-2+m_boxHeight)) )
+    {
+        SetValue(wxSCB_SETVALUE_CYCLE);
+    }
+}
+
+void wxSimpleCheckBox::OnKeyDown( wxKeyEvent& event )
+{
+    if ( event.GetKeyCode() == WXK_SPACE )
+    {
+        SetValue(wxSCB_SETVALUE_CYCLE);
+    }
+}
+
+void wxSimpleCheckBox::SetValue( int value )
+{
+    if ( value == wxSCB_SETVALUE_CYCLE )
+    {
+        if ( m_state & wxSCB_STATE_CHECKED )
+            m_state &= ~wxSCB_STATE_CHECKED;
+        else
+            m_state |= wxSCB_STATE_CHECKED;
+    }
+    else
+    {
+        m_state = value;
+    }
+    Refresh();
+
+    wxCommandEvent evt(wxEVT_COMMAND_CHECKBOX_CLICKED,GetParent()->GetId());
+
+    wxPropertyGrid* propGrid = (wxPropertyGrid*) GetParent()->GetParent();
+    wxASSERT( propGrid->IsKindOf(CLASSINFO(wxPropertyGrid)) );
+    propGrid->HandleCustomEditorEvent(evt);
+}
+
+wxPGWindowList wxPGCheckBoxEditor::CreateControls( wxPropertyGrid* propGrid,
+                                                   wxPGProperty* property,
+                                                   const wxPoint& pos,
+                                                   const wxSize& size ) const
+{
+    wxPoint pt = pos;
+    pt.x -= wxPG_XBEFOREWIDGET;
+    wxSize sz = size;
+    sz.x = propGrid->GetFontHeight() + (wxPG_XBEFOREWIDGET*2) + 4;
+
+    wxSimpleCheckBox* cb = new wxSimpleCheckBox(propGrid->GetPanel(),
+                                                wxPG_SUBID1, pt, sz);
+
+    cb->SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW));
+
+    UpdateControl(property, cb);
+
+    if ( !property->IsValueUnspecified() )
+    {
+        // If mouse cursor was on the item, toggle the value now.
+        if ( propGrid->GetInternalFlags() & wxPG_FL_ACTIVATION_BY_CLICK )
+        {
+            wxPoint pt = cb->ScreenToClient(::wxGetMousePosition());
+            if ( pt.x <= (wxPG_XBEFORETEXT-2+cb->m_boxHeight) )
+            {
+                if ( cb->m_state & wxSCB_STATE_CHECKED )
+                    cb->m_state &= ~wxSCB_STATE_CHECKED;
+                else
+                    cb->m_state |= wxSCB_STATE_CHECKED;
+
+                // Makes sure wxPG_EVT_CHANGING etc. is sent for this initial
+                // click 
+                propGrid->ChangePropertyValue(property,
+                                              wxPGVariant_Bool(cb->m_state));
+            }
+        }
+    }
+
+    propGrid->SetInternalFlag( wxPG_FL_FIXED_WIDTH_EDITOR );
+
+    return cb;
+}
+
+void wxPGCheckBoxEditor::DrawValue( wxDC& dc, const wxRect& rect,
+                                    wxPGProperty* property,
+                                    const wxString& WXUNUSED(text) ) const
+{
+    int state = wxSCB_STATE_UNCHECKED;
+    wxColour rectCol = dc.GetTextForeground();
+
+    if ( !property->IsValueUnspecified() )
+    {
+        state = property->GetChoiceSelection();
+        if ( dc.GetFont().GetWeight() == wxBOLD )
+            state |= wxSCB_STATE_BOLD;
+    }
+    else
+    {
+        state |= wxSCB_STATE_UNSPECIFIED;
+    }
+
+    DrawSimpleCheckBox(dc, rect, dc.GetCharHeight(), state, rectCol);
+}
+
+void wxPGCheckBoxEditor::UpdateControl( wxPGProperty* property,
+                                        wxWindow* ctrl ) const
+{
+    wxSimpleCheckBox* cb = (wxSimpleCheckBox*) ctrl;
+    wxASSERT( cb );
+
+    if ( !property->IsValueUnspecified() )
+        cb->m_state = property->GetChoiceSelection();
+    else
+        cb->m_state = wxSCB_STATE_UNSPECIFIED;
+
+    wxPropertyGrid* propGrid = property->GetGrid();
+    cb->m_boxHeight = propGrid->GetFontHeight();
+
+    cb->Refresh();
+}
+
+bool wxPGCheckBoxEditor::OnEvent( wxPropertyGrid* WXUNUSED(propGrid), wxPGProperty* WXUNUSED(property),
+    wxWindow* WXUNUSED(ctrl), wxEvent& event ) const
+{
+    if ( event.GetEventType() == wxEVT_COMMAND_CHECKBOX_CLICKED )
+    {
+        return true;
+    }
+    return false;
+}
+
+
+bool wxPGCheckBoxEditor::GetValueFromControl( wxVariant& variant, wxPGProperty* property, wxWindow* ctrl ) const
+{
+    wxSimpleCheckBox* cb = (wxSimpleCheckBox*)ctrl;
+
+    int index = cb->m_state;
+
+    if ( index != property->GetChoiceSelection() ||
+         // Changing unspecified always causes event (returning
+         // true here should be enough to trigger it).
+         property->IsValueUnspecified()
+       )
+    {
+        return property->IntToValue(variant, index, 0);
+    }
+    return false;
+}
+
+
+void wxPGCheckBoxEditor::SetControlIntValue( wxPGProperty* WXUNUSED(property), wxWindow* ctrl, int value ) const
+{
+    if ( value != 0 ) value = 1;
+    ((wxSimpleCheckBox*)ctrl)->m_state = value;
+    ctrl->Refresh();
+}
+
+
+void wxPGCheckBoxEditor::SetValueToUnspecified( wxPGProperty* WXUNUSED(property), wxWindow* ctrl ) const
+{
+    ((wxSimpleCheckBox*)ctrl)->m_state = 0;
+    ctrl->Refresh();
+}
+
+
+wxPGCheckBoxEditor::~wxPGCheckBoxEditor() { }
+
+
+#endif // wxPG_INCLUDE_CHECKBOX
+
+// -----------------------------------------------------------------------
+
+wxWindow* wxPropertyGrid::GetEditorControl() const
+{
+    wxWindow* ctrl = m_wndEditor;
+
+    if ( !ctrl )
+        return ctrl;
+
+    return ctrl;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::CorrectEditorWidgetSizeX()
+{
+    if ( m_selColumn == -1 )
+        return;
+
+    int secWid = 0;
+    int newSplitterx = m_pState->DoGetSplitterPosition(m_selColumn-1);
+    int newWidth = newSplitterx + m_pState->m_colWidths[m_selColumn];
+
+    if ( m_wndEditor2 )
+    {
+        // if width change occurred, move secondary wnd by that amount
+        wxRect r = m_wndEditor2->GetRect();
+        secWid = r.width;
+        r.x = newWidth - secWid;
+
+        m_wndEditor2->SetSize( r );
+
+        // if primary is textctrl, then we have to add some extra space
+#ifdef __WXMAC__
+        if ( m_wndEditor )
+#else
+        if ( m_wndEditor && m_wndEditor->IsKindOf(CLASSINFO(wxTextCtrl)) )
+#endif
+            secWid += wxPG_TEXTCTRL_AND_BUTTON_SPACING;
+    }
+
+    if ( m_wndEditor )
+    {
+        wxRect r = m_wndEditor->GetRect();
+
+        r.x = newSplitterx+m_ctrlXAdjust;
+
+        if ( !(m_iFlags & wxPG_FL_FIXED_WIDTH_EDITOR) )
+            r.width = newWidth - r.x - secWid;
+
+        m_wndEditor->SetSize(r);
+    }
+
+    if ( m_wndEditor2 )
+        m_wndEditor2->Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::CorrectEditorWidgetPosY()
+{
+    if ( m_selColumn == -1 )
+        return;
+
+    if ( m_selected && (m_wndEditor || m_wndEditor2) ) 
+    {
+        wxRect r = GetEditorWidgetRect(m_selected, m_selColumn);
+
+        if ( m_wndEditor )
+        {
+            wxPoint pos = m_wndEditor->GetPosition();
+
+            // Calculate y offset
+            int offset = pos.y % m_lineHeight;
+
+            m_wndEditor->Move(pos.x, r.y + offset);
+        }
+
+        if ( m_wndEditor2 )
+        {
+            wxPoint pos = m_wndEditor2->GetPosition();
+
+            m_wndEditor2->Move(pos.x, r.y);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+// Fixes position of wxTextCtrl-like control (wxSpinCtrl usually
+// fits into that category as well).
+void wxPropertyGrid::FixPosForTextCtrl( wxWindow* ctrl, const wxPoint& offset )
+{
+    // Center the control vertically
+    wxRect finalPos = ctrl->GetRect();
+    int y_adj = (m_lineHeight - finalPos.height)/2 + wxPG_TEXTCTRLYADJUST;
+
+    // Prevent over-sized control
+    int sz_dec = (y_adj + finalPos.height) - m_lineHeight;
+    if ( sz_dec < 0 ) sz_dec = 0;
+
+    finalPos.y += y_adj;
+    finalPos.height -= (y_adj+sz_dec);
+
+    const int textCtrlXAdjust = wxPG_TEXTCTRLXADJUST;
+
+    finalPos.x += textCtrlXAdjust;
+    finalPos.width -= textCtrlXAdjust;
+
+    finalPos.x += offset.x;
+    finalPos.y += offset.y;
+
+    ctrl->SetSize(finalPos);
+}
+
+// -----------------------------------------------------------------------
+
+wxWindow* wxPropertyGrid::GenerateEditorTextCtrl( const wxPoint& pos,
+                                                  const wxSize& sz,
+                                                  const wxString& value,
+                                                  wxWindow* secondary,
+                                                  int extraStyle,
+                                                  int maxLen )
+{
+    wxWindowID id = wxPG_SUBID1;
+    wxPGProperty* prop = m_selected;
+    wxASSERT(prop);
+
+    int tcFlags = wxTE_PROCESS_ENTER | extraStyle;
+
+    if ( prop->HasFlag(wxPG_PROP_READONLY) )
+        tcFlags |= wxTE_READONLY;
+
+    wxPoint p(pos.x,pos.y);
+    wxSize s(sz.x,sz.y);
+
+   // Need to reduce width of text control on Mac
+#if defined(__WXMAC__)
+    s.x -= 8;
+#endif
+
+     // Take button into acccount
+    if ( secondary )
+    {
+        s.x -= (secondary->GetSize().x + wxPG_TEXTCTRL_AND_BUTTON_SPACING);
+        m_iFlags &= ~(wxPG_FL_PRIMARY_FILLS_ENTIRE);
+    }
+
+    // If the height is significantly higher, then use border, and fill the rect exactly.
+    bool hasSpecialSize = false;
+
+    if ( (sz.y - m_lineHeight) > 5 )
+        hasSpecialSize = true;
+
+    wxWindow* ctrlParent = GetPanel();
+
+    if ( !hasSpecialSize )
+        tcFlags |= wxBORDER_NONE;
+
+    wxTextCtrl* tc = new wxTextCtrl();
+
+#if defined(__WXMSW__)
+    tc->Hide();
+#endif
+    SetupTextCtrlValue(value);
+    tc->Create(ctrlParent,id,value, p, s,tcFlags);
+    
+    // Center the control vertically
+    if ( !hasSpecialSize )
+        FixPosForTextCtrl(tc);
+
+#ifdef __WXMSW__
+    tc->Show();
+    if ( secondary )
+        secondary->Show();
+#endif
+
+    // Set maximum length
+    if ( maxLen > 0 )
+        tc->SetMaxLength( maxLen );
+
+    wxVariant attrVal = prop->GetAttribute(wxPG_ATTR_AUTOCOMPLETE);
+    if ( !attrVal.IsNull() )
+    {
+        wxASSERT(attrVal.GetType() == wxS("arrstring"));
+        tc->AutoComplete(attrVal.GetArrayString());
+    }
+
+    return tc;
+}
+
+// -----------------------------------------------------------------------
+
+wxWindow* wxPropertyGrid::GenerateEditorButton( const wxPoint& pos, const wxSize& sz )
+{
+    wxWindowID id = wxPG_SUBID2;
+    wxPGProperty* selected = m_selected;
+    wxASSERT(selected);
+
+#ifdef __WXMAC__
+   // Decorations are chunky on Mac, and we can't make the button square, so
+   // do things a bit differently on this platform.
+
+   wxPoint p(pos.x+sz.x,
+             pos.y+wxPG_BUTTON_SIZEDEC-wxPG_NAT_BUTTON_BORDER_Y);
+   wxSize s(25, -1);
+
+   wxButton* but = new wxButton();
+   but->Create(GetPanel(),id,wxS("..."),p,s,wxWANTS_CHARS);
+
+   // Now that we know the size, move to the correct position
+   p.x = pos.x + sz.x - but->GetSize().x - 2;
+   but->Move(p);
+
+#else 
+    wxSize s(sz.y-(wxPG_BUTTON_SIZEDEC*2)+(wxPG_NAT_BUTTON_BORDER_Y*2),
+        sz.y-(wxPG_BUTTON_SIZEDEC*2)+(wxPG_NAT_BUTTON_BORDER_Y*2));
+
+    // Reduce button width to lineheight
+    if ( s.x > m_lineHeight )
+        s.x = m_lineHeight;
+
+#ifdef __WXGTK__
+    // On wxGTK, take fixed button margins into account
+    if ( s.x < 25 )
+        s.x = 25;
+#endif
+
+    wxPoint p(pos.x+sz.x-s.x,
+        pos.y+wxPG_BUTTON_SIZEDEC-wxPG_NAT_BUTTON_BORDER_Y);
+
+    wxButton* but = new wxButton();
+  #ifdef __WXMSW__
+    but->Hide();
+  #endif
+    but->Create(GetPanel(),id,wxS("..."),p,s,wxWANTS_CHARS);
+
+  #ifdef __WXGTK__
+    wxFont font = GetFont();
+    font.SetPointSize(font.GetPointSize()-2);
+    but->SetFont(font);
+  #else
+    but->SetFont(GetFont());
+  #endif
+#endif
+
+    if ( selected->HasFlag(wxPG_PROP_READONLY) )
+        but->Disable();
+
+    return but;
+}
+
+// -----------------------------------------------------------------------
+
+wxWindow* wxPropertyGrid::GenerateEditorTextCtrlAndButton( const wxPoint& pos,
+                                                           const wxSize& sz,
+                                                           wxWindow** psecondary,
+                                                           int limitedEditing,
+                                                           wxPGProperty* property )
+{
+    wxButton* but = (wxButton*)GenerateEditorButton(pos,sz);
+    *psecondary = (wxWindow*)but;
+
+    if ( limitedEditing )
+    {
+    #ifdef __WXMSW__
+        // There is button Show in GenerateEditorTextCtrl as well
+        but->Show();
+    #endif
+        return NULL;
+    }
+
+    wxString text;
+
+    if ( !property->IsValueUnspecified() )
+        text = property->GetValueAsString(property->HasFlag(wxPG_PROP_READONLY)?0:wxPG_EDITABLE_VALUE);
+
+    return GenerateEditorTextCtrl(pos,sz,text,but,property->m_maxLen);
+}
+
+// -----------------------------------------------------------------------
+
+wxTextCtrl* wxPropertyGrid::GetEditorTextCtrl() const
+{
+    wxWindow* wnd = GetEditorControl();
+
+    if ( !wnd )
+        return NULL;
+
+    if ( wnd->IsKindOf(CLASSINFO(wxTextCtrl)) )
+        return wxStaticCast(wnd, wxTextCtrl);
+
+    if ( wnd->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)) )
+    {
+        wxOwnerDrawnComboBox* cb = wxStaticCast(wnd, wxOwnerDrawnComboBox);
+        return cb->GetTextCtrl();
+    }
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGEditor* wxPropertyGridInterface::GetEditorByName( const wxString& editorName )
+{
+    wxPGHashMapS2P::const_iterator it;
+
+    it = wxPGGlobalVars->m_mapEditorClasses.find(editorName);
+    if ( it == wxPGGlobalVars->m_mapEditorClasses.end() )
+        return NULL;
+    return (wxPGEditor*) it->second;
+}
+
+// -----------------------------------------------------------------------
+// wxPGEditorDialogAdapter
+// -----------------------------------------------------------------------
+
+IMPLEMENT_ABSTRACT_CLASS(wxPGEditorDialogAdapter, wxObject)
+
+bool wxPGEditorDialogAdapter::ShowDialog( wxPropertyGrid* propGrid, wxPGProperty* property )
+{
+    if ( !propGrid->EditorValidate() )
+        return false;
+
+    bool res = DoShowDialog( propGrid, property );
+
+    if ( res )
+    {
+        propGrid->ValueChangeInEvent( m_value );
+        return true;
+    }
+
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPGMultiButton
+// -----------------------------------------------------------------------
+
+wxPGMultiButton::wxPGMultiButton( wxPropertyGrid* pg, const wxSize& sz )
+    : wxWindow( pg->GetPanel(), wxPG_SUBID2, wxPoint(-100,-100), wxSize(0, sz.y) ),
+      m_fullEditorSize(sz), m_buttonsWidth(0)
+{
+    SetBackgroundColour(pg->GetCellBackgroundColour());
+}
+
+void wxPGMultiButton::Finalize( wxPropertyGrid* WXUNUSED(propGrid),
+                                const wxPoint& pos )
+{
+    Move( pos.x + m_fullEditorSize.x - m_buttonsWidth, pos.y );
+}
+
+int wxPGMultiButton::GenId( int id ) const
+{
+    if ( id < -1 )
+    {
+        if ( m_buttons.size() )
+            id = GetButton(m_buttons.size()-1)->GetId() + 1;
+        else
+            id = wxPG_SUBID2;
+    }
+    return id;
+}
+
+#if wxUSE_BMPBUTTON
+void wxPGMultiButton::Add( const wxBitmap& bitmap, int id )
+{
+    id = GenId(id);
+    wxSize sz = GetSize();
+    wxButton* button = new wxBitmapButton( this, id, bitmap,
+                                           wxPoint(sz.x, 0),
+                                           wxSize(sz.y, sz.y) );
+    DoAddButton( button, sz );
+}
+#endif
+
+void wxPGMultiButton::Add( const wxString& label, int id )
+{
+    id = GenId(id);
+    wxSize sz = GetSize();
+    wxButton* button = new wxButton( this, id, label, wxPoint(sz.x, 0),
+                                     wxSize(sz.y, sz.y) );
+    DoAddButton( button, sz );
+}
+
+void wxPGMultiButton::DoAddButton( wxWindow* button,
+                                   const wxSize& sz )
+{
+    m_buttons.push_back(button);
+    int bw = button->GetSize().x;
+    SetSize(wxSize(sz.x+bw,sz.y));
+    m_buttonsWidth += bw;
+}
+
+// -----------------------------------------------------------------------
+
+#endif  // wxUSE_PROPGRID
Index: manager.cpp
===================================================================
--- manager.cpp	(revision 102)
+++ manager.cpp	(working copy)
@@ -1,1707 +1,1707 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/manager.cpp
-// Purpose:     wxPropertyGridManager
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2005-01-14
-// RCS-ID:      $Id: manager.cpp 58971 2009-02-17 18:01:06Z JMS $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/cursor.h"
-    #include "wx/settings.h"
-    #include "wx/textctrl.h"
-    #include "wx/sizer.h"
-    #include "wx/statusbr.h"
-    #include "wx/intl.h"
-#endif
-
-// This define is necessary to prevent macro clearing
-#define __wxPG_SOURCE_FILE__
-
-#include "wx/propgrid/propgrid.h"
-
-#include "wx/propgrid/manager.h"
-
-
-#define wxPG_MAN_ALTERNATE_BASE_ID          11249 // Needed for wxID_ANY madnesss
-
-
-// -----------------------------------------------------------------------
-
-// For wxMSW cursor consistency, we must do mouse capturing even
-// when using custom controls
-
-#define BEGIN_MOUSE_CAPTURE \
-    if ( !(m_iFlags & wxPG_FL_MOUSE_CAPTURED) ) \
-    { \
-        CaptureMouse(); \
-        m_iFlags |= wxPG_FL_MOUSE_CAPTURED; \
-    }
-
-#define END_MOUSE_CAPTURE \
-    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED ) \
-    { \
-        ReleaseMouse(); \
-        m_iFlags &= ~(wxPG_FL_MOUSE_CAPTURED); \
-    }
-
-// -----------------------------------------------------------------------
-// wxPropertyGridManager
-// -----------------------------------------------------------------------
-
-const char wxPropertyGridManagerNameStr[] = "wxPropertyGridManager";
-
-
-// Categoric Mode Icon
-static const char* gs_xpm_catmode[] = {
-"16 16 5 1",
-". c none",
-"B c black",
-"D c #868686",
-"L c #CACACA",
-"W c #FFFFFF",
-".DDD............",
-".DLD.BBBBBB.....",
-".DDD............",
-".....DDDDD.DDD..",
-"................",
-".....DDDDD.DDD..",
-"................",
-".....DDDDD.DDD..",
-"................",
-".....DDDDD.DDD..",
-"................",
-".DDD............",
-".DLD.BBBBBB.....",
-".DDD............",
-".....DDDDD.DDD..",
-"................"
-};
-
-// Alphabetic Mode Icon
-static const char* gs_xpm_noncatmode[] = {
-"16 16 5 1",
-". c none",
-"B c black",
-"D c #868686",
-"L c #000080",
-"W c #FFFFFF",
-"..DBD...DDD.DDD.",
-".DB.BD..........",
-".BBBBB..DDD.DDD.",
-".B...B..........",
-"...L....DDD.DDD.",
-"...L............",
-".L.L.L..DDD.DDD.",
-"..LLL...........",
-"...L....DDD.DDD.",
-"................",
-".BBBBB..DDD.DDD.",
-"....BD..........",
-"...BD...DDD.DDD.",
-"..BD............",
-".BBBBB..DDD.DDD.",
-"................"
-};
-
-// Default Page Icon.
-static const char* gs_xpm_defpage[] = {
-"16 16 5 1",
-". c none",
-"B c black",
-"D c #868686",
-"L c #000080",
-"W c #FFFFFF",
-"................",
-"................",
-"..BBBBBBBBBBBB..",
-"..B..........B..",
-"..B.BB.LLLLL.B..",
-"..B..........B..",
-"..B.BB.LLLLL.B..",
-"..B..........B..",
-"..B.BB.LLLLL.B..",
-"..B..........B..",
-"..B.BB.LLLLL.B..",
-"..B..........B..",
-"..BBBBBBBBBBBB..",
-"................",
-"................",
-"................"
-};
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPage
-// -----------------------------------------------------------------------
-
-
-IMPLEMENT_CLASS(wxPropertyGridPage, wxEvtHandler)
-
-
-BEGIN_EVENT_TABLE(wxPropertyGridPage, wxEvtHandler)
-END_EVENT_TABLE()
-
-
-wxPropertyGridPage::wxPropertyGridPage()
-    : wxEvtHandler(), wxPropertyGridInterface(), wxPropertyGridPageState()
-{
-    m_pState = this; // wxPropertyGridInterface to point to State
-    m_manager = NULL;
-    m_isDefault = false;
-}
-
-wxPropertyGridPage::~wxPropertyGridPage()
-{
-}
-
-void wxPropertyGridPage::Clear()
-{
-    GetStatePtr()->DoClear();
-}
-
-wxSize wxPropertyGridPage::FitColumns()
-{
-    wxSize sz = DoFitColumns();
-    return sz;
-}
-
-void wxPropertyGridPage::RefreshProperty( wxPGProperty* p )
-{
-    if ( m_manager )
-        m_manager->RefreshProperty(p);
-}
-
-void wxPropertyGridPage::OnShow()
-{
-}
-
-void wxPropertyGridPage::SetSplitterPosition( int splitterPos, int col )
-{
-    wxPropertyGrid* pg = GetGrid();
-    if ( pg->GetState() == this )
-        pg->SetSplitterPosition(splitterPos);
-    else
-        DoSetSplitterPosition(splitterPos, col, false);
-}
-
-void wxPropertyGridPage::DoSetSplitterPosition( int pos,
-                                                int splitterColumn,
-                                                bool allPages,
-                                                bool fromAutoCenter )
-{
-    if ( allPages && m_manager->GetPageCount() )
-        m_manager->SetSplitterPosition( pos, splitterColumn );
-    else
-        wxPropertyGridPageState::DoSetSplitterPosition( pos,
-                                                        splitterColumn,
-                                                        allPages,
-                                                        fromAutoCenter );
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridManager
-// -----------------------------------------------------------------------
-
-// Final default splitter y is client height minus this.
-#define wxPGMAN_DEFAULT_NEGATIVE_SPLITTER_Y         100
-
-// -----------------------------------------------------------------------
-
-IMPLEMENT_CLASS(wxPropertyGridManager, wxPanel)
-
-#define ID_ADVTOOLBAR_OFFSET        1
-#define ID_ADVHELPCAPTION_OFFSET    2
-#define ID_ADVHELPCONTENT_OFFSET    3
-//#define ID_ADVBUTTON_OFFSET         4
-#define ID_ADVTBITEMSBASE_OFFSET    5   // Must be last.
-
-// -----------------------------------------------------------------------
-
-BEGIN_EVENT_TABLE(wxPropertyGridManager, wxPanel)
-  EVT_MOTION(wxPropertyGridManager::OnMouseMove)
-  EVT_SIZE(wxPropertyGridManager::OnResize)
-  EVT_PAINT(wxPropertyGridManager::OnPaint)
-  EVT_LEFT_DOWN(wxPropertyGridManager::OnMouseClick)
-  EVT_LEFT_UP(wxPropertyGridManager::OnMouseUp)
-  EVT_LEAVE_WINDOW(wxPropertyGridManager::OnMouseEntry)
-  //EVT_ENTER_WINDOW(wxPropertyGridManager::OnMouseEntry)
-END_EVENT_TABLE()
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridManager::wxPropertyGridManager()
-    : wxPanel()
-{
-    Init1();
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridManager::wxPropertyGridManager( wxWindow *parent,
-                                              wxWindowID id,
-                                              const wxPoint& pos,
-                                              const wxSize& size,
-                                              long style,
-                                              const wxString& name )
-    : wxPanel()
-{
-    Init1();
-    Create(parent,id,pos,size,style,name);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::Create( wxWindow *parent,
-                                    wxWindowID id,
-                                    const wxPoint& pos,
-                                    const wxSize& size,
-                                    long style,
-                                    const wxString& name )
-{
-    if ( !m_pPropGrid )
-        m_pPropGrid = CreatePropertyGrid();
-
-    bool res = wxPanel::Create( parent, id, pos, size,
-                                (style&0xFFFF0000)|wxWANTS_CHARS,
-                                name );
-    Init2(style);
-
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-//
-// Initialize values to defaults
-//
-void wxPropertyGridManager::Init1()
-{
-
-    m_pPropGrid = NULL;
-
-#if wxUSE_TOOLBAR
-    m_pToolbar = NULL;
-#endif
-    m_pTxtHelpCaption = NULL;
-    m_pTxtHelpContent = NULL;
-
-    m_emptyPage = NULL;
-
-    m_selPage = -1;
-
-    m_width = m_height = 0;
-
-    m_splitterHeight = 5;
-
-    m_splitterY = -1; // -1 causes default to be set.
-
-    m_nextDescBoxSize = -1;
-
-    m_extraHeight = 0;
-    m_dragStatus = 0;
-    m_onSplitter = 0;
-    m_iFlags = 0;
-}
-
-// -----------------------------------------------------------------------
-
-// These flags are always used in wxPropertyGrid integrated in wxPropertyGridManager.
-#ifndef __WXMAC__
-  #define wxPG_MAN_PROPGRID_FORCED_FLAGS (wxSIMPLE_BORDER| \
-                                          wxNO_FULL_REPAINT_ON_RESIZE| \
-                                          wxCLIP_CHILDREN)
-#else
-  #define wxPG_MAN_PROPGRID_FORCED_FLAGS (wxNO_BORDER| \
-                                          wxNO_FULL_REPAINT_ON_RESIZE| \
-                                          wxCLIP_CHILDREN)
-#endif
-
-// Which flags can be passed to underlying wxPropertyGrid.
-#define wxPG_MAN_PASS_FLAGS_MASK       (0xFFF0|wxTAB_TRAVERSAL)
-
-//
-// Initialize after parent etc. set
-//
-void wxPropertyGridManager::Init2( int style )
-{
-
-    if ( m_iFlags & wxPG_FL_INITIALIZED )
-        return;
-
-    m_windowStyle |= (style&0x0000FFFF);
-
-    wxSize csz = GetClientSize();
-
-    m_cursorSizeNS = wxCursor(wxCURSOR_SIZENS);
-
-    // Prepare the first page
-    // NB: But just prepare - you still need to call Add/InsertPage
-    //     to actually add properties on it.
-    wxPropertyGridPage* pd = new wxPropertyGridPage();
-    pd->m_isDefault = true;
-    pd->m_manager = this;
-    wxPropertyGridPageState* state = pd->GetStatePtr();
-    state->m_pPropGrid = m_pPropGrid;
-    m_arrPages.push_back( pd );
-    m_pPropGrid->m_pState = state;
-
-    wxWindowID baseId = GetId();
-    wxWindowID useId = baseId;
-    if ( baseId < 0 )
-        baseId = wxPG_MAN_ALTERNATE_BASE_ID;
-
-    m_baseId = baseId;
-
-#ifdef __WXMAC__
-   // Smaller controls on Mac
-   SetWindowVariant(wxWINDOW_VARIANT_SMALL);
-#endif
-
-    // Create propertygrid.
-    m_pPropGrid->Create(this,baseId,wxPoint(0,0),csz,
-                        (m_windowStyle&wxPG_MAN_PASS_FLAGS_MASK)
-                            |wxPG_MAN_PROPGRID_FORCED_FLAGS);
-
-    m_pPropGrid->m_eventObject = this;
-
-    m_pPropGrid->SetId(useId);
-
-    m_pPropGrid->m_iFlags |= wxPG_FL_IN_MANAGER;
-
-    m_pState = m_pPropGrid->m_pState;
-
-    m_pPropGrid->SetExtraStyle(wxPG_EX_INIT_NOCAT);
-
-    m_nextTbInd = baseId+ID_ADVTBITEMSBASE_OFFSET + 2;
-
-
-    // Connect to property grid onselect event.
-    // NB: Even if wxID_ANY is used, this doesn't connect properly in wxPython
-    //     (see wxPropertyGridManager::ProcessEvent).
-    Connect(m_pPropGrid->GetId()/*wxID_ANY*/,
-            wxEVT_PG_SELECTED,
-            wxPropertyGridEventHandler(wxPropertyGridManager::OnPropertyGridSelect) );
-
-    // Connect to toolbar button events.
-    Connect(baseId+ID_ADVTBITEMSBASE_OFFSET,baseId+ID_ADVTBITEMSBASE_OFFSET+50,
-            wxEVT_COMMAND_TOOL_CLICKED,
-            wxCommandEventHandler(wxPropertyGridManager::OnToolbarClick) );
-
-    // Optional initial controls.
-    m_width = -12345;
-
-    m_iFlags |= wxPG_FL_INITIALIZED;
-
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridManager::~wxPropertyGridManager()
-{
-    END_MOUSE_CAPTURE
-
-    m_pPropGrid->DoSelectProperty(NULL);
-    m_pPropGrid->m_pState = NULL;
-
-    size_t i;
-    for ( i=0; i<m_arrPages.size(); i++ )
-    {
-        delete m_arrPages[i];
-    }
-
-    delete m_emptyPage;
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGrid* wxPropertyGridManager::CreatePropertyGrid() const
-{
-    return new wxPropertyGrid();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetId( wxWindowID winid )
-{
-    wxWindow::SetId(winid);
-
-    // TODO: Reconnect propgrid event handler(s).
-
-    m_pPropGrid->SetId(winid);
-}
-
-// -----------------------------------------------------------------------
-
-wxSize wxPropertyGridManager::DoGetBestSize() const
-{
-    return wxSize(60,150);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::SetFont( const wxFont& font )
-{
-    bool res = wxWindow::SetFont(font);
-    m_pPropGrid->SetFont(font);
-
-    // TODO: Need to do caption recacalculations for other pages as well.
-    unsigned int i;
-    for ( i=0; i<m_arrPages.size(); i++ )
-    {
-        wxPropertyGridPage* page = GetPage(i);
-
-        if ( page != m_pPropGrid->GetState() )
-            page->CalculateFontAndBitmapStuff(-1);
-    }
-
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetExtraStyle( long exStyle )
-{
-    wxWindow::SetExtraStyle( exStyle );
-    m_pPropGrid->SetExtraStyle( exStyle & 0xFFFFF000 );
-#if wxUSE_TOOLBAR
-    if ( (exStyle & wxPG_EX_NO_FLAT_TOOLBAR) && m_pToolbar )
-        RecreateControls();
-#endif
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::Freeze()
-{
-    m_pPropGrid->Freeze();
-    wxWindow::Freeze();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::Thaw()
-{
-    wxWindow::Thaw();
-    m_pPropGrid->Thaw();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetWindowStyleFlag( long style )
-{
-    int oldWindowStyle = GetWindowStyleFlag();
-
-    wxWindow::SetWindowStyleFlag( style );
-    m_pPropGrid->SetWindowStyleFlag( (m_pPropGrid->GetWindowStyleFlag()&~(wxPG_MAN_PASS_FLAGS_MASK)) |
-                                   (style&wxPG_MAN_PASS_FLAGS_MASK) );
-
-    // Need to re-position windows?
-    if ( (oldWindowStyle & (wxPG_TOOLBAR|wxPG_DESCRIPTION)) !=
-         (style & (wxPG_TOOLBAR|wxPG_DESCRIPTION)) )
-    {
-        RecreateControls();
-    }
-}
-
-// -----------------------------------------------------------------------
-
-// Actually shows given page.
-bool wxPropertyGridManager::DoSelectPage( int index )
-{
-    // -1 means no page was selected
-    //wxASSERT( m_selPage >= 0 );
-
-    wxCHECK_MSG( index >= -1 && index < (int)GetPageCount(),
-                 false,
-                 wxT("invalid page index") );
-
-    if ( m_selPage == index )
-        return true;
-
-    if ( m_pPropGrid->m_selected )
-    {
-        if ( !m_pPropGrid->ClearSelection() )
-            return false;
-    }
-
-    wxPropertyGridPage* prevPage;
-
-    if ( m_selPage >= 0 )
-        prevPage = GetPage(m_selPage);
-    else
-        prevPage = m_emptyPage;
-
-    wxPropertyGridPage* nextPage;
-
-    if ( index >= 0 )
-    {
-        nextPage = m_arrPages[index];
-
-        nextPage->OnShow();
-    }
-    else
-    {
-        if ( !m_emptyPage )
-        {
-            m_emptyPage = new wxPropertyGridPage();
-            m_emptyPage->m_pPropGrid = m_pPropGrid;
-        }
-
-        nextPage = m_emptyPage;
-    }
-
-    m_iFlags |= wxPG_FL_DESC_REFRESH_REQUIRED;
-
-    m_pPropGrid->SwitchState( nextPage->GetStatePtr() );
-
-    m_pState = m_pPropGrid->m_pState;
-
-    m_selPage = index;
-
-#if wxUSE_TOOLBAR
-    if ( m_pToolbar )
-    {
-        if ( index >= 0 )
-            m_pToolbar->ToggleTool( nextPage->m_id, true );
-        else
-            m_pToolbar->ToggleTool( prevPage->m_id, false );
-    }
-#endif
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-// Changes page *and* set the target page for insertion operations.
-void wxPropertyGridManager::SelectPage( int index )
-{
-    DoSelectPage(index);
-}
-
-// -----------------------------------------------------------------------
-
-int wxPropertyGridManager::GetPageByName( const wxString& name ) const
-{
-    size_t i;
-    for ( i=0; i<GetPageCount(); i++ )
-    {
-        if ( m_arrPages[i]->m_label == name )
-            return i;
-    }
-    return wxNOT_FOUND;
-}
-
-// -----------------------------------------------------------------------
-
-int wxPropertyGridManager::GetPageByState( const wxPropertyGridPageState* pState ) const
-{
-    wxASSERT( pState );
-
-    size_t i;
-    for ( i=0; i<GetPageCount(); i++ )
-    {
-        if ( pState == m_arrPages[i]->GetStatePtr() )
-            return i;
-    }
-
-    return wxNOT_FOUND;
-}
-
-// -----------------------------------------------------------------------
-
-const wxString& wxPropertyGridManager::GetPageName( int index ) const
-{
-    wxASSERT( index >= 0 && index < (int)GetPageCount() );
-    return m_arrPages[index]->m_label;
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridPageState* wxPropertyGridManager::GetPageState( int page ) const
-{
-    // Do not change this into wxCHECK because returning NULL is important
-    // for wxPropertyGridInterface page enumeration mechanics.
-    if ( page >= (int)GetPageCount() )
-        return NULL;
-
-    if ( page == -1 )
-        return m_pState;
-    return m_arrPages[page];
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::Clear()
-{
-    m_pPropGrid->ClearSelection(false);
-
-    m_pPropGrid->Freeze();
-
-    int i;
-    for ( i=(int)GetPageCount()-1; i>=0; i-- )
-        RemovePage(i);
-
-    // Reset toolbar ids
-    m_nextTbInd = m_baseId+ID_ADVTBITEMSBASE_OFFSET + 2;
-
-    m_pPropGrid->Thaw();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::ClearPage( int page )
-{
-    wxASSERT( page >= 0 );
-    wxASSERT( page < (int)GetPageCount() );
-
-    if ( page >= 0 && page < (int)GetPageCount() )
-    {
-        wxPropertyGridPageState* state = m_arrPages[page];
-
-        if ( state == m_pPropGrid->GetState() )
-            m_pPropGrid->Clear();
-        else
-            state->DoClear();
-    }
-}
-
-// -----------------------------------------------------------------------
-
-int wxPropertyGridManager::GetColumnCount( int page ) const
-{
-    wxASSERT( page >= -1 );
-    wxASSERT( page < (int)GetPageCount() );
-
-    return GetPageState(page)->GetColumnCount();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetColumnCount( int colCount, int page )
-{
-    wxASSERT( page >= -1 );
-    wxASSERT( page < (int)GetPageCount() );
-
-    GetPageState(page)->SetColumnCount( colCount );
-    GetGrid()->Refresh();
-}
-// -----------------------------------------------------------------------
-
-size_t wxPropertyGridManager::GetPageCount() const
-{
-	if ( !(m_iFlags & wxPG_MAN_FL_PAGE_INSERTED) )
-		return 0;
-
-	return m_arrPages.size();
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridPage* wxPropertyGridManager::InsertPage( int index,
-                                                       const wxString& label,
-                                                       const wxBitmap& bmp,
-                                                       wxPropertyGridPage* pageObj )
-{
-    if ( index < 0 )
-        index = GetPageCount();
-
-    wxCHECK_MSG( (size_t)index == GetPageCount(), NULL,
-        wxT("wxPropertyGridManager currently only supports appending pages (due to wxToolBar limitation)."));
-
-    bool needInit = true;
-    bool isPageInserted = m_iFlags & wxPG_MAN_FL_PAGE_INSERTED ? true : false;
-
-    wxASSERT( index == 0 || isPageInserted );
-
-    if ( !pageObj )
-    {
-        // No custom page object was given, so we will either re-use the default base
-        // page (if index==0), or create a new default page object.
-        if ( !isPageInserted )
-        {
-            pageObj = GetPage(0);
-            // Of course, if the base page was custom, we need to delete and
-            // re-create it.
-            if ( !pageObj->m_isDefault )
-            {
-                delete pageObj;
-                pageObj = new wxPropertyGridPage();
-                m_arrPages[0] = pageObj;
-            }
-            needInit = false;
-        }
-        else
-        {
-            pageObj = new wxPropertyGridPage();
-        }
-        pageObj->m_isDefault = true;
-    }
-    else
-    {
-        if ( !isPageInserted )
-        {
-            // Initial page needs to be deleted and replaced
-            delete GetPage(0);
-            m_arrPages[0] = pageObj;
-            m_pPropGrid->m_pState = pageObj->GetStatePtr();
-        }
-    }
-
-    wxPropertyGridPageState* state = pageObj->GetStatePtr();
-
-    pageObj->m_manager = this;
-
-    if ( needInit )
-    {
-        state->m_pPropGrid = m_pPropGrid;
-        state->InitNonCatMode();
-    }
-
-    if ( label.length() )
-    {
-        wxASSERT_MSG( !pageObj->m_label.length(),
-                      wxT("If page label is given in constructor, empty label must be given in AddPage"));
-        pageObj->m_label = label;
-    }
-
-    pageObj->m_id = m_nextTbInd;
-
-    if ( isPageInserted )
-        m_arrPages.push_back( pageObj );
-
-#if wxUSE_TOOLBAR
-    if ( m_windowStyle & wxPG_TOOLBAR )
-    {
-        if ( !m_pToolbar )
-            RecreateControls();
-
-        if ( !(GetExtraStyle()&wxPG_EX_HIDE_PAGE_BUTTONS) )
-        {
-            wxASSERT( m_pToolbar );
-
-            // Add separator before first page.
-            if ( GetPageCount() < 2 && (GetExtraStyle()&wxPG_EX_MODE_BUTTONS) &&
-                 m_pToolbar->GetToolsCount() < 3 )
-                m_pToolbar->AddSeparator();
-
-            if ( &bmp != &wxNullBitmap )
-                m_pToolbar->AddTool(m_nextTbInd,label,bmp,label,wxITEM_RADIO);
-                //m_pToolbar->InsertTool(index+3,m_nextTbInd,bmp);
-            else
-                m_pToolbar->AddTool(m_nextTbInd,label,wxBitmap( (const char**)gs_xpm_defpage ),
-                    label,wxITEM_RADIO);
-
-            m_nextTbInd++;
-
-            m_pToolbar->Realize();
-        }
-    }
-#else
-    wxUnusedVar(bmp);
-#endif
-
-    // If selected page was above the point of insertion, fix the current page index
-    if ( isPageInserted )
-    {
-        if ( m_selPage >= index )
-        {
-            m_selPage += 1;
-        }
-    }
-    else
-    {
-        // Set this value only when adding the first page
-        m_selPage = 0;
-    }
-
-    pageObj->Init();
-
-    m_iFlags |= wxPG_MAN_FL_PAGE_INSERTED;
-
-    wxASSERT( pageObj->GetGrid() );
-
-    return pageObj;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::IsAnyModified() const
-{
-    size_t i;
-    for ( i=0; i<GetPageCount(); i++ )
-    {
-        if ( m_arrPages[i]->GetStatePtr()->m_anyModified )
-            return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::IsPageModified( size_t index ) const
-{
-    if ( m_arrPages[index]->GetStatePtr()->m_anyModified )
-        return true;
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridManager::GetPageRoot( int index ) const
-{
-    wxASSERT( index >= 0 );
-    wxASSERT( index < (int)m_arrPages.size() );
-
-    return m_arrPages[index]->GetStatePtr()->m_properties;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::RemovePage( int page )
-{
-    wxCHECK_MSG( (page >= 0) && (page < (int)GetPageCount()),
-                 false,
-                 wxT("invalid page index") );
-
-    wxPropertyGridPage* pd = m_arrPages[page];
-
-    if ( m_arrPages.size() == 1 )
-    {
-        // Last page: do not remove page entry
-        m_pPropGrid->Clear();
-        m_selPage = -1;
-        m_iFlags &= ~wxPG_MAN_FL_PAGE_INSERTED;
-        pd->m_label.clear();
-    }
-
-    // Change selection if current is page
-    else if ( page == m_selPage )
-    {
-        if ( !m_pPropGrid->ClearSelection() )
-                return false;
-
-        // Substitute page to select
-        int substitute = page - 1;
-        if ( substitute < 0 )
-            substitute = page + 1;
-
-        SelectPage(substitute);
-    }
-
-    // Remove toolbar icon
-#if wxUSE_TOOLBAR
-    if ( HasFlag(wxPG_TOOLBAR) )
-    {
-        wxASSERT( m_pToolbar );
-
-        int toolPos = GetExtraStyle() & wxPG_EX_MODE_BUTTONS ? 3 : 0;
-        toolPos += page;
-
-        // Delete separator as well, for consistency
-        if ( (GetExtraStyle() & wxPG_EX_MODE_BUTTONS) &&
-             GetPageCount() == 1 )
-            m_pToolbar->DeleteToolByPos(2);
-
-        m_pToolbar->DeleteToolByPos(toolPos);
-    }
-#endif
-
-    if ( m_arrPages.size() > 1 )
-    {
-        m_arrPages.erase(m_arrPages.begin() + page);
-        delete pd;
-    }
-
-    // Adjust indexes that were above removed
-    if ( m_selPage > page )
-        m_selPage--;
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::ProcessEvent( wxEvent& event )
-{
-    int evtType = event.GetEventType();
-
-    // NB: For some reason, under wxPython, Connect in Init doesn't work properly,
-    //     so we'll need to call OnPropertyGridSelect manually. Multiple call's
-    //     don't really matter.
-    if ( evtType == wxEVT_PG_SELECTED )
-        OnPropertyGridSelect((wxPropertyGridEvent&)event);
-
-    // Property grid events get special attention
-    if ( evtType >= wxPG_BASE_EVT_TYPE &&
-         evtType < (wxPG_MAX_EVT_TYPE) &&
-         m_selPage >= 0 )
-    {
-        wxPropertyGridPage* page = GetPage(m_selPage);
-        wxPropertyGridEvent* pgEvent = wxDynamicCast(&event, wxPropertyGridEvent);
-
-        // Add property grid events to appropriate custom pages
-        // but stop propagating to parent if page says it is
-        // handling everything.
-        if ( pgEvent && !page->m_isDefault )
-        {
-            /*if ( pgEvent->IsPending() )
-                page->AddPendingEvent(event);
-            else*/
-                page->ProcessEvent(event);
-
-            if ( page->IsHandlingAllEvents() )
-                event.StopPropagation();
-        }
-    }
-
-    return wxPanel::ProcessEvent(event);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::RepaintDescBoxDecorations( wxDC& dc,
-                                                       int newSplitterY,
-                                                       int newWidth,
-                                                       int newHeight )
-{
-    // Draw background
-    wxColour bgcol = GetBackgroundColour();
-    dc.SetBrush(bgcol);
-    dc.SetPen(bgcol);
-    int rectHeight = m_splitterHeight;
-    dc.DrawRectangle(0, newSplitterY, newWidth, rectHeight);
-    dc.SetPen( wxSystemSettings::GetColour(wxSYS_COLOUR_3DDKSHADOW) );
-    int splitterBottom = newSplitterY + m_splitterHeight - 1;
-    int boxHeight = newHeight - splitterBottom;
-    if ( boxHeight > 1 )
-        dc.DrawRectangle(0, splitterBottom, newWidth, boxHeight);
-    else
-        dc.DrawLine(0, splitterBottom, newWidth, splitterBottom);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::UpdateDescriptionBox( int new_splittery, int new_width, int new_height )
-{
-    int use_hei = new_height;
-    use_hei--;
-
-    // Fix help control positions.
-    int cap_hei = m_pPropGrid->m_fontHeight;
-    int cap_y = new_splittery+m_splitterHeight+5;
-    int cnt_y = cap_y+cap_hei+3;
-    int sub_cap_hei = cap_y+cap_hei-use_hei;
-    int cnt_hei = use_hei-cnt_y;
-    if ( sub_cap_hei > 0 )
-    {
-        cap_hei -= sub_cap_hei;
-        cnt_hei = 0;
-    }
-    if ( cap_hei <= 2 )
-    {
-        m_pTxtHelpCaption->Show( false );
-        m_pTxtHelpContent->Show( false );
-    }
-    else
-    {
-        m_pTxtHelpCaption->SetSize(3,cap_y,new_width-6,cap_hei);
-        m_pTxtHelpCaption->Wrap(-1);
-        m_pTxtHelpCaption->Show( true );
-        if ( cnt_hei <= 2 )
-        {
-            m_pTxtHelpContent->Show( false );
-        }
-        else
-        {
-            m_pTxtHelpContent->SetSize(3,cnt_y,new_width-6,cnt_hei);
-            m_pTxtHelpContent->Show( true );
-        }
-    }
-
-    wxRect r(0, new_splittery, new_width, new_height-new_splittery);
-    RefreshRect(r);
-
-    m_splitterY = new_splittery;
-
-    m_iFlags &= ~(wxPG_FL_DESC_REFRESH_REQUIRED);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::RecalculatePositions( int width, int height )
-{
-    int propgridY = 0;
-    int propgridBottomY = height;
-
-    // Toolbar at the top.
-#if wxUSE_TOOLBAR
-    if ( m_pToolbar )
-    {
-        m_pToolbar->SetSize(0, 0, width, -1);
-        propgridY += m_pToolbar->GetSize().y;
-    }
-#endif
-
-    // Help box.
-    if ( m_pTxtHelpCaption )
-    {
-        int new_splittery = m_splitterY;
-
-        // Move m_splitterY
-        if ( ( m_splitterY >= 0 || m_nextDescBoxSize ) && m_height > 32 )
-        {
-            if ( m_nextDescBoxSize >= 0 )
-            {
-                new_splittery = m_height - m_nextDescBoxSize - m_splitterHeight;
-                m_nextDescBoxSize = -1;
-            }
-            new_splittery += (height-m_height);
-        }
-        else
-        {
-            new_splittery = height - wxPGMAN_DEFAULT_NEGATIVE_SPLITTER_Y;
-            if ( new_splittery < 32 )
-                new_splittery = 32;
-        }
-
-        // Check if beyond minimum.
-        int nspy_min = propgridY + m_pPropGrid->m_lineHeight;
-        if ( new_splittery < nspy_min )
-            new_splittery = nspy_min;
-
-        propgridBottomY = new_splittery;
-
-        UpdateDescriptionBox( new_splittery, width, height );
-    }
-
-    if ( m_iFlags & wxPG_FL_INITIALIZED )
-    {
-        int pgh = propgridBottomY - propgridY;
-        if ( pgh < 0 )
-            pgh = 0;
-        m_pPropGrid->SetSize( 0, propgridY, width, pgh );
-
-        m_extraHeight = height - pgh;
-
-        m_width = width;
-        m_height = height;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetDescBoxHeight( int ht, bool refresh )
-{
-    if ( m_windowStyle & wxPG_DESCRIPTION )
-    {
-        if ( ht != GetDescBoxHeight() )
-        {
-            m_nextDescBoxSize = ht;
-            if ( refresh )
-                RecalculatePositions(m_width, m_height);
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-int wxPropertyGridManager::GetDescBoxHeight() const
-{
-    return GetClientSize().y - m_splitterY - m_splitterHeight;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnPaint( wxPaintEvent& WXUNUSED(event) )
-{
-    wxPaintDC dc(this);
-
-    // Update everything inside the box
-    wxRect r = GetUpdateRegion().GetBox();
-
-    // Repaint splitter and any other description box decorations
-    if ( (r.y + r.height) >= m_splitterY )
-        RepaintDescBoxDecorations( dc, m_splitterY, m_width, m_height );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::Refresh(bool eraseBackground, const wxRect* rect )
-{
-    m_pPropGrid->Refresh(eraseBackground);
-    wxWindow::Refresh(eraseBackground,rect);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::RefreshProperty( wxPGProperty* p )
-{
-    wxPropertyGrid* grid = p->GetGrid();
-
-    if ( GetPage(m_selPage)->GetStatePtr() == p->GetParent()->GetParentState() )
-        grid->RefreshProperty(p);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::RecreateControls()
-{
-
-    bool was_shown = IsShown();
-    if ( was_shown )
-        Show ( false );
-
-    wxWindowID baseId = m_pPropGrid->GetId();
-    if ( baseId < 0 )
-        baseId = wxPG_MAN_ALTERNATE_BASE_ID;
-
-#if wxUSE_TOOLBAR
-    if ( m_windowStyle & wxPG_TOOLBAR )
-    {
-        // Has toolbar.
-        if ( !m_pToolbar )
-        {
-            m_pToolbar = new wxToolBar(this,baseId+ID_ADVTOOLBAR_OFFSET,
-                                       wxDefaultPosition,wxDefaultSize,
-                                       ((GetExtraStyle()&wxPG_EX_NO_FLAT_TOOLBAR)?0:wxTB_FLAT)
-                                        /*| wxTB_HORIZONTAL | wxNO_BORDER*/ );
-            m_pToolbar->SetToolBitmapSize(wxSize(16, 15));
-
-        #if defined(__WXMSW__)
-            // Eliminate toolbar flicker on XP
-            // NOTE: Not enabled since it corrupts drawing somewhat.
-
-            /*
-            #ifndef WS_EX_COMPOSITED
-                #define WS_EX_COMPOSITED        0x02000000L
-            #endif
-
-            HWND hWnd = (HWND)m_pToolbar->GetHWND();
-
-            ::SetWindowLong( hWnd, GWL_EXSTYLE,
-                             ::GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED );
-            */
-
-        #endif
-
-            m_pToolbar->SetCursor ( *wxSTANDARD_CURSOR );
-
-            if ( (GetExtraStyle()&wxPG_EX_MODE_BUTTONS) )
-            {
-                wxString desc1(_("Categorized Mode"));
-                wxString desc2(_("Alphabetic Mode"));
-                m_pToolbar->AddTool(baseId+ID_ADVTBITEMSBASE_OFFSET+0,
-                    desc1,wxBitmap ( (const char**)gs_xpm_catmode ),
-                    desc1,wxITEM_RADIO);
-                m_pToolbar->AddTool(baseId+ID_ADVTBITEMSBASE_OFFSET+1,
-                    desc2,wxBitmap ( (const char**)gs_xpm_noncatmode ),
-                    desc2,wxITEM_RADIO);
-                m_pToolbar->Realize();
-            }
-
-        }
-
-        if ( (GetExtraStyle()&wxPG_EX_MODE_BUTTONS) )
-        {
-            // Toggle correct mode button.
-            // TODO: This doesn't work in wxMSW (when changing,
-            // both items will get toggled).
-            int toggle_but_on_ind = ID_ADVTBITEMSBASE_OFFSET+0;
-            int toggle_but_off_ind = ID_ADVTBITEMSBASE_OFFSET+1;
-            if ( m_pPropGrid->m_pState->IsInNonCatMode() )
-            {
-                toggle_but_on_ind++;
-                toggle_but_off_ind--;
-            }
-
-            m_pToolbar->ToggleTool(baseId+toggle_but_on_ind,true);
-            m_pToolbar->ToggleTool(baseId+toggle_but_off_ind,false);
-        }
-
-    }
-    else
-    {
-        // No toolbar.
-        if ( m_pToolbar )
-            m_pToolbar->Destroy();
-        m_pToolbar = NULL;
-    }
-#endif
-
-    if ( m_windowStyle & wxPG_DESCRIPTION )
-    {
-        // Has help box.
-        m_pPropGrid->m_iFlags |= (wxPG_FL_NOSTATUSBARHELP);
-
-        if ( !m_pTxtHelpCaption )
-        {
-            m_pTxtHelpCaption = new wxStaticText(this,
-                                                 baseId+ID_ADVHELPCAPTION_OFFSET,
-                                                 wxT(""),
-                                                 wxDefaultPosition,
-                                                 wxDefaultSize,
-                                                 wxALIGN_LEFT|wxST_NO_AUTORESIZE);
-            m_pTxtHelpCaption->SetFont( m_pPropGrid->m_captionFont );
-            m_pTxtHelpCaption->SetCursor( *wxSTANDARD_CURSOR );
-        }
-        if ( !m_pTxtHelpContent )
-        {
-            m_pTxtHelpContent = new wxStaticText(this,
-                                                 baseId+ID_ADVHELPCONTENT_OFFSET,
-                                                 wxT(""),
-                                                 wxDefaultPosition,
-                                                 wxDefaultSize,
-                                                 wxALIGN_LEFT|wxST_NO_AUTORESIZE);
-            m_pTxtHelpContent->SetCursor( *wxSTANDARD_CURSOR );
-        }
-
-        SetDescribedProperty(GetSelection());
-    }
-    else
-    {
-        // No help box.
-        m_pPropGrid->m_iFlags &= ~(wxPG_FL_NOSTATUSBARHELP);
-
-        if ( m_pTxtHelpCaption )
-            m_pTxtHelpCaption->Destroy();
-
-        m_pTxtHelpCaption = NULL;
-
-        if ( m_pTxtHelpContent )
-            m_pTxtHelpContent->Destroy();
-
-        m_pTxtHelpContent = NULL;
-    }
-
-    int width, height;
-
-    GetClientSize(&width,&height);
-
-    RecalculatePositions(width,height);
-
-    if ( was_shown )
-        Show ( true );
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridManager::DoGetPropertyByName( const wxString& name ) const
-{
-    size_t i;
-    for ( i=0; i<GetPageCount(); i++ )
-    {
-        wxPropertyGridPageState* pState = m_arrPages[i]->GetStatePtr();
-        wxPGProperty* p = pState->BaseGetPropertyByName(name);
-        if ( p )
-        {
-            return p;
-        }
-    }
-    return NULL;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::EnsureVisible( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-
-    wxPropertyGridPageState* parentState = p->GetParentState();
-
-    // Select correct page.
-    if ( m_pPropGrid->m_pState != parentState )
-        DoSelectPage( GetPageByState(parentState) );
-
-    return m_pPropGrid->EnsureVisible(id);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnToolbarClick( wxCommandEvent &event )
-{
-    int id = event.GetId();
-    if ( id >= 0 )
-    {
-        int baseId = m_pPropGrid->GetId();
-        if ( baseId < 0 )
-            baseId = wxPG_MAN_ALTERNATE_BASE_ID;
-
-        if ( id == ( baseId + ID_ADVTBITEMSBASE_OFFSET + 0 ) )
-        {
-            // Categorized mode.
-            if ( m_pPropGrid->m_windowStyle & wxPG_HIDE_CATEGORIES )
-            {
-                if ( !m_pPropGrid->HasInternalFlag(wxPG_FL_CATMODE_AUTO_SORT) )
-                    m_pPropGrid->m_windowStyle &= ~wxPG_AUTO_SORT;
-                m_pPropGrid->EnableCategories( true );
-            }
-        }
-        else if ( id == ( baseId + ID_ADVTBITEMSBASE_OFFSET + 1 ) )
-        {
-            // Alphabetic mode.
-            if ( !(m_pPropGrid->m_windowStyle & wxPG_HIDE_CATEGORIES) )
-            {
-                if ( m_pPropGrid->HasFlag(wxPG_AUTO_SORT) )
-                    m_pPropGrid->SetInternalFlag(wxPG_FL_CATMODE_AUTO_SORT);
-                else
-                    m_pPropGrid->ClearInternalFlag(wxPG_FL_CATMODE_AUTO_SORT);
-
-                m_pPropGrid->m_windowStyle |= wxPG_AUTO_SORT;
-                m_pPropGrid->EnableCategories( false );
-            }
-        }
-        else
-        {
-            // Page Switching.
-
-            int index = -1;
-            size_t i;
-            wxPropertyGridPage* pdc;
-
-            // Find page with given id.
-            for ( i=0; i<GetPageCount(); i++ )
-            {
-                pdc = m_arrPages[i];
-                if ( pdc->m_id == id )
-                {
-                    index = i;
-                    break;
-                }
-            }
-
-            wxASSERT( index >= 0 );
-
-            if ( DoSelectPage( index ) )
-            {
-
-                // Event dispatching must be last.
-                m_pPropGrid->SendEvent(  wxEVT_PG_PAGE_CHANGED, NULL );
-
-            }
-            else
-            {
-                // TODO: Depress the old button on toolbar.
-            }
-
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridManager::SetEditableStateItem( const wxString& name, wxVariant value )
-{
-    if ( name == wxS("descboxheight") )
-    {
-        SetDescBoxHeight(value.GetLong(), true);
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-wxVariant wxPropertyGridManager::GetEditableStateItem( const wxString& name ) const
-{
-    if ( name == wxS("descboxheight") )
-    {
-        return (long) GetDescBoxHeight();
-    }
-    return wxNullVariant;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetDescription( const wxString& label, const wxString& content )
-{
-    if ( m_pTxtHelpCaption )
-    {
-        wxSize osz1 = m_pTxtHelpCaption->GetSize();
-        wxSize osz2 = m_pTxtHelpContent->GetSize();
-
-        m_pTxtHelpCaption->SetLabel(label);
-        m_pTxtHelpContent->SetLabel(content);
-
-        m_pTxtHelpCaption->SetSize(-1,osz1.y);
-        m_pTxtHelpContent->SetSize(-1,osz2.y);
-
-        UpdateDescriptionBox( m_splitterY, m_width, m_height );
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetDescribedProperty( wxPGProperty* p )
-{
-    if ( m_pTxtHelpCaption )
-    {
-        if ( p )
-        {
-            SetDescription( p->GetLabel(), p->GetHelpString() );
-        }
-        else
-        {
-            SetDescription( wxEmptyString, wxEmptyString );
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetSplitterLeft( bool subProps, bool allPages )
-{
-    if ( !allPages )
-    {
-        m_pPropGrid->SetSplitterLeft(subProps);
-    }
-    else
-    {
-        wxClientDC dc(this);
-        dc.SetFont(m_pPropGrid->GetFont());
-
-        int highest = 0;
-        unsigned int i;
-
-        for ( i=0; i<GetPageCount(); i++ )
-        {
-            int maxW = m_pState->GetColumnFitWidth(dc, m_arrPages[i]->m_properties, 0, subProps );
-            maxW += m_pPropGrid->m_marginWidth;
-            if ( maxW > highest )
-                highest = maxW;
-        }
-
-        if ( highest > 0 )
-            m_pPropGrid->SetSplitterPosition( highest );
-
-        m_pPropGrid->m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnPropertyGridSelect( wxPropertyGridEvent& event )
-{
-    // Check id.
-    wxASSERT_MSG( GetId() == m_pPropGrid->GetId(),
-        wxT("wxPropertyGridManager id must be set with wxPropertyGridManager::SetId (not wxWindow::SetId).") );
-
-    SetDescribedProperty(event.GetProperty());
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnResize( wxSizeEvent& WXUNUSED(event) )
-{
-    int width, height;
-
-    GetClientSize(&width,&height);
-
-    if ( m_width == -12345 )
-        RecreateControls();
-
-    RecalculatePositions(width,height);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnMouseEntry( wxMouseEvent& WXUNUSED(event) )
-{
-    // Correct cursor. This is required atleast for wxGTK, for which
-    // setting button's cursor to *wxSTANDARD_CURSOR does not work.
-    SetCursor( wxNullCursor );
-    m_onSplitter = 0;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnMouseMove( wxMouseEvent &event )
-{
-    if ( !m_pTxtHelpCaption )
-        return;
-
-    int y = event.m_y;
-
-    if ( m_dragStatus > 0 )
-    {
-        int sy = y - m_dragOffset;
-
-        // Calculate drag limits
-        int bottom_limit = m_height - m_splitterHeight + 1;
-        int top_limit = m_pPropGrid->m_lineHeight;
-#if wxUSE_TOOLBAR
-        if ( m_pToolbar ) top_limit += m_pToolbar->GetSize().y;
-#endif
-
-        if ( sy >= top_limit && sy < bottom_limit )
-        {
-
-            int change = sy - m_splitterY;
-            if ( change )
-            {
-                m_splitterY = sy;
-
-                m_pPropGrid->SetSize( m_width, m_splitterY - m_pPropGrid->GetPosition().y );
-                UpdateDescriptionBox( m_splitterY, m_width, m_height );
-
-                m_extraHeight -= change;
-                InvalidateBestSize();
-            }
-
-        }
-
-    }
-    else
-    {
-        if ( y >= m_splitterY && y < (m_splitterY+m_splitterHeight+2) )
-        {
-            SetCursor ( m_cursorSizeNS );
-            m_onSplitter = 1;
-        }
-        else
-        {
-            if ( m_onSplitter )
-            {
-                SetCursor ( wxNullCursor );
-            }
-            m_onSplitter = 0;
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnMouseClick( wxMouseEvent &event )
-{
-    int y = event.m_y;
-
-    // Click on splitter.
-    if ( y >= m_splitterY && y < (m_splitterY+m_splitterHeight+2) )
-    {
-        if ( m_dragStatus == 0 )
-        {
-            //
-            // Begin draggin the splitter
-            //
-
-            BEGIN_MOUSE_CAPTURE
-
-            m_dragStatus = 1;
-
-            m_dragOffset = y - m_splitterY;
-
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::OnMouseUp( wxMouseEvent &event )
-{
-    // No event type check - basicly calling this method should
-    // just stop dragging.
-
-    if ( m_dragStatus >= 1 )
-    {
-        //
-        // End Splitter Dragging
-        //
-
-        int y = event.m_y;
-
-        // DO NOT ENABLE FOLLOWING LINE!
-        // (it is only here as a reminder to not to do it)
-        //m_splitterY = y;
-
-        // This is necessary to return cursor
-        END_MOUSE_CAPTURE
-
-        // Set back the default cursor, if necessary
-        if ( y < m_splitterY || y >= (m_splitterY+m_splitterHeight+2) )
-        {
-            SetCursor ( wxNullCursor );
-        }
-
-        m_dragStatus = 0;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridManager::SetSplitterPosition( int pos, int splitterColumn )
-{
-    wxASSERT_MSG( GetPageCount(),
-                  wxT("SetSplitterPosition() has no effect until pages have been added") );
-
-    size_t i;
-    for ( i=0; i<GetPageCount(); i++ )
-    {
-        wxPropertyGridPage* page = GetPage(i);
-        page->DoSetSplitterPosition( pos, splitterColumn, false );
-    }
-
-    m_pPropGrid->SetInternalFlag(wxPG_FL_SPLITTER_PRE_SET);
-}
-
-// -----------------------------------------------------------------------
-// wxPGVIterator_Manager
-// -----------------------------------------------------------------------
-
-// Default returned by wxPropertyGridInterface::CreateVIterator().
-class wxPGVIteratorBase_Manager : public wxPGVIteratorBase
-{
-public:
-    wxPGVIteratorBase_Manager( wxPropertyGridManager* manager, int flags )
-        : m_manager(manager), m_flags(flags), m_curPage(0)
-    {
-        m_it.Init(manager->GetPage(0), flags);
-    }
-    virtual ~wxPGVIteratorBase_Manager() { }
-    virtual void Next()
-    {
-        m_it.Next();
-
-        // Next page?
-        if ( m_it.AtEnd() )
-        {
-            m_curPage++;
-            if ( m_curPage < m_manager->GetPageCount() )
-                m_it.Init( m_manager->GetPage(m_curPage), m_flags );
-        }
-    }
-private:
-    wxPropertyGridManager*  m_manager;
-    int                     m_flags;
-    unsigned int            m_curPage;
-};
-
-wxPGVIterator wxPropertyGridManager::GetVIterator( int flags ) const
-{
-    return wxPGVIterator( new wxPGVIteratorBase_Manager( (wxPropertyGridManager*)this, flags ) );
-}
-
-#endif  // wxUSE_PROPGRID
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/manager.cpp
+// Purpose:     wxPropertyGridManager
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2005-01-14
+// RCS-ID:      $Id: manager.cpp 58971 2009-02-17 18:01:06Z JMS $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/cursor.h"
+    #include "wx/settings.h"
+    #include "wx/textctrl.h"
+    #include "wx/sizer.h"
+    #include "wx/statusbr.h"
+    #include "wx/intl.h"
+#endif
+
+// This define is necessary to prevent macro clearing
+#define __wxPG_SOURCE_FILE__
+
+#include "wx/propgrid/propgrid.h"
+
+#include "wx/propgrid/manager.h"
+
+
+#define wxPG_MAN_ALTERNATE_BASE_ID          11249 // Needed for wxID_ANY madnesss
+
+
+// -----------------------------------------------------------------------
+
+// For wxMSW cursor consistency, we must do mouse capturing even
+// when using custom controls
+
+#define BEGIN_MOUSE_CAPTURE \
+    if ( !(m_iFlags & wxPG_FL_MOUSE_CAPTURED) ) \
+    { \
+        CaptureMouse(); \
+        m_iFlags |= wxPG_FL_MOUSE_CAPTURED; \
+    }
+
+#define END_MOUSE_CAPTURE \
+    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED ) \
+    { \
+        ReleaseMouse(); \
+        m_iFlags &= ~(wxPG_FL_MOUSE_CAPTURED); \
+    }
+
+// -----------------------------------------------------------------------
+// wxPropertyGridManager
+// -----------------------------------------------------------------------
+
+const char wxPropertyGridManagerNameStr[] = "wxPropertyGridManager";
+
+
+// Categoric Mode Icon
+static const char* gs_xpm_catmode[] = {
+"16 16 5 1",
+". c none",
+"B c black",
+"D c #868686",
+"L c #CACACA",
+"W c #FFFFFF",
+".DDD............",
+".DLD.BBBBBB.....",
+".DDD............",
+".....DDDDD.DDD..",
+"................",
+".....DDDDD.DDD..",
+"................",
+".....DDDDD.DDD..",
+"................",
+".....DDDDD.DDD..",
+"................",
+".DDD............",
+".DLD.BBBBBB.....",
+".DDD............",
+".....DDDDD.DDD..",
+"................"
+};
+
+// Alphabetic Mode Icon
+static const char* gs_xpm_noncatmode[] = {
+"16 16 5 1",
+". c none",
+"B c black",
+"D c #868686",
+"L c #000080",
+"W c #FFFFFF",
+"..DBD...DDD.DDD.",
+".DB.BD..........",
+".BBBBB..DDD.DDD.",
+".B...B..........",
+"...L....DDD.DDD.",
+"...L............",
+".L.L.L..DDD.DDD.",
+"..LLL...........",
+"...L....DDD.DDD.",
+"................",
+".BBBBB..DDD.DDD.",
+"....BD..........",
+"...BD...DDD.DDD.",
+"..BD............",
+".BBBBB..DDD.DDD.",
+"................"
+};
+
+// Default Page Icon.
+static const char* gs_xpm_defpage[] = {
+"16 16 5 1",
+". c none",
+"B c black",
+"D c #868686",
+"L c #000080",
+"W c #FFFFFF",
+"................",
+"................",
+"..BBBBBBBBBBBB..",
+"..B..........B..",
+"..B.BB.LLLLL.B..",
+"..B..........B..",
+"..B.BB.LLLLL.B..",
+"..B..........B..",
+"..B.BB.LLLLL.B..",
+"..B..........B..",
+"..B.BB.LLLLL.B..",
+"..B..........B..",
+"..BBBBBBBBBBBB..",
+"................",
+"................",
+"................"
+};
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPage
+// -----------------------------------------------------------------------
+
+
+IMPLEMENT_CLASS(wxPropertyGridPage, wxEvtHandler)
+
+
+BEGIN_EVENT_TABLE(wxPropertyGridPage, wxEvtHandler)
+END_EVENT_TABLE()
+
+
+wxPropertyGridPage::wxPropertyGridPage()
+    : wxEvtHandler(), wxPropertyGridInterface(), wxPropertyGridPageState()
+{
+    m_pState = this; // wxPropertyGridInterface to point to State
+    m_manager = NULL;
+    m_isDefault = false;
+}
+
+wxPropertyGridPage::~wxPropertyGridPage()
+{
+}
+
+void wxPropertyGridPage::Clear()
+{
+    GetStatePtr()->DoClear();
+}
+
+wxSize wxPropertyGridPage::FitColumns()
+{
+    wxSize sz = DoFitColumns();
+    return sz;
+}
+
+void wxPropertyGridPage::RefreshProperty( wxPGProperty* p )
+{
+    if ( m_manager )
+        m_manager->RefreshProperty(p);
+}
+
+void wxPropertyGridPage::OnShow()
+{
+}
+
+void wxPropertyGridPage::SetSplitterPosition( int splitterPos, int col )
+{
+    wxPropertyGrid* pg = GetGrid();
+    if ( pg->GetState() == this )
+        pg->SetSplitterPosition(splitterPos);
+    else
+        DoSetSplitterPosition(splitterPos, col, false);
+}
+
+void wxPropertyGridPage::DoSetSplitterPosition( int pos,
+                                                int splitterColumn,
+                                                bool allPages,
+                                                bool fromAutoCenter )
+{
+    if ( allPages && m_manager->GetPageCount() )
+        m_manager->SetSplitterPosition( pos, splitterColumn );
+    else
+        wxPropertyGridPageState::DoSetSplitterPosition( pos,
+                                                        splitterColumn,
+                                                        allPages,
+                                                        fromAutoCenter );
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridManager
+// -----------------------------------------------------------------------
+
+// Final default splitter y is client height minus this.
+#define wxPGMAN_DEFAULT_NEGATIVE_SPLITTER_Y         100
+
+// -----------------------------------------------------------------------
+
+IMPLEMENT_CLASS(wxPropertyGridManager, wxPanel)
+
+#define ID_ADVTOOLBAR_OFFSET        1
+#define ID_ADVHELPCAPTION_OFFSET    2
+#define ID_ADVHELPCONTENT_OFFSET    3
+//#define ID_ADVBUTTON_OFFSET         4
+#define ID_ADVTBITEMSBASE_OFFSET    5   // Must be last.
+
+// -----------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(wxPropertyGridManager, wxPanel)
+  EVT_MOTION(wxPropertyGridManager::OnMouseMove)
+  EVT_SIZE(wxPropertyGridManager::OnResize)
+  EVT_PAINT(wxPropertyGridManager::OnPaint)
+  EVT_LEFT_DOWN(wxPropertyGridManager::OnMouseClick)
+  EVT_LEFT_UP(wxPropertyGridManager::OnMouseUp)
+  EVT_LEAVE_WINDOW(wxPropertyGridManager::OnMouseEntry)
+  //EVT_ENTER_WINDOW(wxPropertyGridManager::OnMouseEntry)
+END_EVENT_TABLE()
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridManager::wxPropertyGridManager()
+    : wxPanel()
+{
+    Init1();
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridManager::wxPropertyGridManager( wxWindow *parent,
+                                              wxWindowID id,
+                                              const wxPoint& pos,
+                                              const wxSize& size,
+                                              long style,
+                                              const wxString& name )
+    : wxPanel()
+{
+    Init1();
+    Create(parent,id,pos,size,style,name);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::Create( wxWindow *parent,
+                                    wxWindowID id,
+                                    const wxPoint& pos,
+                                    const wxSize& size,
+                                    long style,
+                                    const wxString& name )
+{
+    if ( !m_pPropGrid )
+        m_pPropGrid = CreatePropertyGrid();
+
+    bool res = wxPanel::Create( parent, id, pos, size,
+                                (style&0xFFFF0000)|wxWANTS_CHARS,
+                                name );
+    Init2(style);
+
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+//
+// Initialize values to defaults
+//
+void wxPropertyGridManager::Init1()
+{
+
+    m_pPropGrid = NULL;
+
+#if wxUSE_TOOLBAR
+    m_pToolbar = NULL;
+#endif
+    m_pTxtHelpCaption = NULL;
+    m_pTxtHelpContent = NULL;
+
+    m_emptyPage = NULL;
+
+    m_selPage = -1;
+
+    m_width = m_height = 0;
+
+    m_splitterHeight = 5;
+
+    m_splitterY = -1; // -1 causes default to be set.
+
+    m_nextDescBoxSize = -1;
+
+    m_extraHeight = 0;
+    m_dragStatus = 0;
+    m_onSplitter = 0;
+    m_iFlags = 0;
+}
+
+// -----------------------------------------------------------------------
+
+// These flags are always used in wxPropertyGrid integrated in wxPropertyGridManager.
+#ifndef __WXMAC__
+  #define wxPG_MAN_PROPGRID_FORCED_FLAGS (wxNO_BORDER|\
+                                          wxNO_FULL_REPAINT_ON_RESIZE| \
+                                          wxCLIP_CHILDREN)
+#else
+  #define wxPG_MAN_PROPGRID_FORCED_FLAGS (wxNO_BORDER| \
+                                          wxNO_FULL_REPAINT_ON_RESIZE| \
+                                          wxCLIP_CHILDREN)
+#endif
+
+// Which flags can be passed to underlying wxPropertyGrid.
+#define wxPG_MAN_PASS_FLAGS_MASK       (0xFFF0|wxTAB_TRAVERSAL)
+
+//
+// Initialize after parent etc. set
+//
+void wxPropertyGridManager::Init2( int style )
+{
+
+    if ( m_iFlags & wxPG_FL_INITIALIZED )
+        return;
+
+    m_windowStyle |= (style&0x0000FFFF);
+
+    wxSize csz = GetClientSize();
+
+    m_cursorSizeNS = wxCursor(wxCURSOR_SIZENS);
+
+    // Prepare the first page
+    // NB: But just prepare - you still need to call Add/InsertPage
+    //     to actually add properties on it.
+    wxPropertyGridPage* pd = new wxPropertyGridPage();
+    pd->m_isDefault = true;
+    pd->m_manager = this;
+    wxPropertyGridPageState* state = pd->GetStatePtr();
+    state->m_pPropGrid = m_pPropGrid;
+    m_arrPages.push_back( pd );
+    m_pPropGrid->m_pState = state;
+
+    wxWindowID baseId = GetId();
+    wxWindowID useId = baseId;
+    if ( baseId < 0 )
+        baseId = wxPG_MAN_ALTERNATE_BASE_ID;
+
+    m_baseId = baseId;
+
+#ifdef __WXMAC__
+   // Smaller controls on Mac
+   SetWindowVariant(wxWINDOW_VARIANT_SMALL);
+#endif
+
+    // Create propertygrid.
+    m_pPropGrid->Create(this,baseId,wxPoint(0,0),csz,
+                        (m_windowStyle&wxPG_MAN_PASS_FLAGS_MASK)
+                            |wxPG_MAN_PROPGRID_FORCED_FLAGS);
+
+    m_pPropGrid->m_eventObject = this;
+
+    m_pPropGrid->SetId(useId);
+
+    m_pPropGrid->m_iFlags |= wxPG_FL_IN_MANAGER;
+
+    m_pState = m_pPropGrid->m_pState;
+
+    m_pPropGrid->SetExtraStyle(wxPG_EX_INIT_NOCAT);
+
+    m_nextTbInd = baseId+ID_ADVTBITEMSBASE_OFFSET + 2;
+
+
+    // Connect to property grid onselect event.
+    // NB: Even if wxID_ANY is used, this doesn't connect properly in wxPython
+    //     (see wxPropertyGridManager::ProcessEvent).
+    Connect(m_pPropGrid->GetId()/*wxID_ANY*/,
+            wxEVT_PG_SELECTED,
+            wxPropertyGridEventHandler(wxPropertyGridManager::OnPropertyGridSelect) );
+
+    // Connect to toolbar button events.
+    Connect(baseId+ID_ADVTBITEMSBASE_OFFSET,baseId+ID_ADVTBITEMSBASE_OFFSET+50,
+            wxEVT_COMMAND_TOOL_CLICKED,
+            wxCommandEventHandler(wxPropertyGridManager::OnToolbarClick) );
+
+    // Optional initial controls.
+    m_width = -12345;
+
+    m_iFlags |= wxPG_FL_INITIALIZED;
+
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridManager::~wxPropertyGridManager()
+{
+    END_MOUSE_CAPTURE
+
+    m_pPropGrid->DoSelectProperty(NULL);
+    m_pPropGrid->m_pState = NULL;
+
+    size_t i;
+    for ( i=0; i<m_arrPages.size(); i++ )
+    {
+        delete m_arrPages[i];
+    }
+
+    delete m_emptyPage;
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGrid* wxPropertyGridManager::CreatePropertyGrid() const
+{
+    return new wxPropertyGrid();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetId( wxWindowID winid )
+{
+    wxWindow::SetId(winid);
+
+    // TODO: Reconnect propgrid event handler(s).
+
+    m_pPropGrid->SetId(winid);
+}
+
+// -----------------------------------------------------------------------
+
+wxSize wxPropertyGridManager::DoGetBestSize() const
+{
+    return wxSize(60,150);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::SetFont( const wxFont& font )
+{
+    bool res = wxWindow::SetFont(font);
+    m_pPropGrid->SetFont(font);
+
+    // TODO: Need to do caption recacalculations for other pages as well.
+    unsigned int i;
+    for ( i=0; i<m_arrPages.size(); i++ )
+    {
+        wxPropertyGridPage* page = GetPage(i);
+
+        if ( page != m_pPropGrid->GetState() )
+            page->CalculateFontAndBitmapStuff(-1);
+    }
+
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetExtraStyle( long exStyle )
+{
+    wxWindow::SetExtraStyle( exStyle );
+    m_pPropGrid->SetExtraStyle( exStyle & 0xFFFFF000 );
+#if wxUSE_TOOLBAR
+    if ( (exStyle & wxPG_EX_NO_FLAT_TOOLBAR) && m_pToolbar )
+        RecreateControls();
+#endif
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::Freeze()
+{
+    m_pPropGrid->Freeze();
+    wxWindow::Freeze();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::Thaw()
+{
+    wxWindow::Thaw();
+    m_pPropGrid->Thaw();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetWindowStyleFlag( long style )
+{
+    int oldWindowStyle = GetWindowStyleFlag();
+
+    wxWindow::SetWindowStyleFlag( style );
+    m_pPropGrid->SetWindowStyleFlag( (m_pPropGrid->GetWindowStyleFlag()&~(wxPG_MAN_PASS_FLAGS_MASK)) |
+                                   (style&wxPG_MAN_PASS_FLAGS_MASK) );
+
+    // Need to re-position windows?
+    if ( (oldWindowStyle & (wxPG_TOOLBAR|wxPG_DESCRIPTION)) !=
+         (style & (wxPG_TOOLBAR|wxPG_DESCRIPTION)) )
+    {
+        RecreateControls();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+// Actually shows given page.
+bool wxPropertyGridManager::DoSelectPage( int index )
+{
+    // -1 means no page was selected
+    //wxASSERT( m_selPage >= 0 );
+
+    wxCHECK_MSG( index >= -1 && index < (int)GetPageCount(),
+                 false,
+                 wxT("invalid page index") );
+
+    if ( m_selPage == index )
+        return true;
+
+    if ( m_pPropGrid->m_selected )
+    {
+        if ( !m_pPropGrid->ClearSelection() )
+            return false;
+    }
+
+    wxPropertyGridPage* prevPage;
+
+    if ( m_selPage >= 0 )
+        prevPage = GetPage(m_selPage);
+    else
+        prevPage = m_emptyPage;
+
+    wxPropertyGridPage* nextPage;
+
+    if ( index >= 0 )
+    {
+        nextPage = m_arrPages[index];
+
+        nextPage->OnShow();
+    }
+    else
+    {
+        if ( !m_emptyPage )
+        {
+            m_emptyPage = new wxPropertyGridPage();
+            m_emptyPage->m_pPropGrid = m_pPropGrid;
+        }
+
+        nextPage = m_emptyPage;
+    }
+
+    m_iFlags |= wxPG_FL_DESC_REFRESH_REQUIRED;
+
+    m_pPropGrid->SwitchState( nextPage->GetStatePtr() );
+
+    m_pState = m_pPropGrid->m_pState;
+
+    m_selPage = index;
+
+#if wxUSE_TOOLBAR
+    if ( m_pToolbar )
+    {
+        if ( index >= 0 )
+            m_pToolbar->ToggleTool( nextPage->m_id, true );
+        else
+            m_pToolbar->ToggleTool( prevPage->m_id, false );
+    }
+#endif
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+// Changes page *and* set the target page for insertion operations.
+void wxPropertyGridManager::SelectPage( int index )
+{
+    DoSelectPage(index);
+}
+
+// -----------------------------------------------------------------------
+
+int wxPropertyGridManager::GetPageByName( const wxString& name ) const
+{
+    size_t i;
+    for ( i=0; i<GetPageCount(); i++ )
+    {
+        if ( m_arrPages[i]->m_label == name )
+            return i;
+    }
+    return wxNOT_FOUND;
+}
+
+// -----------------------------------------------------------------------
+
+int wxPropertyGridManager::GetPageByState( const wxPropertyGridPageState* pState ) const
+{
+    wxASSERT( pState );
+
+    size_t i;
+    for ( i=0; i<GetPageCount(); i++ )
+    {
+        if ( pState == m_arrPages[i]->GetStatePtr() )
+            return i;
+    }
+
+    return wxNOT_FOUND;
+}
+
+// -----------------------------------------------------------------------
+
+const wxString& wxPropertyGridManager::GetPageName( int index ) const
+{
+    wxASSERT( index >= 0 && index < (int)GetPageCount() );
+    return m_arrPages[index]->m_label;
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridPageState* wxPropertyGridManager::GetPageState( int page ) const
+{
+    // Do not change this into wxCHECK because returning NULL is important
+    // for wxPropertyGridInterface page enumeration mechanics.
+    if ( page >= (int)GetPageCount() )
+        return NULL;
+
+    if ( page == -1 )
+        return m_pState;
+    return m_arrPages[page];
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::Clear()
+{
+    m_pPropGrid->ClearSelection(false);
+
+    m_pPropGrid->Freeze();
+
+    int i;
+    for ( i=(int)GetPageCount()-1; i>=0; i-- )
+        RemovePage(i);
+
+    // Reset toolbar ids
+    m_nextTbInd = m_baseId+ID_ADVTBITEMSBASE_OFFSET + 2;
+
+    m_pPropGrid->Thaw();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::ClearPage( int page )
+{
+    wxASSERT( page >= 0 );
+    wxASSERT( page < (int)GetPageCount() );
+
+    if ( page >= 0 && page < (int)GetPageCount() )
+    {
+        wxPropertyGridPageState* state = m_arrPages[page];
+
+        if ( state == m_pPropGrid->GetState() )
+            m_pPropGrid->Clear();
+        else
+            state->DoClear();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+int wxPropertyGridManager::GetColumnCount( int page ) const
+{
+    wxASSERT( page >= -1 );
+    wxASSERT( page < (int)GetPageCount() );
+
+    return GetPageState(page)->GetColumnCount();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetColumnCount( int colCount, int page )
+{
+    wxASSERT( page >= -1 );
+    wxASSERT( page < (int)GetPageCount() );
+
+    GetPageState(page)->SetColumnCount( colCount );
+    GetGrid()->Refresh();
+}
+// -----------------------------------------------------------------------
+
+size_t wxPropertyGridManager::GetPageCount() const
+{
+	if ( !(m_iFlags & wxPG_MAN_FL_PAGE_INSERTED) )
+		return 0;
+
+	return m_arrPages.size();
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridPage* wxPropertyGridManager::InsertPage( int index,
+                                                       const wxString& label,
+                                                       const wxBitmap& bmp,
+                                                       wxPropertyGridPage* pageObj )
+{
+    if ( index < 0 )
+        index = GetPageCount();
+
+    wxCHECK_MSG( (size_t)index == GetPageCount(), NULL,
+        wxT("wxPropertyGridManager currently only supports appending pages (due to wxToolBar limitation)."));
+
+    bool needInit = true;
+    bool isPageInserted = m_iFlags & wxPG_MAN_FL_PAGE_INSERTED ? true : false;
+
+    wxASSERT( index == 0 || isPageInserted );
+
+    if ( !pageObj )
+    {
+        // No custom page object was given, so we will either re-use the default base
+        // page (if index==0), or create a new default page object.
+        if ( !isPageInserted )
+        {
+            pageObj = GetPage(0);
+            // Of course, if the base page was custom, we need to delete and
+            // re-create it.
+            if ( !pageObj->m_isDefault )
+            {
+                delete pageObj;
+                pageObj = new wxPropertyGridPage();
+                m_arrPages[0] = pageObj;
+            }
+            needInit = false;
+        }
+        else
+        {
+            pageObj = new wxPropertyGridPage();
+        }
+        pageObj->m_isDefault = true;
+    }
+    else
+    {
+        if ( !isPageInserted )
+        {
+            // Initial page needs to be deleted and replaced
+            delete GetPage(0);
+            m_arrPages[0] = pageObj;
+            m_pPropGrid->m_pState = pageObj->GetStatePtr();
+        }
+    }
+
+    wxPropertyGridPageState* state = pageObj->GetStatePtr();
+
+    pageObj->m_manager = this;
+
+    if ( needInit )
+    {
+        state->m_pPropGrid = m_pPropGrid;
+        state->InitNonCatMode();
+    }
+
+    if ( label.length() )
+    {
+        wxASSERT_MSG( !pageObj->m_label.length(),
+                      wxT("If page label is given in constructor, empty label must be given in AddPage"));
+        pageObj->m_label = label;
+    }
+
+    pageObj->m_id = m_nextTbInd;
+
+    if ( isPageInserted )
+        m_arrPages.push_back( pageObj );
+
+#if wxUSE_TOOLBAR
+    if ( m_windowStyle & wxPG_TOOLBAR )
+    {
+        if ( !m_pToolbar )
+            RecreateControls();
+
+        if ( !(GetExtraStyle()&wxPG_EX_HIDE_PAGE_BUTTONS) )
+        {
+            wxASSERT( m_pToolbar );
+
+            // Add separator before first page.
+            if ( GetPageCount() < 2 && (GetExtraStyle()&wxPG_EX_MODE_BUTTONS) &&
+                 m_pToolbar->GetToolsCount() < 3 )
+                m_pToolbar->AddSeparator();
+
+            if ( &bmp != &wxNullBitmap )
+                m_pToolbar->AddTool(m_nextTbInd,label,bmp,label,wxITEM_RADIO);
+                //m_pToolbar->InsertTool(index+3,m_nextTbInd,bmp);
+            else
+                m_pToolbar->AddTool(m_nextTbInd,label,wxBitmap( (const char**)gs_xpm_defpage ),
+                    label,wxITEM_RADIO);
+
+            m_nextTbInd++;
+
+            m_pToolbar->Realize();
+        }
+    }
+#else
+    wxUnusedVar(bmp);
+#endif
+
+    // If selected page was above the point of insertion, fix the current page index
+    if ( isPageInserted )
+    {
+        if ( m_selPage >= index )
+        {
+            m_selPage += 1;
+        }
+    }
+    else
+    {
+        // Set this value only when adding the first page
+        m_selPage = 0;
+    }
+
+    pageObj->Init();
+
+    m_iFlags |= wxPG_MAN_FL_PAGE_INSERTED;
+
+    wxASSERT( pageObj->GetGrid() );
+
+    return pageObj;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::IsAnyModified() const
+{
+    size_t i;
+    for ( i=0; i<GetPageCount(); i++ )
+    {
+        if ( m_arrPages[i]->GetStatePtr()->m_anyModified )
+            return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::IsPageModified( size_t index ) const
+{
+    if ( m_arrPages[index]->GetStatePtr()->m_anyModified )
+        return true;
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridManager::GetPageRoot( int index ) const
+{
+    wxASSERT( index >= 0 );
+    wxASSERT( index < (int)m_arrPages.size() );
+
+    return m_arrPages[index]->GetStatePtr()->m_properties;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::RemovePage( int page )
+{
+    wxCHECK_MSG( (page >= 0) && (page < (int)GetPageCount()),
+                 false,
+                 wxT("invalid page index") );
+
+    wxPropertyGridPage* pd = m_arrPages[page];
+
+    if ( m_arrPages.size() == 1 )
+    {
+        // Last page: do not remove page entry
+        m_pPropGrid->Clear();
+        m_selPage = -1;
+        m_iFlags &= ~wxPG_MAN_FL_PAGE_INSERTED;
+        pd->m_label.clear();
+    }
+
+    // Change selection if current is page
+    else if ( page == m_selPage )
+    {
+        if ( !m_pPropGrid->ClearSelection() )
+                return false;
+
+        // Substitute page to select
+        int substitute = page - 1;
+        if ( substitute < 0 )
+            substitute = page + 1;
+
+        SelectPage(substitute);
+    }
+
+    // Remove toolbar icon
+#if wxUSE_TOOLBAR
+    if ( HasFlag(wxPG_TOOLBAR) )
+    {
+        wxASSERT( m_pToolbar );
+
+        int toolPos = GetExtraStyle() & wxPG_EX_MODE_BUTTONS ? 3 : 0;
+        toolPos += page;
+
+        // Delete separator as well, for consistency
+        if ( (GetExtraStyle() & wxPG_EX_MODE_BUTTONS) &&
+             GetPageCount() == 1 )
+            m_pToolbar->DeleteToolByPos(2);
+
+        m_pToolbar->DeleteToolByPos(toolPos);
+    }
+#endif
+
+    if ( m_arrPages.size() > 1 )
+    {
+        m_arrPages.erase(m_arrPages.begin() + page);
+        delete pd;
+    }
+
+    // Adjust indexes that were above removed
+    if ( m_selPage > page )
+        m_selPage--;
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::ProcessEvent( wxEvent& event )
+{
+    int evtType = event.GetEventType();
+
+    // NB: For some reason, under wxPython, Connect in Init doesn't work properly,
+    //     so we'll need to call OnPropertyGridSelect manually. Multiple call's
+    //     don't really matter.
+    if ( evtType == wxEVT_PG_SELECTED )
+        OnPropertyGridSelect((wxPropertyGridEvent&)event);
+
+    // Property grid events get special attention
+    if ( evtType >= wxPG_BASE_EVT_TYPE &&
+         evtType < (wxPG_MAX_EVT_TYPE) &&
+         m_selPage >= 0 )
+    {
+        wxPropertyGridPage* page = GetPage(m_selPage);
+        wxPropertyGridEvent* pgEvent = wxDynamicCast(&event, wxPropertyGridEvent);
+
+        // Add property grid events to appropriate custom pages
+        // but stop propagating to parent if page says it is
+        // handling everything.
+        if ( pgEvent && !page->m_isDefault )
+        {
+            /*if ( pgEvent->IsPending() )
+                page->AddPendingEvent(event);
+            else*/
+                page->ProcessEvent(event);
+
+            if ( page->IsHandlingAllEvents() )
+                event.StopPropagation();
+        }
+    }
+
+    return wxPanel::ProcessEvent(event);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::RepaintDescBoxDecorations( wxDC& dc,
+                                                       int newSplitterY,
+                                                       int newWidth,
+                                                       int newHeight )
+{
+    // Draw background
+    wxColour bgcol = GetBackgroundColour();
+    dc.SetBrush(bgcol);
+    dc.SetPen(bgcol);
+    int rectHeight = m_splitterHeight;
+    dc.DrawRectangle(0, newSplitterY, newWidth, rectHeight);
+    dc.SetPen( wxSystemSettings::GetColour(wxSYS_COLOUR_3DDKSHADOW) );
+    int splitterBottom = newSplitterY + m_splitterHeight - 1;
+    int boxHeight = newHeight - splitterBottom;
+    if ( boxHeight > 1 )
+        dc.DrawRectangle(0, splitterBottom, newWidth, boxHeight);
+    else
+        dc.DrawLine(0, splitterBottom, newWidth, splitterBottom);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::UpdateDescriptionBox( int new_splittery, int new_width, int new_height )
+{
+    int use_hei = new_height;
+    use_hei--;
+
+    // Fix help control positions.
+    int cap_hei = m_pPropGrid->m_fontHeight;
+    int cap_y = new_splittery+m_splitterHeight+5;
+    int cnt_y = cap_y+cap_hei+3;
+    int sub_cap_hei = cap_y+cap_hei-use_hei;
+    int cnt_hei = use_hei-cnt_y;
+    if ( sub_cap_hei > 0 )
+    {
+        cap_hei -= sub_cap_hei;
+        cnt_hei = 0;
+    }
+    if ( cap_hei <= 2 )
+    {
+        m_pTxtHelpCaption->Show( false );
+        m_pTxtHelpContent->Show( false );
+    }
+    else
+    {
+        m_pTxtHelpCaption->SetSize(3,cap_y,new_width-6,cap_hei);
+        m_pTxtHelpCaption->Wrap(-1);
+        m_pTxtHelpCaption->Show( true );
+        if ( cnt_hei <= 2 )
+        {
+            m_pTxtHelpContent->Show( false );
+        }
+        else
+        {
+            m_pTxtHelpContent->SetSize(3,cnt_y,new_width-6,cnt_hei);
+            m_pTxtHelpContent->Show( true );
+        }
+    }
+
+    wxRect r(0, new_splittery, new_width, new_height-new_splittery);
+    RefreshRect(r);
+
+    m_splitterY = new_splittery;
+
+    m_iFlags &= ~(wxPG_FL_DESC_REFRESH_REQUIRED);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::RecalculatePositions( int width, int height )
+{
+    int propgridY = 0;
+    int propgridBottomY = height;
+
+    // Toolbar at the top.
+#if wxUSE_TOOLBAR
+    if ( m_pToolbar )
+    {
+        m_pToolbar->SetSize(0, 0, width, -1);
+        propgridY += m_pToolbar->GetSize().y;
+    }
+#endif
+
+    // Help box.
+    if ( m_pTxtHelpCaption )
+    {
+        int new_splittery = m_splitterY;
+
+        // Move m_splitterY
+        if ( ( m_splitterY >= 0 || m_nextDescBoxSize ) && m_height > 32 )
+        {
+            if ( m_nextDescBoxSize >= 0 )
+            {
+                new_splittery = m_height - m_nextDescBoxSize - m_splitterHeight;
+                m_nextDescBoxSize = -1;
+            }
+            new_splittery += (height-m_height);
+        }
+        else
+        {
+            new_splittery = height - wxPGMAN_DEFAULT_NEGATIVE_SPLITTER_Y;
+            if ( new_splittery < 32 )
+                new_splittery = 32;
+        }
+
+        // Check if beyond minimum.
+        int nspy_min = propgridY + m_pPropGrid->m_lineHeight;
+        if ( new_splittery < nspy_min )
+            new_splittery = nspy_min;
+
+        propgridBottomY = new_splittery;
+
+        UpdateDescriptionBox( new_splittery, width, height );
+    }
+
+    if ( m_iFlags & wxPG_FL_INITIALIZED )
+    {
+        int pgh = propgridBottomY - propgridY;
+        if ( pgh < 0 )
+            pgh = 0;
+        m_pPropGrid->SetSize( 0, propgridY, width, pgh );
+
+        m_extraHeight = height - pgh;
+
+        m_width = width;
+        m_height = height;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetDescBoxHeight( int ht, bool refresh )
+{
+    if ( m_windowStyle & wxPG_DESCRIPTION )
+    {
+        if ( ht != GetDescBoxHeight() )
+        {
+            m_nextDescBoxSize = ht;
+            if ( refresh )
+                RecalculatePositions(m_width, m_height);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+int wxPropertyGridManager::GetDescBoxHeight() const
+{
+    return GetClientSize().y - m_splitterY - m_splitterHeight;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnPaint( wxPaintEvent& WXUNUSED(event) )
+{
+    wxPaintDC dc(this);
+
+    // Update everything inside the box
+    wxRect r = GetUpdateRegion().GetBox();
+
+    // Repaint splitter and any other description box decorations
+    if ( (r.y + r.height) >= m_splitterY )
+        RepaintDescBoxDecorations( dc, m_splitterY, m_width, m_height );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::Refresh(bool eraseBackground, const wxRect* rect )
+{
+    m_pPropGrid->Refresh(eraseBackground);
+    wxWindow::Refresh(eraseBackground,rect);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::RefreshProperty( wxPGProperty* p )
+{
+    wxPropertyGrid* grid = p->GetGrid();
+
+    if ( GetPage(m_selPage)->GetStatePtr() == p->GetParent()->GetParentState() )
+        grid->RefreshProperty(p);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::RecreateControls()
+{
+
+    bool was_shown = IsShown();
+    if ( was_shown )
+        Show ( false );
+
+    wxWindowID baseId = m_pPropGrid->GetId();
+    if ( baseId < 0 )
+        baseId = wxPG_MAN_ALTERNATE_BASE_ID;
+
+#if wxUSE_TOOLBAR
+    if ( m_windowStyle & wxPG_TOOLBAR )
+    {
+        // Has toolbar.
+        if ( !m_pToolbar )
+        {
+            m_pToolbar = new wxToolBar(this,baseId+ID_ADVTOOLBAR_OFFSET,
+                                       wxDefaultPosition,wxDefaultSize,
+                                       ((GetExtraStyle()&wxPG_EX_NO_FLAT_TOOLBAR)?0:wxTB_FLAT)
+                                        /*| wxTB_HORIZONTAL | wxNO_BORDER*/ );
+            m_pToolbar->SetToolBitmapSize(wxSize(16, 15));
+
+        #if defined(__WXMSW__)
+            // Eliminate toolbar flicker on XP
+            // NOTE: Not enabled since it corrupts drawing somewhat.
+
+            /*
+            #ifndef WS_EX_COMPOSITED
+                #define WS_EX_COMPOSITED        0x02000000L
+            #endif
+
+            HWND hWnd = (HWND)m_pToolbar->GetHWND();
+
+            ::SetWindowLong( hWnd, GWL_EXSTYLE,
+                             ::GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED );
+            */
+
+        #endif
+
+            m_pToolbar->SetCursor ( *wxSTANDARD_CURSOR );
+
+            if ( (GetExtraStyle()&wxPG_EX_MODE_BUTTONS) )
+            {
+                wxString desc1(_("Categorized Mode"));
+                wxString desc2(_("Alphabetic Mode"));
+                m_pToolbar->AddTool(baseId+ID_ADVTBITEMSBASE_OFFSET+0,
+                    desc1,wxBitmap ( (const char**)gs_xpm_catmode ),
+                    desc1,wxITEM_RADIO);
+                m_pToolbar->AddTool(baseId+ID_ADVTBITEMSBASE_OFFSET+1,
+                    desc2,wxBitmap ( (const char**)gs_xpm_noncatmode ),
+                    desc2,wxITEM_RADIO);
+                m_pToolbar->Realize();
+            }
+
+        }
+
+        if ( (GetExtraStyle()&wxPG_EX_MODE_BUTTONS) )
+        {
+            // Toggle correct mode button.
+            // TODO: This doesn't work in wxMSW (when changing,
+            // both items will get toggled).
+            int toggle_but_on_ind = ID_ADVTBITEMSBASE_OFFSET+0;
+            int toggle_but_off_ind = ID_ADVTBITEMSBASE_OFFSET+1;
+            if ( m_pPropGrid->m_pState->IsInNonCatMode() )
+            {
+                toggle_but_on_ind++;
+                toggle_but_off_ind--;
+            }
+
+            m_pToolbar->ToggleTool(baseId+toggle_but_on_ind,true);
+            m_pToolbar->ToggleTool(baseId+toggle_but_off_ind,false);
+        }
+
+    }
+    else
+    {
+        // No toolbar.
+        if ( m_pToolbar )
+            m_pToolbar->Destroy();
+        m_pToolbar = NULL;
+    }
+#endif
+
+    if ( m_windowStyle & wxPG_DESCRIPTION )
+    {
+        // Has help box.
+        m_pPropGrid->m_iFlags |= (wxPG_FL_NOSTATUSBARHELP);
+
+        if ( !m_pTxtHelpCaption )
+        {
+            m_pTxtHelpCaption = new wxStaticText(this,
+                                                 baseId+ID_ADVHELPCAPTION_OFFSET,
+                                                 wxT(""),
+                                                 wxDefaultPosition,
+                                                 wxDefaultSize,
+                                                 wxALIGN_LEFT|wxST_NO_AUTORESIZE);
+            m_pTxtHelpCaption->SetFont( m_pPropGrid->m_captionFont );
+            m_pTxtHelpCaption->SetCursor( *wxSTANDARD_CURSOR );
+        }
+        if ( !m_pTxtHelpContent )
+        {
+            m_pTxtHelpContent = new wxStaticText(this,
+                                                 baseId+ID_ADVHELPCONTENT_OFFSET,
+                                                 wxT(""),
+                                                 wxDefaultPosition,
+                                                 wxDefaultSize,
+                                                 wxALIGN_LEFT|wxST_NO_AUTORESIZE);
+            m_pTxtHelpContent->SetCursor( *wxSTANDARD_CURSOR );
+        }
+
+        SetDescribedProperty(GetSelection());
+    }
+    else
+    {
+        // No help box.
+        m_pPropGrid->m_iFlags &= ~(wxPG_FL_NOSTATUSBARHELP);
+
+        if ( m_pTxtHelpCaption )
+            m_pTxtHelpCaption->Destroy();
+
+        m_pTxtHelpCaption = NULL;
+
+        if ( m_pTxtHelpContent )
+            m_pTxtHelpContent->Destroy();
+
+        m_pTxtHelpContent = NULL;
+    }
+
+    int width, height;
+
+    GetClientSize(&width,&height);
+
+    RecalculatePositions(width,height);
+
+    if ( was_shown )
+        Show ( true );
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridManager::DoGetPropertyByName( const wxString& name ) const
+{
+    size_t i;
+    for ( i=0; i<GetPageCount(); i++ )
+    {
+        wxPropertyGridPageState* pState = m_arrPages[i]->GetStatePtr();
+        wxPGProperty* p = pState->BaseGetPropertyByName(name);
+        if ( p )
+        {
+            return p;
+        }
+    }
+    return NULL;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::EnsureVisible( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+
+    wxPropertyGridPageState* parentState = p->GetParentState();
+
+    // Select correct page.
+    if ( m_pPropGrid->m_pState != parentState )
+        DoSelectPage( GetPageByState(parentState) );
+
+    return m_pPropGrid->EnsureVisible(id);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnToolbarClick( wxCommandEvent &event )
+{
+    int id = event.GetId();
+    if ( id >= 0 )
+    {
+        int baseId = m_pPropGrid->GetId();
+        if ( baseId < 0 )
+            baseId = wxPG_MAN_ALTERNATE_BASE_ID;
+
+        if ( id == ( baseId + ID_ADVTBITEMSBASE_OFFSET + 0 ) )
+        {
+            // Categorized mode.
+            if ( m_pPropGrid->m_windowStyle & wxPG_HIDE_CATEGORIES )
+            {
+                if ( !m_pPropGrid->HasInternalFlag(wxPG_FL_CATMODE_AUTO_SORT) )
+                    m_pPropGrid->m_windowStyle &= ~wxPG_AUTO_SORT;
+                m_pPropGrid->EnableCategories( true );
+            }
+        }
+        else if ( id == ( baseId + ID_ADVTBITEMSBASE_OFFSET + 1 ) )
+        {
+            // Alphabetic mode.
+            if ( !(m_pPropGrid->m_windowStyle & wxPG_HIDE_CATEGORIES) )
+            {
+                if ( m_pPropGrid->HasFlag(wxPG_AUTO_SORT) )
+                    m_pPropGrid->SetInternalFlag(wxPG_FL_CATMODE_AUTO_SORT);
+                else
+                    m_pPropGrid->ClearInternalFlag(wxPG_FL_CATMODE_AUTO_SORT);
+
+                m_pPropGrid->m_windowStyle |= wxPG_AUTO_SORT;
+                m_pPropGrid->EnableCategories( false );
+            }
+        }
+        else
+        {
+            // Page Switching.
+
+            int index = -1;
+            size_t i;
+            wxPropertyGridPage* pdc;
+
+            // Find page with given id.
+            for ( i=0; i<GetPageCount(); i++ )
+            {
+                pdc = m_arrPages[i];
+                if ( pdc->m_id == id )
+                {
+                    index = i;
+                    break;
+                }
+            }
+
+            wxASSERT( index >= 0 );
+
+            if ( DoSelectPage( index ) )
+            {
+
+                // Event dispatching must be last.
+                m_pPropGrid->SendEvent(  wxEVT_PG_PAGE_CHANGED, NULL );
+
+            }
+            else
+            {
+                // TODO: Depress the old button on toolbar.
+            }
+
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridManager::SetEditableStateItem( const wxString& name, wxVariant value )
+{
+    if ( name == wxS("descboxheight") )
+    {
+        SetDescBoxHeight(value.GetLong(), true);
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+wxVariant wxPropertyGridManager::GetEditableStateItem( const wxString& name ) const
+{
+    if ( name == wxS("descboxheight") )
+    {
+        return (long) GetDescBoxHeight();
+    }
+    return wxNullVariant;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetDescription( const wxString& label, const wxString& content )
+{
+    if ( m_pTxtHelpCaption )
+    {
+        wxSize osz1 = m_pTxtHelpCaption->GetSize();
+        wxSize osz2 = m_pTxtHelpContent->GetSize();
+
+        m_pTxtHelpCaption->SetLabel(label);
+        m_pTxtHelpContent->SetLabel(content);
+
+        m_pTxtHelpCaption->SetSize(-1,osz1.y);
+        m_pTxtHelpContent->SetSize(-1,osz2.y);
+
+        UpdateDescriptionBox( m_splitterY, m_width, m_height );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetDescribedProperty( wxPGProperty* p )
+{
+    if ( m_pTxtHelpCaption )
+    {
+        if ( p )
+        {
+            SetDescription( p->GetLabel(), p->GetHelpString() );
+        }
+        else
+        {
+            SetDescription( wxEmptyString, wxEmptyString );
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetSplitterLeft( bool subProps, bool allPages )
+{
+    if ( !allPages )
+    {
+        m_pPropGrid->SetSplitterLeft(subProps);
+    }
+    else
+    {
+        wxClientDC dc(this);
+        dc.SetFont(m_pPropGrid->GetFont());
+
+        int highest = 0;
+        unsigned int i;
+
+        for ( i=0; i<GetPageCount(); i++ )
+        {
+            int maxW = m_pState->GetColumnFitWidth(dc, m_arrPages[i]->m_properties, 0, subProps );
+            maxW += m_pPropGrid->m_marginWidth;
+            if ( maxW > highest )
+                highest = maxW;
+        }
+
+        if ( highest > 0 )
+            m_pPropGrid->SetSplitterPosition( highest );
+
+        m_pPropGrid->m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnPropertyGridSelect( wxPropertyGridEvent& event )
+{
+    // Check id.
+    wxASSERT_MSG( GetId() == m_pPropGrid->GetId(),
+        wxT("wxPropertyGridManager id must be set with wxPropertyGridManager::SetId (not wxWindow::SetId).") );
+
+    SetDescribedProperty(event.GetProperty());
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnResize( wxSizeEvent& WXUNUSED(event) )
+{
+    int width, height;
+
+    GetClientSize(&width,&height);
+
+    if ( m_width == -12345 )
+        RecreateControls();
+
+    RecalculatePositions(width,height);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnMouseEntry( wxMouseEvent& WXUNUSED(event) )
+{
+    // Correct cursor. This is required atleast for wxGTK, for which
+    // setting button's cursor to *wxSTANDARD_CURSOR does not work.
+    SetCursor( wxNullCursor );
+    m_onSplitter = 0;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnMouseMove( wxMouseEvent &event )
+{
+    if ( !m_pTxtHelpCaption )
+        return;
+
+    int y = event.m_y;
+
+    if ( m_dragStatus > 0 )
+    {
+        int sy = y - m_dragOffset;
+
+        // Calculate drag limits
+        int bottom_limit = m_height - m_splitterHeight + 1;
+        int top_limit = m_pPropGrid->m_lineHeight;
+#if wxUSE_TOOLBAR
+        if ( m_pToolbar ) top_limit += m_pToolbar->GetSize().y;
+#endif
+
+        if ( sy >= top_limit && sy < bottom_limit )
+        {
+
+            int change = sy - m_splitterY;
+            if ( change )
+            {
+                m_splitterY = sy;
+
+                m_pPropGrid->SetSize( m_width, m_splitterY - m_pPropGrid->GetPosition().y );
+                UpdateDescriptionBox( m_splitterY, m_width, m_height );
+
+                m_extraHeight -= change;
+                InvalidateBestSize();
+            }
+
+        }
+
+    }
+    else
+    {
+        if ( y >= m_splitterY && y < (m_splitterY+m_splitterHeight+2) )
+        {
+            SetCursor ( m_cursorSizeNS );
+            m_onSplitter = 1;
+        }
+        else
+        {
+            if ( m_onSplitter )
+            {
+                SetCursor ( wxNullCursor );
+            }
+            m_onSplitter = 0;
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnMouseClick( wxMouseEvent &event )
+{
+    int y = event.m_y;
+
+    // Click on splitter.
+    if ( y >= m_splitterY && y < (m_splitterY+m_splitterHeight+2) )
+    {
+        if ( m_dragStatus == 0 )
+        {
+            //
+            // Begin draggin the splitter
+            //
+
+            BEGIN_MOUSE_CAPTURE
+
+            m_dragStatus = 1;
+
+            m_dragOffset = y - m_splitterY;
+
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::OnMouseUp( wxMouseEvent &event )
+{
+    // No event type check - basicly calling this method should
+    // just stop dragging.
+
+    if ( m_dragStatus >= 1 )
+    {
+        //
+        // End Splitter Dragging
+        //
+
+        int y = event.m_y;
+
+        // DO NOT ENABLE FOLLOWING LINE!
+        // (it is only here as a reminder to not to do it)
+        //m_splitterY = y;
+
+        // This is necessary to return cursor
+        END_MOUSE_CAPTURE
+
+        // Set back the default cursor, if necessary
+        if ( y < m_splitterY || y >= (m_splitterY+m_splitterHeight+2) )
+        {
+            SetCursor ( wxNullCursor );
+        }
+
+        m_dragStatus = 0;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridManager::SetSplitterPosition( int pos, int splitterColumn )
+{
+    wxASSERT_MSG( GetPageCount(),
+                  wxT("SetSplitterPosition() has no effect until pages have been added") );
+
+    size_t i;
+    for ( i=0; i<GetPageCount(); i++ )
+    {
+        wxPropertyGridPage* page = GetPage(i);
+        page->DoSetSplitterPosition( pos, splitterColumn, false );
+    }
+
+    m_pPropGrid->SetInternalFlag(wxPG_FL_SPLITTER_PRE_SET);
+}
+
+// -----------------------------------------------------------------------
+// wxPGVIterator_Manager
+// -----------------------------------------------------------------------
+
+// Default returned by wxPropertyGridInterface::CreateVIterator().
+class wxPGVIteratorBase_Manager : public wxPGVIteratorBase
+{
+public:
+    wxPGVIteratorBase_Manager( wxPropertyGridManager* manager, int flags )
+        : m_manager(manager), m_flags(flags), m_curPage(0)
+    {
+        m_it.Init(manager->GetPage(0), flags);
+    }
+    virtual ~wxPGVIteratorBase_Manager() { }
+    virtual void Next()
+    {
+        m_it.Next();
+
+        // Next page?
+        if ( m_it.AtEnd() )
+        {
+            m_curPage++;
+            if ( m_curPage < m_manager->GetPageCount() )
+                m_it.Init( m_manager->GetPage(m_curPage), m_flags );
+        }
+    }
+private:
+    wxPropertyGridManager*  m_manager;
+    int                     m_flags;
+    unsigned int            m_curPage;
+};
+
+wxPGVIterator wxPropertyGridManager::GetVIterator( int flags ) const
+{
+    return wxPGVIterator( new wxPGVIteratorBase_Manager( (wxPropertyGridManager*)this, flags ) );
+}
+
+#endif  // wxUSE_PROPGRID
Index: property.cpp
===================================================================
--- property.cpp	(revision 102)
+++ property.cpp	(working copy)
@@ -1,2883 +1,2883 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/property.cpp
-// Purpose:     wxPGProperty and related support classes
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2008-08-23
-// RCS-ID:      $Id: property.cpp 60793 2009-05-29 16:04:22Z JMS $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcmemory.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/settings.h"
-    #include "wx/intl.h"
-#endif
-
-#include "wx/propgrid/propgrid.h"
-
-
-#define PWC_CHILD_SUMMARY_LIMIT         16 // Maximum number of children summarized in a parent property's
-                                           // value field.
-
-#define PWC_CHILD_SUMMARY_CHAR_LIMIT    64 // Character limit of summary field when not editing
-
-#if wxPG_COMPATIBILITY_1_4
-
-// Used to establish backwards compatiblity
-const char* g_invalidStringContent = "@__TOTALLY_INVALID_STRING__@";
-
-#endif
-
-// -----------------------------------------------------------------------
-
-static void wxPGDrawFocusRect( wxDC& dc, const wxRect& rect )
-{
-#if defined(__WXMSW__) && !defined(__WXWINCE__)
-    // FIXME: Use DrawFocusRect code above (currently it draws solid line
-    //   for caption focus but works ok for other stuff).
-    //   Also, it seems that this code may not work in future wx versions.
-    dc.SetLogicalFunction(wxINVERT);
-
-    wxPen pen(*wxBLACK,1,wxDOT);
-    pen.SetCap(wxCAP_BUTT);
-    dc.SetPen(pen);
-    dc.SetBrush(*wxTRANSPARENT_BRUSH);
-
-    dc.DrawRectangle(rect);
-
-    dc.SetLogicalFunction(wxCOPY);
-#else
-    dc.SetLogicalFunction(wxINVERT);
-
-    dc.SetPen(wxPen(*wxBLACK,1,wxDOT));
-    dc.SetBrush(*wxTRANSPARENT_BRUSH);
-
-    dc.DrawRectangle(rect);
-
-    dc.SetLogicalFunction(wxCOPY);
-#endif
-}
-
-// -----------------------------------------------------------------------
-// wxPGCellRenderer
-// -----------------------------------------------------------------------
-
-wxSize wxPGCellRenderer::GetImageSize( const wxPGProperty* WXUNUSED(property),
-                                       int WXUNUSED(column),
-                                       int WXUNUSED(item) ) const
-{
-     return wxSize(0, 0);
-}
-
-void wxPGCellRenderer::DrawText( wxDC& dc, const wxRect& rect,
-                                 int xOffset, const wxString& text ) const
-{
-    dc.DrawText( text,
-                 rect.x+xOffset+wxPG_XBEFORETEXT,
-                 rect.y+((rect.height-dc.GetCharHeight())/2) );
-}
-
-void wxPGCellRenderer::DrawEditorValue( wxDC& dc, const wxRect& rect,
-                                        int xOffset, const wxString& text,
-                                        wxPGProperty* property,
-                                        const wxPGEditor* editor ) const
-{
-    int yOffset = ((rect.height-dc.GetCharHeight())/2);
-
-    if ( editor )
-    {
-        wxRect rect2(rect); 
-        rect2.x += xOffset;
-        rect2.y += yOffset;
-        rect2.height -= yOffset;
-        editor->DrawValue( dc, rect2, property, text );
-    }
-    else
-    {
-        dc.DrawText( text,
-                     rect.x+xOffset+wxPG_XBEFORETEXT,
-                     rect.y+yOffset );
-    }
-}
-
-void wxPGCellRenderer::DrawCaptionSelectionRect( wxDC& dc, int x, int y, int w, int h ) const
-{
-    wxRect focusRect(x,y+((h-dc.GetCharHeight())/2),w,h);
-    wxPGDrawFocusRect(dc,focusRect);
-}
-
-int wxPGCellRenderer::PreDrawCell( wxDC& dc, const wxRect& rect, const wxPGCell& cell, int flags ) const
-{
-    int imageWidth = 0;
-
-    // If possible, use cell colours
-    if ( !(flags & DontUseCellBgCol) )
-    {
-        dc.SetPen(cell.GetBgCol());
-        dc.SetBrush(cell.GetBgCol());
-    }
-
-    if ( !(flags & DontUseCellFgCol) )
-    {
-        dc.SetTextForeground(cell.GetFgCol());
-    }
-
-    // Draw Background, but only if not rendering in control
-    // (as control already has rendered correct background).
-    if ( !(flags & (Control|ChoicePopup)) )
-        dc.DrawRectangle(rect);
-
-    const wxBitmap& bmp = cell.GetBitmap();
-    if ( bmp.Ok() &&
-        // Do not draw oversized bitmap outside choice popup
-         ((flags & ChoicePopup) || bmp.GetHeight() < rect.height )
-        )
-    {
-        dc.DrawBitmap( bmp,
-                       rect.x + wxPG_CONTROL_MARGIN + wxCC_CUSTOM_IMAGE_MARGIN1,
-                       rect.y + wxPG_CUSTOM_IMAGE_SPACINGY,
-                       true );
-        imageWidth = bmp.GetWidth();
-    }
-
-    return imageWidth;
-}
-
-// -----------------------------------------------------------------------
-// wxPGDefaultRenderer
-// -----------------------------------------------------------------------
-
-void wxPGDefaultRenderer::Render( wxDC& dc, const wxRect& rect,
-                                  const wxPropertyGrid* propertyGrid, wxPGProperty* property,
-                                  int column, int item, int flags ) const
-{
-    bool isUnspecified = property->IsValueUnspecified();
-
-    if ( column == 1 && item == -1 )
-    {
-        int cmnVal = property->GetCommonValue();
-        if ( cmnVal >= 0 )
-        {
-            // Common Value
-            if ( !isUnspecified )
-                DrawText( dc, rect, 0, propertyGrid->GetCommonValueLabel(cmnVal) );
-            return;
-        }
-    }
-
-    const wxPGEditor* editor = NULL;
-    const wxPGCell* cell = NULL;
-
-    wxString text;
-    int imageWidth = 0;
-    int preDrawFlags = flags;
-
-    property->GetDisplayInfo(column, item, flags, &text, &cell);
-
-    imageWidth = PreDrawCell( dc, rect, *cell, preDrawFlags );
-
-    if ( column == 1 )
-    {
-        if ( !isUnspecified )
-        {
-            editor = property->GetColumnEditor(column);
-
-            // Regular property value
-
-            wxSize imageSize = propertyGrid->GetImageSize(property, item);
-
-            wxPGPaintData paintdata;
-            paintdata.m_parent = propertyGrid;
-            paintdata.m_choiceItem = item;
-
-            if ( imageSize.x > 0 )
-            {
-                wxRect imageRect(rect.x + wxPG_CONTROL_MARGIN + wxCC_CUSTOM_IMAGE_MARGIN1,
-                                 rect.y+wxPG_CUSTOM_IMAGE_SPACINGY,
-                                 wxPG_CUSTOM_IMAGE_WIDTH,
-                                 rect.height-(wxPG_CUSTOM_IMAGE_SPACINGY*2));
-
-                dc.SetPen( wxPen(propertyGrid->GetCellTextColour(), 1, wxSOLID) );
-
-                paintdata.m_drawnWidth = imageSize.x;
-                paintdata.m_drawnHeight = imageSize.y;
-
-                property->OnCustomPaint( dc, imageRect, paintdata );
-
-                imageWidth = paintdata.m_drawnWidth;
-            }
-
-            text = property->GetValueAsString();
-
-            // Add units string?
-            if ( propertyGrid->GetColumnCount() <= 2 )
-            {
-                wxString unitsString = property->GetAttribute(wxPGGlobalVars->m_strUnits, wxEmptyString);
-                if ( unitsString.length() )
-                    text = wxString::Format(wxS("%s %s"), text.c_str(), unitsString.c_str() );
-            }
-        }
-
-        if ( text.length() == 0 )
-        {
-            // Try to show inline help if no text
-            wxVariant vInlineHelp = property->GetAttribute(wxPGGlobalVars->m_strInlineHelp);
-            if ( !vInlineHelp.IsNull() )
-            {
-                text = vInlineHelp.GetString();
-                dc.SetTextForeground(propertyGrid->GetCellDisabledTextColour());
-            }
-        }
-    }
-
-    int imageOffset = property->GetImageOffset(imageWidth);
-
-    DrawEditorValue( dc, rect, imageOffset, text, property, editor );
-
-    // active caption gets nice dotted rectangle
-    if ( property->IsCategory() /*&& column == 0*/ )
-    {
-        if ( flags & Selected )
-        {
-            if ( imageWidth > 0 )
-            {
-                imageOffset -= DEFAULT_IMAGE_OFFSET_INCREMENT;
-                imageWidth += wxCC_CUSTOM_IMAGE_MARGIN2 + 4;
-            }
-
-            DrawCaptionSelectionRect( dc,
-                                      rect.x+wxPG_XBEFORETEXT-wxPG_CAPRECTXMARGIN+imageOffset,
-                                      rect.y-wxPG_CAPRECTYMARGIN+1,
-                                      ((wxPropertyCategory*)property)->GetTextExtent(propertyGrid,
-                                                                                     propertyGrid->GetCaptionFont())
-                                      +(wxPG_CAPRECTXMARGIN*2),
-                                      propertyGrid->GetFontHeight()+(wxPG_CAPRECTYMARGIN*2) );
-        }
-    }
-}
-
-wxSize wxPGDefaultRenderer::GetImageSize( const wxPGProperty* property,
-                                          int column,
-                                          int item ) const
-{
-    if ( property && column == 1 )
-    {
-        if ( item == -1 )
-        {
-            wxBitmap* bmp = property->GetValueImage();
-
-            if ( bmp && bmp->Ok() )
-                return wxSize(bmp->GetWidth(),bmp->GetHeight());
-        }
-    }
-    return wxSize(0,0);
-}
-
-// -----------------------------------------------------------------------
-// wxPGCellData
-// -----------------------------------------------------------------------
-
-wxPGCellData::wxPGCellData()
-    : wxObjectRefData()
-{
-    m_hasValidText = false;
-}
-
-// -----------------------------------------------------------------------
-// wxPGCell
-// -----------------------------------------------------------------------
-
-wxPGCell::wxPGCell()
-    : wxObject()
-{
-}
-
-wxPGCell::wxPGCell( const wxString& text,
-                    const wxBitmap& bitmap,
-                    const wxColour& fgCol,
-                    const wxColour& bgCol )
-    : wxObject()
-{
-    wxPGCellData* data = new wxPGCellData();
-    m_refData = data;
-    data->m_text = text;
-    data->m_bitmap = bitmap;
-    data->m_fgCol = fgCol;
-    data->m_bgCol = bgCol;
-    data->m_hasValidText = true;
-}
-
-wxObjectRefData *wxPGCell::CloneRefData( const wxObjectRefData *data ) const
-{
-    wxPGCellData* c = new wxPGCellData();
-    const wxPGCellData* o = (const wxPGCellData*) data;
-    c->m_text = o->m_text;
-    c->m_bitmap = o->m_bitmap;
-    c->m_fgCol = o->m_fgCol;
-    c->m_bgCol = o->m_bgCol;
-    c->m_hasValidText = o->m_hasValidText;
-    return c;
-}
-
-void wxPGCell::SetText( const wxString& text )
-{
-    AllocExclusive();
-
-    GetData()->SetText(text);
-}
-
-void wxPGCell::SetBitmap( const wxBitmap& bitmap )
-{
-    AllocExclusive();
-
-    GetData()->SetBitmap(bitmap);
-}
-
-void wxPGCell::SetFgCol( const wxColour& col )
-{
-    AllocExclusive();
-
-    GetData()->SetFgCol(col);
-}
-
-void wxPGCell::SetBgCol( const wxColour& col )
-{
-    AllocExclusive();
-
-    GetData()->SetBgCol(col);
-}
-
-void wxPGCell::MergeFrom( const wxPGCell& srcCell )
-{
-    AllocExclusive();
-
-    wxPGCellData* data = GetData();
-
-    if ( srcCell.HasText() )
-        data->SetText(srcCell.GetText());
-
-    if ( srcCell.GetFgCol().IsOk() )
-        data->SetFgCol(srcCell.GetFgCol());
-
-    if ( srcCell.GetBgCol().IsOk() )
-        data->SetBgCol(srcCell.GetBgCol());
-
-    if ( srcCell.GetBitmap().IsOk() )
-        data->SetBitmap(srcCell.GetBitmap());
-}
-
-// -----------------------------------------------------------------------
-// wxPGProperty
-// -----------------------------------------------------------------------
-
-IMPLEMENT_ABSTRACT_CLASS(wxPGProperty, wxObject)
-
-wxString* wxPGProperty::sm_wxPG_LABEL = NULL;
-
-void wxPGProperty::Init()
-{
-    m_commonValue = -1;
-    m_arrIndex = 0xFFFF;
-    m_parent = NULL;
-
-    m_parentState = NULL;
-
-    m_clientData = NULL;
-    m_clientObject = NULL;
-
-    m_customEditor = NULL;
-#if wxUSE_VALIDATORS
-    m_validator = NULL;
-#endif
-    m_valueBitmap = NULL;
-
-    m_maxLen = 0; // infinite maximum length
-
-    m_flags = wxPG_PROP_PROPERTY;
-
-    m_depth = 1;
-
-    SetExpanded(true);
-}
-
-
-void wxPGProperty::Init( const wxString& label, const wxString& name )
-{
-    // We really need to check if &label and &name are NULL pointers
-    // (this can if we are called before property grid has been initalized)
-
-    if ( (&label) != NULL && label != wxPG_LABEL )
-        m_label = label;
-
-    if ( (&name) != NULL && name != wxPG_LABEL )
-        DoSetName( name );
-    else
-        DoSetName( m_label );
-
-    Init();
-}
-
-void wxPGProperty::InitAfterAdded( wxPropertyGridPageState* pageState,
-                                   wxPropertyGrid* propgrid )
-{
-    //
-    // Called after property has been added to grid or page
-    // (so propgrid can be NULL, too).
-
-    wxPGProperty* parent = m_parent;
-    bool parentIsRoot = parent->IsKindOf(CLASSINFO(wxPGRootProperty));
-
-    m_parentState = pageState;
-
-#if wxPG_COMPATIBILITY_1_4
-    // Make sure deprecated virtual functions are not implemented
-    wxString s = GetValueAsString( 0xFFFF );
-    wxASSERT_MSG( s == g_invalidStringContent,
-                  "Implement ValueToString() instead of GetValueAsString()" );
-#endif
-
-    if ( !parentIsRoot && !parent->IsCategory() )
-    {
-        m_cells = parent->m_cells;
-    }
-
-    // If in hideable adding mode, or if assigned parent is hideable, then
-    // make this one hideable.
-    if (
-         ( !parentIsRoot && parent->HasFlag(wxPG_PROP_HIDDEN) ) ||
-         ( propgrid && (propgrid->HasInternalFlag(wxPG_FL_ADDING_HIDEABLES)) )
-       )
-        SetFlag( wxPG_PROP_HIDDEN );
-
-    // Set custom image flag.
-    int custImgHeight = OnMeasureImage().y;
-    if ( custImgHeight < 0 )
-    {
-        SetFlag(wxPG_PROP_CUSTOMIMAGE);
-    }
-
-    if ( propgrid && (propgrid->HasFlag(wxPG_LIMITED_EDITING)) )
-        SetFlag(wxPG_PROP_NOEDITOR);
-
-    // Make sure parent has some parental flags
-    if ( !parent->HasFlag(wxPG_PROP_PARENTAL_FLAGS) )
-        parent->SetParentalType(wxPG_PROP_MISC_PARENT);
-
-    if ( !IsCategory() )
-    {
-        // This is not a category.
-
-        // Depth.
-        //
-        unsigned char depth = 1;
-        if ( !parentIsRoot )
-        {
-            depth = parent->m_depth;
-            if ( !parent->IsCategory() )
-                depth++;
-        }
-        m_depth = depth;
-        unsigned char greyDepth = depth;
-
-        if ( !parentIsRoot )
-        {
-            wxPropertyCategory* pc;
-
-            if ( parent->IsCategory() )
-                pc = (wxPropertyCategory* ) parent;
-            else
-                // This conditional compile is necessary to
-                // bypass some compiler bug.
-                pc = pageState->GetPropertyCategory(parent);
-
-            if ( pc )
-                greyDepth = pc->GetDepth();
-            else
-                greyDepth = parent->m_depthBgCol;
-        }
-
-        m_depthBgCol = greyDepth;
-    }
-    else
-    {
-        // This is a category.
-
-        // depth
-        unsigned char depth = 1;
-        if ( !parentIsRoot )
-        {
-            depth = parent->m_depth + 1;
-        }
-        m_depth = depth;
-        m_depthBgCol = depth;
-    }
-
-    //
-    // Has initial children
-    if ( GetChildCount() )
-    {
-        // Check parental flags
-        wxASSERT_MSG( ((m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
-                            wxPG_PROP_AGGREGATE) ||
-                      ((m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
-                            wxPG_PROP_MISC_PARENT),
-                      "wxPGProperty parental flags set incorrectly at "
-                      "this time" );
-
-        if ( HasFlag(wxPG_PROP_AGGREGATE) )
-        {
-            // Properties with private children are not expanded by default.
-            SetExpanded(false);
-        }
-        else if ( propgrid && propgrid->HasFlag(wxPG_HIDE_MARGIN) )
-        {
-            // ...unless it cannot be expanded by user and therefore must
-            // remain visible at all times
-            SetExpanded(true);
-        }
-
-        //
-        // Prepare children recursively
-        for ( unsigned int i=0; i<GetChildCount(); i++ )
-        {
-            wxPGProperty* child = Item(i);
-            child->InitAfterAdded(pageState, pageState->GetGrid());
-        }
-
-        if ( propgrid && (propgrid->GetExtraStyle() & wxPG_EX_AUTO_UNSPECIFIED_VALUES) )
-            SetFlagRecursively(wxPG_PROP_AUTO_UNSPECIFIED, true);
-    }
-}
-
-wxPGProperty::wxPGProperty()
-    : wxObject()
-{
-    Init();
-}
-
-
-wxPGProperty::wxPGProperty( const wxString& label, const wxString& name )
-    : wxObject()
-{
-    Init( label, name );
-}
-
-
-wxPGProperty::~wxPGProperty()
-{
-    delete m_clientObject;
-
-    Empty();  // this deletes items
-
-    delete m_valueBitmap;
-#if wxUSE_VALIDATORS
-    delete m_validator;
-#endif
-
-    // This makes it easier for us to detect dangling pointers
-    m_parent = NULL;
-}
-
-
-bool wxPGProperty::IsSomeParent( wxPGProperty* candidate ) const
-{
-    wxPGProperty* parent = m_parent;
-    do
-    {
-        if ( parent == candidate )
-            return true;
-        parent = parent->m_parent;
-    } while ( parent );
-    return false;
-}
-
-
-wxString wxPGProperty::GetName() const
-{
-    wxPGProperty* parent = GetParent();
-
-    if ( !m_name.length() || !parent || parent->IsCategory() || parent->IsRoot() )
-        return m_name;
-
-    return m_parent->GetName() + wxS(".") + m_name;
-}
-
-wxPropertyGrid* wxPGProperty::GetGrid() const
-{
-    if ( !m_parentState )
-        return NULL;
-    return m_parentState->GetGrid();
-}
-
-int wxPGProperty::Index( const wxPGProperty* p ) const
-{
-    for ( unsigned int i = 0; i<m_children.size(); i++ )
-    {
-        if ( p == m_children[i] )
-            return i;
-    }
-    return wxNOT_FOUND;
-}
-
-bool wxPGProperty::ValidateValue( wxVariant& WXUNUSED(value), wxPGValidationInfo& WXUNUSED(validationInfo) ) const
-{
-    return true;
-}
-
-void wxPGProperty::OnSetValue()
-{
-}
-
-void wxPGProperty::RefreshChildren ()
-{
-}
-
-void wxPGProperty::OnValidationFailure( wxVariant& WXUNUSED(pendingValue) )
-{
-}
-
-void wxPGProperty::GetDisplayInfo( unsigned int column,
-                                   int choiceIndex,
-                                   int flags,
-                                   wxString* pString,
-                                   const wxPGCell** pCell )
-{
-    const wxPGCell* cell = NULL;
-
-    if ( !(flags & wxPGCellRenderer::ChoicePopup) )
-    {
-        // Not painting listi of choice popups, so get text from property
-        cell = &GetCell(column);
-        if ( cell->HasText() )
-        {
-            *pString = cell->GetText();
-        }
-        else
-        {
-            if ( column == 0 )
-                *pString = GetLabel();
-            else if ( column == 1 )
-                *pString = GetDisplayedString();
-            else if ( column == 2 )
-                *pString = GetAttribute(wxPGGlobalVars->m_strUnits, wxEmptyString);
-        }
-    }
-    else
-    {
-        wxASSERT( column == 1 );
-
-        if ( choiceIndex != wxNOT_FOUND )
-        {
-            const wxPGChoiceEntry& entry = m_choices[choiceIndex];
-            if ( entry.GetBitmap().IsOk() ||
-                 entry.GetFgCol().IsOk() ||
-                 entry.GetBgCol().IsOk() )
-                cell = &entry;
-            *pString = m_choices.GetLabel(choiceIndex);
-        }
-    }
-
-    if ( !cell )
-        cell = &GetCell(column);
-
-    wxASSERT_MSG( cell->GetData(),
-                  wxString::Format("Invalid cell for property %s",
-                                   GetName().c_str()) );
-
-    *pCell = cell;
-}
-
-/*
-wxString wxPGProperty::GetColumnText( unsigned int col, int choiceIndex ) const
-{
-    
-    if ( col != 1 || choiceIndex == wxNOT_FOUND )
-    {
-        const wxPGCell& cell = GetCell(col);
-        if ( cell->HasText() )
-        {
-            return cell->GetText();
-        }
-        else
-        {
-            if ( col == 0 )
-                return GetLabel();
-            else if ( col == 1 )
-                return GetDisplayedString();
-            else if ( col == 2 )
-                return GetAttribute(wxPGGlobalVars->m_strUnits, wxEmptyString);
-        }
-    }
-    else
-    {
-        // Use choice
-        return m_choices.GetLabel(choiceIndex);
-    }
-
-    return wxEmptyString;
-}
-*/
-
-void wxPGProperty::DoGenerateComposedValue( wxString& text,
-                                            int argFlags,
-                                            const wxVariantList* valueOverrides,
-                                            wxPGHashMapS2S* childResults ) const
-{
-    int i;
-    int iMax = m_children.size();
-
-    text.clear();
-    if ( iMax == 0 )
-        return;
-
-    if ( iMax > PWC_CHILD_SUMMARY_LIMIT &&
-         !(argFlags & wxPG_FULL_VALUE) )
-        iMax = PWC_CHILD_SUMMARY_LIMIT;
-
-    int iMaxMinusOne = iMax-1;
-
-    if ( !IsTextEditable() )
-        argFlags |= wxPG_UNEDITABLE_COMPOSITE_FRAGMENT;
-
-    wxPGProperty* curChild = m_children[0];
-
-    bool overridesLeft = false;
-    wxVariant overrideValue;
-    wxVariantList::const_iterator node;
-
-    if ( valueOverrides )
-    {
-        node = valueOverrides->begin();
-        if ( node != valueOverrides->end() )
-        {
-            overrideValue = *node;
-            overridesLeft = true;
-        }
-    }
-
-    for ( i = 0; i < iMax; i++ )
-    {
-        wxVariant childValue;
-
-        wxString childLabel = curChild->GetLabel();
-
-        // Check for value override
-        if ( overridesLeft && overrideValue.GetName() == childLabel )
-        {
-            if ( !overrideValue.IsNull() )
-                childValue = overrideValue;
-            else
-                childValue = curChild->GetValue();
-            ++node;
-            if ( node != valueOverrides->end() )
-                overrideValue = *node;
-            else
-                overridesLeft = false;
-        }
-        else
-        {
-            childValue = curChild->GetValue();
-        }
-
-        wxString s;
-        if ( !childValue.IsNull() )
-        {
-            if ( overridesLeft &&
-                 curChild->HasFlag(wxPG_PROP_COMPOSED_VALUE) &&
-                 childValue.GetType() == wxPG_VARIANT_TYPE_LIST )
-            {
-                wxVariantList& childList = childValue.GetList();
-                DoGenerateComposedValue(s, argFlags|wxPG_COMPOSITE_FRAGMENT,
-                                        &childList, childResults);
-            }
-            else
-            {
-                s = curChild->ValueToString(childValue,
-                                            argFlags|wxPG_COMPOSITE_FRAGMENT);
-            }
-        }
- 
-        if ( childResults && curChild->GetChildCount() )
-            (*childResults)[curChild->GetName()] = s;
-
-        bool skip = false;
-        if ( (argFlags & wxPG_UNEDITABLE_COMPOSITE_FRAGMENT) && !s.length() )
-            skip = true;
-
-        if ( !curChild->GetChildCount() || skip )
-            text += s;
-        else
-            text += wxS("[") + s + wxS("]");
-
-        if ( i < iMaxMinusOne )
-        {
-            if ( text.length() > PWC_CHILD_SUMMARY_CHAR_LIMIT &&
-                 !(argFlags & wxPG_EDITABLE_VALUE) &&
-                 !(argFlags & wxPG_FULL_VALUE) )
-                break;
-
-            if ( !skip )
-            {
-                if ( !curChild->GetChildCount() )
-                    text += wxS("; ");
-                else
-                    text += wxS(" ");
-            }
-
-            curChild = m_children[i+1];
-        }
-    }
-
-    if ( (unsigned int)i < m_children.size() )
-    {
-        if ( !text.EndsWith(wxS("; ")) )
-            text += wxS("; ...");
-        else
-            text += wxS("...");
-    }
-}
-
-wxString wxPGProperty::ValueToString( wxVariant& WXUNUSED(value),
-                                      int argFlags ) const
-{
-    wxCHECK_MSG( GetChildCount() > 0,
-                 wxString(),
-                 "If user property does not have any children, it must "
-                 "override GetValueAsString" );
-
-    // FIXME: Currently code below only works if value is actually m_value
-    wxASSERT_MSG( argFlags & wxPG_VALUE_IS_CURRENT,
-                  "Sorry, currently default wxPGProperty::ValueToString() "
-                  "implementation only works if value is m_value." );
-
-    wxString text;
-    DoGenerateComposedValue(text, argFlags);
-    return text;
-}
-
-wxString wxPGProperty::GetValueAsString( int argFlags ) const
-{
-#if wxPG_COMPATIBILITY_1_4
-    // This is backwards compatibility test
-    // That is, to make sure this function is not overridden
-    // (instead, ValueToString() should be).
-    if ( argFlags == 0xFFFF )
-    {
-        // Do not override! (for backwards compliancy)
-        return g_invalidStringContent;
-    }
-#endif
-
-    if ( IsValueUnspecified() )
-        return wxEmptyString;
-
-    if ( m_commonValue == -1 )
-    {
-        wxVariant value(GetValue());
-        return ValueToString(value, argFlags|wxPG_VALUE_IS_CURRENT);
-    }
-
-    //
-    // Return common value's string representation
-    wxPropertyGrid* pg = GetGrid();
-    const wxPGCommonValue* cv = pg->GetCommonValue(m_commonValue);
-
-    if ( argFlags & wxPG_FULL_VALUE )
-    {
-        return cv->GetLabel();
-    }
-    else if ( argFlags & wxPG_EDITABLE_VALUE )
-    {
-        return cv->GetEditableText();
-    }
-    else
-    {
-        return cv->GetLabel();
-    }
-}
-
-wxString wxPGProperty::GetValueString( int argFlags ) const
-{
-    return GetValueAsString(argFlags);
-}
-
-bool wxPGProperty::IntToValue( wxVariant& variant, int number, int WXUNUSED(argFlags) ) const
-{
-    variant = (long)number;
-    return true;
-}
-
-// Convert semicolon delimited tokens into child values.
-bool wxPGProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
-{
-    if ( !GetChildCount() )
-        return false;
-
-    unsigned int curChild = 0;
-
-    unsigned int iMax = m_children.size();
-
-    if ( iMax > PWC_CHILD_SUMMARY_LIMIT &&
-         !(argFlags & wxPG_FULL_VALUE) )
-        iMax = PWC_CHILD_SUMMARY_LIMIT;
-
-    bool changed = false;
-
-    wxString token;
-    size_t pos = 0;
-
-    // Its best only to add non-empty group items
-    bool addOnlyIfNotEmpty = false;
-    const wxChar delimeter = wxS(';');
-
-    size_t tokenStart = 0xFFFFFF;
-
-    wxVariantList temp_list;
-    wxVariant list(temp_list);
-
-    int propagatedFlags = argFlags & (wxPG_REPORT_ERROR|wxPG_PROGRAMMATIC_VALUE);
-
-    wxLogTrace("propgrid",
-               wxT(">> %s.StringToValue('%s')"), GetLabel(), text);
-
-    wxString::const_iterator it = text.begin();
-    wxUniChar a;
-
-    if ( it != text.end() )
-        a = *it;
-    else
-        a = 0;
-
-    for ( ;; )
-    {
-        // How many units we iterate string forward at the end of loop?
-        // We need to keep track of this or risk going to negative
-        // with it-- operation.
-        unsigned int strPosIncrement = 1;
-
-        if ( tokenStart != 0xFFFFFF )
-        {
-            // Token is running
-            if ( a == delimeter || a == 0 )
-            {
-                token = text.substr(tokenStart,pos-tokenStart);
-                token.Trim(true);
-                size_t len = token.length();
-
-                if ( !addOnlyIfNotEmpty || len > 0 )
-                {
-                    const wxPGProperty* child = Item(curChild);
-                    wxVariant variant(child->GetValue());
-                    wxString childName = child->GetBaseName();
-
-                    wxLogTrace("propgrid",
-                               wxT("token = '%s', child = %s"),
-                               token, childName);
-
-                    // Add only if editable or setting programmatically
-                    if ( (argFlags & wxPG_PROGRAMMATIC_VALUE) ||
-                         !child->HasFlag(wxPG_PROP_DISABLED|wxPG_PROP_READONLY) )
-                    {
-                        if ( len > 0 )
-                        {
-                            if ( child->StringToValue(variant, token,
-                                 propagatedFlags|wxPG_COMPOSITE_FRAGMENT) )
-                            {
-                                // We really need to set the variant's name
-                                // *after* child->StringToValue() has been
-                                // called, since variant's value may be set by
-                                // assigning another variant into it, which
-                                // then usually causes name to be copied (ie.
-                                // usually cleared) as well. wxBoolProperty
-                                // being case in point with its use of
-                                // wxPGVariant_Bool macro as an optimization.
-                                variant.SetName(childName);
-                                list.Append(variant);
-
-                                changed = true;
-                            }
-                        }
-                        else
-                        {
-                            // Empty, becomes unspecified
-                            variant.MakeNull();
-                            variant.SetName(childName);
-                            list.Append(variant);
-                            changed = true;
-                        }
-                    }
-
-                    curChild++;
-                    if ( curChild >= iMax )
-                        break;
-                }
-
-                tokenStart = 0xFFFFFF;
-            }
-        }
-        else
-        {
-            // Token is not running
-            if ( a != wxS(' ') )
-            {
-
-                addOnlyIfNotEmpty = false;
-
-                // Is this a group of tokens?
-                if ( a == wxS('[') )
-                {
-                    int depth = 1;
-
-                    if ( it != text.end() ) ++it;
-                    pos++;
-                    size_t startPos = pos;
-
-                    // Group item - find end
-                    while ( it != text.end() && depth > 0 )
-                    {
-                        a = *it;
-                        ++it;
-                        pos++;
-
-                        if ( a == wxS(']') )
-                            depth--;
-                        else if ( a == wxS('[') )
-                            depth++;
-                    }
-
-                    token = text.substr(startPos,pos-startPos-1);
-
-                    if ( !token.length() )
-                        break;
-
-                    const wxPGProperty* child = Item(curChild);
-
-                    wxVariant oldChildValue = child->GetValue();
-                    wxVariant variant(oldChildValue);
-
-                    if ( (argFlags & wxPG_PROGRAMMATIC_VALUE) ||
-                         !child->HasFlag(wxPG_PROP_DISABLED|wxPG_PROP_READONLY) )
-                    {
-                        wxString childName = child->GetBaseName();
-
-                        bool stvRes = child->StringToValue( variant, token,
-                                                            propagatedFlags );
-                        if ( stvRes || (variant != oldChildValue) )
-                        {
-                            variant.SetName(childName);
-                            list.Append(variant);
-
-                            changed = true;
-                        }
-                        else
-                        {
-                            // No changes...
-                        }
-                    }
-
-                    curChild++;
-                    if ( curChild >= iMax )
-                        break;
-
-                    addOnlyIfNotEmpty = true;
-
-                    tokenStart = 0xFFFFFF;
-                }
-                else
-                {
-                    tokenStart = pos;
-
-                    if ( a == delimeter )
-                        strPosIncrement -= 1;
-                }
-            }
-        }
-
-        if ( a == 0 )
-            break;
-
-        it += strPosIncrement;
-
-        if ( it != text.end() )
-        {
-            a = *it;
-        }
-        else
-        {
-            a = 0;
-        }
-
-        pos += strPosIncrement;
-    }
-
-    if ( changed )
-        variant = list;
-
-    return changed;
-}
-
-bool wxPGProperty::SetValueFromString( const wxString& text, int argFlags )
-{
-    wxVariant variant(m_value);
-    bool res = StringToValue(variant, text, argFlags);
-    if ( res )
-        SetValue(variant);
-    return res;
-}
-
-bool wxPGProperty::SetValueFromInt( long number, int argFlags )
-{
-    wxVariant variant(m_value);
-    bool res = IntToValue(variant, number, argFlags);
-    if ( res )
-        SetValue(variant);
-    return res;
-}
-
-wxSize wxPGProperty::OnMeasureImage( int WXUNUSED(item) ) const
-{
-    if ( m_valueBitmap )
-        return wxSize(m_valueBitmap->GetWidth(),-1);
-
-    return wxSize(0,0);
-}
-
-int wxPGProperty::GetImageOffset( int imageWidth ) const
-{
-    int imageOffset = 0;
-
-    if ( imageWidth )
-    {
-        // Do not increment offset too much for wide images
-        if ( imageWidth <= (wxPG_CUSTOM_IMAGE_WIDTH+5) )
-            imageOffset = imageWidth + DEFAULT_IMAGE_OFFSET_INCREMENT;
-        else
-            imageOffset = imageWidth + 1;
-    }
-
-    return imageOffset;
-}
-
-wxPGCellRenderer* wxPGProperty::GetCellRenderer( int WXUNUSED(column) ) const
-{
-    return wxPGGlobalVars->m_defaultRenderer;
-}
-
-void wxPGProperty::OnCustomPaint( wxDC& dc,
-                                  const wxRect& rect,
-                                  wxPGPaintData& )
-{
-    wxBitmap* bmp = m_valueBitmap;
-
-    wxCHECK_RET( bmp && bmp->Ok(), wxT("invalid bitmap") );
-
-    wxCHECK_RET( rect.x >= 0, wxT("unexpected measure call") );
-
-    dc.DrawBitmap(*bmp,rect.x,rect.y);
-}
-
-const wxPGEditor* wxPGProperty::DoGetEditorClass() const
-{
-    return wxPGEditor_TextCtrl;
-}
-
-// Default extra property event handling - that is, none at all.
-bool wxPGProperty::OnEvent( wxPropertyGrid*, wxWindow*, wxEvent& )
-{
-    return false;
-}
-
-
-void wxPGProperty::SetValue( wxVariant value, wxVariant* pList, int flags )
-{
-    // If auto unspecified values are not wanted (via window or property style),
-    // then get default value instead of wxNullVariant.
-    if ( value.IsNull() && (flags & wxPG_SETVAL_BY_USER) &&
-         !UsesAutoUnspecified() )
-    {
-        value = GetDefaultValue();
-    }
-
-    if ( !value.IsNull() )
-    {
-        wxVariant tempListVariant;
-
-        SetCommonValue(-1);
-        // List variants are reserved a special purpose
-        // as intermediate containers for child values
-        // of properties with children.
-        if ( value.GetType() == wxPG_VARIANT_TYPE_LIST )
-        {
-            //
-            // However, situation is different for composed string properties
-            if ( HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-            {
-                tempListVariant = value;
-                pList = &tempListVariant;
-            }
-
-            wxVariant newValue;
-            AdaptListToValue(value, &newValue);
-            value = newValue;
-            //wxLogDebug(wxT(">> %s.SetValue() adapted list value to type '%s'"),GetName().c_str(),value.GetType().c_str());
-        }
-
-        if ( HasFlag( wxPG_PROP_AGGREGATE) )
-            flags |= wxPG_SETVAL_AGGREGATED;
-
-        if ( pList && !pList->IsNull() )
-        {
-            wxASSERT( pList->GetType() == wxPG_VARIANT_TYPE_LIST );
-            wxASSERT( GetChildCount() );
-            wxASSERT( !IsCategory() );
-
-            wxVariantList& list = pList->GetList();
-            wxVariantList::iterator node;
-            unsigned int i = 0;
-
-            //wxLogDebug(wxT(">> %s.SetValue() pList parsing"),GetName().c_str());
-
-            // Children in list can be in any order, but we will give hint to
-            // GetPropertyByNameWH(). This optimizes for full list parsing.
-            for ( node = list.begin(); node != list.end(); ++node )
-            {
-                wxVariant& childValue = *((wxVariant*)*node);
-                wxPGProperty* child = GetPropertyByNameWH(childValue.GetName(), i);
-                if ( child )
-                {
-                    //wxLogDebug(wxT("%i: child = %s, childValue.GetType()=%s"),i,child->GetBaseName().c_str(),childValue.GetType().c_str());
-                    if ( childValue.GetType() == wxPG_VARIANT_TYPE_LIST )
-                    {
-                        if ( child->HasFlag(wxPG_PROP_AGGREGATE) && !(flags & wxPG_SETVAL_AGGREGATED) )
-                        {
-                            wxVariant listRefCopy = childValue;
-                            child->SetValue(childValue, &listRefCopy, flags|wxPG_SETVAL_FROM_PARENT);
-                        }
-                        else
-                        {
-                            wxVariant oldVal = child->GetValue();
-                            child->SetValue(oldVal, &childValue, flags|wxPG_SETVAL_FROM_PARENT);
-                        }
-                    }
-                    else if ( child->GetValue() != childValue )
-                    {
-                        // For aggregate properties, we will trust RefreshChildren()
-                        // to update child values.
-                        if ( !HasFlag(wxPG_PROP_AGGREGATE) )
-                            child->SetValue(childValue, NULL, flags|wxPG_SETVAL_FROM_PARENT);
-                        if ( flags & wxPG_SETVAL_BY_USER )
-                            child->SetFlag(wxPG_PROP_MODIFIED);
-                    }
-                }
-                i++;
-            }
-        }
-
-        if ( !value.IsNull() )
-        {
-            m_value = value;
-            OnSetValue();
-        }
-
-        if ( flags & wxPG_SETVAL_BY_USER )
-            SetFlag(wxPG_PROP_MODIFIED);
-
-        if ( HasFlag(wxPG_PROP_AGGREGATE) )
-            RefreshChildren();
-    }
-    else
-    {
-        if ( m_commonValue != -1 )
-        {
-            wxPropertyGrid* pg = GetGrid();
-            if ( !pg || m_commonValue != pg->GetUnspecifiedCommonValue() )
-                SetCommonValue(-1);
-        }
-
-        m_value = value;
-
-        // Set children to unspecified, but only if aggregate or
-        // value is <composed>
-        if ( AreChildrenComponents() )
-        {
-            unsigned int i;
-            for ( i=0; i<GetChildCount(); i++ )
-                Item(i)->SetValue(value, NULL, flags|wxPG_SETVAL_FROM_PARENT);
-        }
-    }
-
-    if ( !(flags & wxPG_SETVAL_FROM_PARENT) )
-        UpdateParentValues();
-
-    //
-    // Update editor control
-    //
-
-    // We need to check for these, otherwise GetGrid() may fail.
-    if ( flags & wxPG_SETVAL_REFRESH_EDITOR )
-    {
-        RefreshEditor();
-        wxPropertyGrid* pg = GetGridIfDisplayed();
-        if ( pg )
-            pg->DrawItemAndValueRelated(this);
-    }
-}
-
-
-void wxPGProperty::SetValueInEvent( wxVariant value ) const
-{
-    GetGrid()->ValueChangeInEvent(value);
-}
-
-void wxPGProperty::SetFlagRecursively( FlagType flag, bool set )
-{
-    if ( set )
-        SetFlag(flag);
-    else
-        ClearFlag(flag);
-
-    unsigned int i;
-    for ( i = 0; i < GetChildCount(); i++ )
-        Item(i)->SetFlagRecursively(flag, set);
-}
-
-void wxPGProperty::RefreshEditor()
-{
-    if ( !m_parent )
-        return;
-
-    wxPropertyGrid* pg = GetGrid();
-    if ( pg && pg->GetSelectedProperty() == this )
-        pg->RefreshEditor();
-}
-
-wxVariant wxPGProperty::GetDefaultValue() const
-{
-    wxVariant defVal = GetAttribute(wxS("DefaultValue"));
-    if ( !defVal.IsNull() )
-        return defVal;
-
-    wxVariant value = GetValue();
-
-    if ( !value.IsNull() )
-    {
-        wxString valueType(value.GetType());
-
-        if ( valueType == wxPG_VARIANT_TYPE_LONG )
-            return wxPGVariant_Zero;
-        if ( valueType == wxPG_VARIANT_TYPE_STRING )
-            return wxPGVariant_EmptyString;
-        if ( valueType == wxPG_VARIANT_TYPE_BOOL )
-            return wxPGVariant_False;
-        if ( valueType == wxPG_VARIANT_TYPE_DOUBLE )
-            return wxVariant(0.0);
-        if ( valueType == wxPG_VARIANT_TYPE_ARRSTRING )
-            return wxVariant(wxArrayString());
-        if ( valueType == wxS("wxLongLong") )
-            return WXVARIANT(wxLongLong(0));
-        if ( valueType == wxS("wxULongLong") )
-            return WXVARIANT(wxULongLong(0));
-        if ( valueType == wxS("wxColour") )
-            return WXVARIANT(*wxBLACK);
-#if wxUSE_DATETIME
-        if ( valueType == wxPG_VARIANT_TYPE_DATETIME )
-            return wxVariant(wxDateTime::Now());
-#endif
-        if ( valueType == wxS("wxFont") )
-            return WXVARIANT(*wxNORMAL_FONT);
-        if ( valueType == wxS("wxPoint") )
-            return WXVARIANT(wxPoint(0, 0));
-        if ( valueType == wxS("wxSize") )
-            return WXVARIANT(wxSize(0, 0));
-    }
-
-    return wxVariant();
-}
-
-void wxPGProperty::EnsureCells( unsigned int column )
-{
-    if ( column >= m_cells.size() )
-    {
-        // Fill empty slots with default cells
-        wxPropertyGrid* pg = GetGrid();
-        wxPGCell defaultCell;
-
-        if ( !HasFlag(wxPG_PROP_CATEGORY) )
-            defaultCell = pg->GetPropertyDefaultCell();
-        else
-            defaultCell = pg->GetCategoryDefaultCell();
-
-        // TODO: Replace with resize() call
-        unsigned int cellCountMax = column+1;
-
-        for ( unsigned int i=m_cells.size(); i<cellCountMax; i++ )
-            m_cells.push_back(defaultCell);
-    }
-}
-
-void wxPGProperty::SetCell( int column,
-                            const wxPGCell& cell )
-{
-    EnsureCells(column);
-
-    m_cells[column] = cell;
-}
-
-void wxPGProperty::AdaptiveSetCell( unsigned int firstCol,
-                                    unsigned int lastCol,
-                                    const wxPGCell& cell,
-                                    const wxPGCell& srcData,
-                                    wxPGCellData* unmodCellData,
-                                    FlagType ignoreWithFlags,
-                                    bool recursively )
-{
-    //
-    // Sets cell in memory optimizing fashion. That is, if
-    // current cell data matches unmodCellData, we will
-    // simply get reference to data from cell. Otherwise,
-    // cell information from srcData is merged into current.
-    //
-
-    if ( !(m_flags & ignoreWithFlags) && !IsRoot() )
-    {
-        EnsureCells(lastCol);
-
-        for ( unsigned int col=firstCol; col<=lastCol; col++ )
-        {
-            if ( m_cells[col].GetData() == unmodCellData )
-            {
-                // Data matches... use cell directly
-                m_cells[col] = cell;
-            }
-            else
-            {
-                // Data did not match... merge valid information
-                m_cells[col].MergeFrom(srcData);
-            }
-        }
-    }
-
-    if ( recursively )
-    {
-        for ( unsigned int i=0; i<GetChildCount(); i++ )
-            Item(i)->AdaptiveSetCell( firstCol,
-                                      lastCol,
-                                      cell,
-                                      srcData,
-                                      unmodCellData,
-                                      ignoreWithFlags,
-                                      recursively );
-    }
-}
-
-const wxPGCell& wxPGProperty::GetCell( unsigned int column ) const
-{
-    if ( m_cells.size() > column )
-        return m_cells[column];
-
-    wxPropertyGrid* pg = GetGrid();
-
-    if ( IsCategory() )
-        return pg->GetCategoryDefaultCell();
-
-    return pg->GetPropertyDefaultCell();
-}
-
-wxPGCell& wxPGProperty::GetCell( unsigned int column )
-{
-    EnsureCells(column);
-    return m_cells[column];
-}
-
-void wxPGProperty::SetBackgroundColour( const wxColour& colour,
-                                        bool recursively )
-{
-    wxPGProperty* firstProp = this;
-
-    //
-    // If category is tried to set recursively, skip it and only
-    // affect the children.
-    if ( recursively )
-    {
-        while ( firstProp->IsCategory() )
-        {
-            if ( !firstProp->GetChildCount() )
-                return;
-            firstProp = firstProp->Item(0);
-        }
-    }
-
-    wxPGCell& firstCell = firstProp->GetCell(0);
-    wxPGCellData* firstCellData = firstCell.GetData();
-
-    wxPGCell newCell(firstCell);
-    newCell.SetBgCol(colour);
-    wxPGCell srcCell;
-    srcCell.SetBgCol(colour);
-
-    AdaptiveSetCell( 0,
-                     GetParentState()->GetColumnCount()-1,
-                     newCell,
-                     srcCell,
-                     firstCellData,
-                     recursively ? wxPG_PROP_CATEGORY : 0,
-                     recursively );
-}
-
-void wxPGProperty::SetTextColour( const wxColour& colour,
-                                  bool recursively )
-{
-    wxPGProperty* firstProp = this;
-
-    //
-    // If category is tried to set recursively, skip it and only
-    // affect the children.
-    if ( recursively )
-    {
-        while ( firstProp->IsCategory() )
-        {
-            if ( !firstProp->GetChildCount() )
-                return;
-            firstProp = firstProp->Item(0);
-        }
-    }
-
-    wxPGCell& firstCell = firstProp->GetCell(0);
-    wxPGCellData* firstCellData = firstCell.GetData();
-
-    wxPGCell newCell(firstCell);
-    newCell.SetFgCol(colour);
-    wxPGCell srcCell;
-    srcCell.SetFgCol(colour);
-
-    AdaptiveSetCell( 0,
-                     GetParentState()->GetColumnCount()-1,
-                     newCell,
-                     srcCell,
-                     firstCellData,
-                     recursively ? wxPG_PROP_CATEGORY : 0,
-                     recursively );
-}
-
-wxPGEditorDialogAdapter* wxPGProperty::GetEditorDialog() const
-{
-    return NULL;
-}
-
-bool wxPGProperty::DoSetAttribute( const wxString& WXUNUSED(name), wxVariant& WXUNUSED(value) )
-{
-    return false;
-}
-
-void wxPGProperty::SetAttribute( const wxString& name, wxVariant value )
-{
-    if ( DoSetAttribute( name, value ) )
-    {
-        // Support working without grid, when possible
-        if ( wxPGGlobalVars->HasExtraStyle( wxPG_EX_WRITEONLY_BUILTIN_ATTRIBUTES ) )
-            return;
-    }
-
-    m_attributes.Set( name, value );
-}
-
-void wxPGProperty::SetAttributes( const wxPGAttributeStorage& attributes )
-{
-    wxPGAttributeStorage::const_iterator it = attributes.StartIteration();
-    wxVariant variant;
-
-    while ( attributes.GetNext(it, variant) )
-        SetAttribute( variant.GetName(), variant );
-}
-
-wxVariant wxPGProperty::DoGetAttribute( const wxString& WXUNUSED(name) ) const
-{
-    return wxVariant();
-}
-
-
-wxVariant wxPGProperty::GetAttribute( const wxString& name ) const
-{
-    return m_attributes.FindValue(name);
-}
-
-wxString wxPGProperty::GetAttribute( const wxString& name, const wxString& defVal ) const
-{
-    wxVariant variant = m_attributes.FindValue(name);
-
-    if ( !variant.IsNull() )
-        return variant.GetString();
-
-    return defVal;
-}
-
-long wxPGProperty::GetAttributeAsLong( const wxString& name, long defVal ) const
-{
-    wxVariant variant = m_attributes.FindValue(name);
-
-    return wxPGVariantToInt(variant, defVal);
-}
-
-double wxPGProperty::GetAttributeAsDouble( const wxString& name, double defVal ) const
-{
-    double retVal;
-    wxVariant variant = m_attributes.FindValue(name);
-
-    if ( wxPGVariantToDouble(variant, &retVal) )
-        return retVal;
-
-    return defVal;
-}
-
-wxVariant wxPGProperty::GetAttributesAsList() const
-{
-    wxVariantList tempList;
-    wxVariant v( tempList, wxString::Format(wxS("@%s@attr"),m_name.c_str()) );
-
-    wxPGAttributeStorage::const_iterator it = m_attributes.StartIteration();
-    wxVariant variant;
-
-    while ( m_attributes.GetNext(it, variant) )
-        v.Append(variant);
-
-    return v;
-}
-
-// Slots of utility flags are NULL
-const unsigned int gs_propFlagToStringSize = 14;
-
-static const wxChar* gs_propFlagToString[gs_propFlagToStringSize] = {
-    NULL,
-    wxT("DISABLED"),
-    wxT("HIDDEN"),
-    NULL,
-    wxT("NOEDITOR"),
-    wxT("COLLAPSED"),
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-wxString wxPGProperty::GetFlagsAsString( FlagType flagsMask ) const
-{
-    wxString s;
-    int relevantFlags = m_flags & flagsMask & wxPG_STRING_STORED_FLAGS;
-    FlagType a = 1;
-
-    unsigned int i = 0;
-    for ( i=0; i<gs_propFlagToStringSize; i++ )
-    {
-        if ( relevantFlags & a )
-        {
-            const wxChar* fs = gs_propFlagToString[i];
-            wxASSERT(fs);
-            if ( s.length() )
-                s << wxS("|");
-            s << fs;
-        }
-        a = a << 1;
-    }
-
-    return s;
-}
-
-void wxPGProperty::SetFlagsFromString( const wxString& str )
-{
-    FlagType flags = 0;
-
-    WX_PG_TOKENIZER1_BEGIN(str, wxS('|'))
-        unsigned int i;
-        for ( i=0; i<gs_propFlagToStringSize; i++ )
-        {
-            const wxChar* fs = gs_propFlagToString[i];
-            if ( fs && str == fs )
-            {
-                flags |= (1<<i);
-                break;
-            }
-        }
-    WX_PG_TOKENIZER1_END()
-
-    m_flags = (m_flags & ~wxPG_STRING_STORED_FLAGS) | flags;
-}
-
-wxValidator* wxPGProperty::DoGetValidator() const
-{
-    return NULL;
-}
-
-int wxPGProperty::InsertChoice( const wxString& label, int index, int value )
-{
-    wxPropertyGrid* pg = GetGrid();
-    int sel = GetChoiceSelection();
-
-    int newSel = sel;
-
-    if ( index == wxNOT_FOUND )
-        index = m_choices.GetCount();
-
-    if ( index <= sel )
-        newSel++;
-
-    m_choices.Insert(label, index, value);
-
-    if ( sel != newSel )
-        SetChoiceSelection(newSel);
-
-    if ( this == pg->GetSelection() )
-        GetEditorClass()->InsertItem(pg->GetEditorControl(),label,index);
-
-    return index;
-}
-
-
-void wxPGProperty::DeleteChoice( int index )
-{
-    wxPropertyGrid* pg = GetGrid();
-
-    int sel = GetChoiceSelection();
-    int newSel = sel;
-
-    // Adjust current value
-    if ( sel == index )
-    {
-        SetValueToUnspecified();
-        newSel = 0;
-    }
-    else if ( index < sel )
-    {
-        newSel--;
-    }
-
-    m_choices.RemoveAt(index);
-
-    if ( sel != newSel )
-        SetChoiceSelection(newSel);
-
-    if ( this == pg->GetSelection() )
-        GetEditorClass()->DeleteItem(pg->GetEditorControl(), index);
-}
-
-int wxPGProperty::GetChoiceSelection() const
-{
-    wxVariant value = GetValue();
-    wxString valueType = value.GetType();
-    int index = wxNOT_FOUND;
-
-    if ( IsValueUnspecified() || !m_choices.GetCount() )
-        return wxNOT_FOUND;
-
-    if ( valueType == wxPG_VARIANT_TYPE_LONG )
-    {
-        index = value.GetLong();
-    }
-    else if ( valueType == wxPG_VARIANT_TYPE_STRING )
-    {
-        index = m_choices.Index(value.GetString());
-    }
-    else if ( valueType == wxPG_VARIANT_TYPE_BOOL )
-    {
-        index = value.GetBool()? 1 : 0;
-    }
-
-    return index;
-}
-
-void wxPGProperty::SetChoiceSelection( int newValue )
-{
-    // Changes value of a property with choices, but only
-    // works if the value type is long or string.
-    wxString valueType = GetValue().GetType();
-
-    wxCHECK_RET( m_choices.IsOk(), wxT("invalid choiceinfo") );
-
-    if ( valueType == wxPG_VARIANT_TYPE_STRING )
-    {
-        SetValue( m_choices.GetLabel(newValue) );
-    }
-    else  // if ( valueType == wxPG_VARIANT_TYPE_LONG )
-    {
-        SetValue( (long) newValue );
-    }
-}
-
-bool wxPGProperty::SetChoices( wxPGChoices& choices )
-{
-    m_choices.Assign(choices);
-
-    {
-        // This may be needed to trigger some initialization
-        // (but don't do it if property is somewhat uninitialized)
-        wxVariant defVal = GetDefaultValue();
-        if ( defVal.IsNull() )
-            return false;
-
-        SetValue(defVal);
-    }
-
-    return true;
-}
-
-
-const wxPGEditor* wxPGProperty::GetEditorClass() const
-{
-    const wxPGEditor* editor;
-
-    if ( !m_customEditor )
-    {
-        editor = DoGetEditorClass();
-    }
-    else
-        editor = m_customEditor;
-
-    //
-    // Maybe override editor if common value specified
-    if ( GetDisplayedCommonValueCount() )
-    {
-        // TextCtrlAndButton -> ComboBoxAndButton
-        if ( editor->IsKindOf(CLASSINFO(wxPGTextCtrlAndButtonEditor)) )
-            editor = wxPGEditor_ChoiceAndButton;
-
-        // TextCtrl -> ComboBox
-        else if ( editor->IsKindOf(CLASSINFO(wxPGTextCtrlEditor)) )
-            editor = wxPGEditor_ComboBox;
-    }
-
-    return editor;
-}
-
-bool wxPGProperty::HasVisibleChildren() const
-{
-    unsigned int i;
-
-    for ( i=0; i<GetChildCount(); i++ )
-    {
-        wxPGProperty* child = Item(i);
-
-        if ( !child->HasFlag(wxPG_PROP_HIDDEN) )
-            return true;
-    }
-
-    return false;
-}
-
-bool wxPGProperty::RecreateEditor()
-{
-    wxPropertyGrid* pg = GetGrid();
-    wxASSERT(pg);
-
-    wxPGProperty* selected = pg->GetSelection();
-    if ( this == selected )
-    {
-        pg->DoSelectProperty(this, wxPG_SEL_FORCE);
-        return true;
-    }
-    return false;
-}
-
-
-void wxPGProperty::SetValueImage( wxBitmap& bmp )
-{
-    delete m_valueBitmap;
-
-    if ( &bmp && bmp.Ok() )
-    {
-        // Resize the image
-        wxSize maxSz = GetGrid()->GetImageSize();
-        wxSize imSz(bmp.GetWidth(),bmp.GetHeight());
-
-        if ( imSz.y != maxSz.y )
-        {
-            // Create a memory DC
-            wxBitmap* bmpNew = new wxBitmap(maxSz.x,maxSz.y,bmp.GetDepth());
-
-            wxMemoryDC dc;
-            dc.SelectObject(*bmpNew);
-
-            // Scale
-            // FIXME: This is ugly - use image or wait for scaling patch.
-            double scaleY = (double)maxSz.y / (double)imSz.y;
-
-            dc.SetUserScale(scaleY, scaleY);
-
-            dc.DrawBitmap(bmp, 0, 0);
-
-            m_valueBitmap = bmpNew;
-        }
-        else
-        {
-            m_valueBitmap = new wxBitmap(bmp);
-        }
-
-        m_flags |= wxPG_PROP_CUSTOMIMAGE;
-    }
-    else
-    {
-        m_valueBitmap = NULL;
-        m_flags &= ~(wxPG_PROP_CUSTOMIMAGE);
-    }
-}
-
-
-wxPGProperty* wxPGProperty::GetMainParent() const
-{
-    const wxPGProperty* curChild = this;
-    const wxPGProperty* curParent = m_parent;
-
-    while ( curParent && !curParent->IsCategory() )
-    {
-        curChild = curParent;
-        curParent = curParent->m_parent;
-    }
-
-    return (wxPGProperty*) curChild;
-}
-
-
-const wxPGProperty* wxPGProperty::GetLastVisibleSubItem() const
-{
-    //
-    // Returns last visible sub-item, recursively.
-    if ( !IsExpanded() || !GetChildCount() )
-        return this;
-
-    return Last()->GetLastVisibleSubItem();
-}
-
-
-bool wxPGProperty::IsVisible() const
-{
-    const wxPGProperty* parent;
-
-    if ( HasFlag(wxPG_PROP_HIDDEN) )
-        return false;
-
-    for ( parent = GetParent(); parent != NULL; parent = parent->GetParent() )
-    {
-        if ( !parent->IsExpanded() || parent->HasFlag(wxPG_PROP_HIDDEN) )
-            return false;
-    }
-
-    return true;
-}
-
-wxPropertyGrid* wxPGProperty::GetGridIfDisplayed() const
-{
-    wxPropertyGridPageState* state = GetParentState();
-    if ( !state )
-        return NULL;
-    wxPropertyGrid* propGrid = state->GetGrid();
-    if ( state == propGrid->GetState() )
-        return propGrid;
-    return NULL;
-}
-
-
-int wxPGProperty::GetY2( int lh ) const
-{
-    const wxPGProperty* parent;
-    const wxPGProperty* child = this;
-
-    int y = 0;
-
-    for ( parent = GetParent(); parent != NULL; parent = child->GetParent() )
-    {
-        if ( !parent->IsExpanded() )
-            return -1;
-        y += parent->GetChildrenHeight(lh, child->GetIndexInParent());
-        y += lh;
-        child = parent;
-    }
-
-    y -= lh;  // need to reduce one level
-
-    return y;
-}
-
-
-int wxPGProperty::GetY() const
-{
-    return GetY2(GetGrid()->GetRowHeight());
-}
-
-// This is used by Insert etc.
-void wxPGProperty::DoAddChild( wxPGProperty* prop, int index,
-                               bool correct_mode )
-{
-    if ( index < 0 || (size_t)index >= m_children.size() )
-    {
-        if ( correct_mode ) prop->m_arrIndex = m_children.size();
-        m_children.push_back( prop );
-    }
-    else
-    {
-        m_children.insert( m_children.begin()+index, prop);
-        if ( correct_mode ) FixIndicesOfChildren( index );
-    }
-
-    prop->m_parent = this;
-}
-
-void wxPGProperty::DoPreAddChild( int index, wxPGProperty* prop )
-{
-    wxASSERT_MSG( prop->GetBaseName().length(),
-                  "Property's children must have unique, non-empty "
-                  "names within their scope" );
-
-    prop->m_arrIndex = index;
-    m_children.insert( m_children.begin()+index,
-                       prop );
-
-    int custImgHeight = prop->OnMeasureImage().y;
-    if ( custImgHeight < 0 /*|| custImgHeight > 1*/ )
-        prop->m_flags |= wxPG_PROP_CUSTOMIMAGE;
-
-    prop->m_parent = this;
-}
-
-void wxPGProperty::AddPrivateChild( wxPGProperty* prop )
-{
-    if ( !(m_flags & wxPG_PROP_PARENTAL_FLAGS) )
-        SetParentalType(wxPG_PROP_AGGREGATE);
-
-    wxASSERT_MSG( (m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
-                    wxPG_PROP_AGGREGATE,
-                  "Do not mix up AddPrivateChild() calls with other "
-                  "property adders." );
-
-    DoPreAddChild( m_children.size(), prop );
-}
-
-#if wxPG_COMPATIBILITY_1_4
-void wxPGProperty::AddChild( wxPGProperty* prop )
-{
-    AddPrivateChild(prop);
-}
-#endif
-
-wxPGProperty* wxPGProperty::InsertChild( int index,
-                                         wxPGProperty* childProperty )
-{
-    if ( index < 0 )
-        index = m_children.size();
-
-    if ( m_parentState )
-    {
-        m_parentState->DoInsert(this, index, childProperty);
-    }
-    else
-    {
-        if ( !(m_flags & wxPG_PROP_PARENTAL_FLAGS) )
-            SetParentalType(wxPG_PROP_MISC_PARENT);
-
-        wxASSERT_MSG( (m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
-                        wxPG_PROP_MISC_PARENT,
-                      "Do not mix up AddPrivateChild() calls with other "
-                      "property adders." );
-
-        DoPreAddChild( index, childProperty );
-    }
-
-    return childProperty;
-}
-
-void wxPGProperty::RemoveChild( wxPGProperty* p )
-{
-    wxArrayPGProperty::iterator it;
-    wxArrayPGProperty& children = m_children;
-
-    for ( it=children.begin(); it != children.end(); it++ )
-    {
-        if ( *it == p )
-        {
-            m_children.erase(it);
-            break;
-        }
-    }
-}
-
-void wxPGProperty::AdaptListToValue( wxVariant& list, wxVariant* value ) const
-{
-    wxASSERT( GetChildCount() );
-    wxASSERT( !IsCategory() );
-
-    *value = GetValue();
-
-    if ( !list.GetCount() )
-        return;
-
-    wxASSERT( GetChildCount() >= (unsigned int)list.GetCount() );
-
-    bool allChildrenSpecified;
-
-    // Don't fully update aggregate properties unless all children have
-    // specified value
-    if ( HasFlag(wxPG_PROP_AGGREGATE) )
-        allChildrenSpecified = AreAllChildrenSpecified(&list);
-    else
-        allChildrenSpecified = true;
-
-    wxVariant childValue = list[0];
-    unsigned int i;
-    unsigned int n = 0;
-
-    //wxLogDebug(wxT(">> %s.AdaptListToValue()"),GetBaseName().c_str());
-
-    for ( i=0; i<GetChildCount(); i++ )
-    {
-        const wxPGProperty* child = Item(i);
-
-        if ( childValue.GetName() == child->GetBaseName() )
-        {
-            //wxLogDebug(wxT("  %s(n=%i), %s"),childValue.GetName().c_str(),n,childValue.GetType().c_str());
-
-            if ( childValue.GetType() == wxPG_VARIANT_TYPE_LIST )
-            {
-                wxVariant cv2(child->GetValue());
-                child->AdaptListToValue(childValue, &cv2);
-                childValue = cv2;
-            }
-
-            if ( allChildrenSpecified )
-                ChildChanged(*value, i, childValue);
-            n++;
-            if ( n == (unsigned int)list.GetCount() )
-                break;
-            childValue = list[n];
-        }
-    }
-}
-
-
-void wxPGProperty::FixIndicesOfChildren( unsigned int starthere )
-{
-    size_t i;
-    for ( i=starthere;i<GetChildCount();i++)
-        Item(i)->m_arrIndex = i;
-}
-
-
-// Returns (direct) child property with given name (or NULL if not found)
-wxPGProperty* wxPGProperty::GetPropertyByName( const wxString& name ) const
-{
-    size_t i;
-
-    for ( i=0; i<GetChildCount(); i++ )
-    {
-        wxPGProperty* p = Item(i);
-        if ( p->m_name == name )
-            return p;
-    }
-
-    // Does it have point, then?
-    int pos = name.Find(wxS('.'));
-    if ( pos <= 0 )
-        return NULL;
-
-    wxPGProperty* p = GetPropertyByName(name. substr(0,pos));
-
-    if ( !p || !p->GetChildCount() )
-        return NULL;
-
-    return p->GetPropertyByName(name.substr(pos+1,name.length()-pos-1));
-}
-
-wxPGProperty* wxPGProperty::GetPropertyByNameWH( const wxString& name, unsigned int hintIndex ) const
-{
-    unsigned int i = hintIndex;
-
-    if ( i >= GetChildCount() )
-        i = 0;
-
-    unsigned int lastIndex = i - 1;
-
-    if ( lastIndex >= GetChildCount() )
-        lastIndex = GetChildCount() - 1;
-
-    for (;;)
-    {
-        wxPGProperty* p = Item(i);
-        if ( p->m_name == name )
-            return p;
-
-        if ( i == lastIndex )
-            break;
-
-        i++;
-        if ( i == GetChildCount() )
-            i = 0;
-    };
-
-    return NULL;
-}
-
-int wxPGProperty::GetChildrenHeight( int lh, int iMax_ ) const
-{
-    // Returns height of children, recursively, and
-    // by taking expanded/collapsed status into account.
-    //
-    // iMax is used when finding property y-positions.
-    //
-    unsigned int i = 0;
-    int h = 0;
-
-    if ( iMax_ == -1 )
-        iMax_ = GetChildCount();
-
-    unsigned int iMax = iMax_;
-
-    wxASSERT( iMax <= GetChildCount() );
-
-    if ( !IsExpanded() && GetParent() )
-        return 0;
-
-    while ( i < iMax )
-    {
-        wxPGProperty* pwc = (wxPGProperty*) Item(i);
-
-        if ( !pwc->HasFlag(wxPG_PROP_HIDDEN) )
-        {
-            if ( !pwc->IsExpanded() ||
-                 pwc->GetChildCount() == 0 )
-                h += lh;
-            else
-                h += pwc->GetChildrenHeight(lh) + lh;
-        }
-
-        i++;
-    }
-
-    return h;
-}
-
-wxPGProperty* wxPGProperty::GetItemAtY( unsigned int y, unsigned int lh, unsigned int* nextItemY ) const
-{
-    wxASSERT( nextItemY );
-
-    // Linear search at the moment
-    //
-    // nextItemY = y of next visible property, final value will be written back.
-    wxPGProperty* result = NULL;
-    wxPGProperty* current = NULL;
-    unsigned int iy = *nextItemY;
-    unsigned int i = 0;
-    unsigned int iMax = GetChildCount();
-
-    while ( i < iMax )
-    {
-        wxPGProperty* pwc = Item(i);
-
-        if ( !pwc->HasFlag(wxPG_PROP_HIDDEN) )
-        {
-            // Found?
-            if ( y < iy )
-            {
-                result = current;
-                break;
-            }
-
-            iy += lh;
-
-            if ( pwc->IsExpanded() &&
-                 pwc->GetChildCount() > 0 )
-            {
-                result = (wxPGProperty*) pwc->GetItemAtY( y, lh, &iy );
-                if ( result )
-                    break;
-            }
-
-            current = pwc;
-        }
-
-        i++;
-    }
-
-    // Found?
-    if ( !result && y < iy )
-        result = current;
-
-    *nextItemY = iy;
-
-    /*
-    if ( current )
-        wxLogDebug(wxT("%s::GetItemAtY(%i) -> %s"),this->GetLabel().c_str(),y,current->GetLabel().c_str());
-    else
-        wxLogDebug(wxT("%s::GetItemAtY(%i) -> NULL"),this->GetLabel().c_str(),y);
-    */
-
-    return (wxPGProperty*) result;
-}
-
-wxPGProperty* wxPGProperty::GetItemAtY( unsigned int y ) const
-{
-    unsigned int nextItemY;
-    return GetItemAtY(y, GetGrid()->GetRowHeight(), &nextItemY);
-}
-
-void wxPGProperty::Empty()
-{
-    size_t i;
-    if ( !HasFlag(wxPG_PROP_CHILDREN_ARE_COPIES) )
-    {
-        for ( i=0; i<GetChildCount(); i++ )
-        {
-            delete m_children[i];
-        }
-    }
-
-    m_children.clear();
-}
-
-void wxPGProperty::DeleteChildren()
-{
-    wxPropertyGridPageState* state = m_parentState;
-
-    while ( GetChildCount() )
-    {
-        wxPGProperty* child = Item(GetChildCount()-1);
-        state->DoDelete(child, true);
-    }
-}
-
-void wxPGProperty::ChildChanged( wxVariant& WXUNUSED(thisValue),
-                                 int WXUNUSED(childIndex),
-                                 wxVariant& WXUNUSED(childValue) ) const
-{
-}
-
-bool wxPGProperty::AreAllChildrenSpecified( wxVariant* pendingList ) const
-{
-    unsigned int i;
-
-    const wxVariantList* pList = NULL;
-    wxVariantList::const_iterator node;
-
-    if ( pendingList )
-    {
-        pList = &pendingList->GetList();
-        node = pList->begin();
-    }
-
-    for ( i=0; i<GetChildCount(); i++ )
-    {
-        wxPGProperty* child = Item(i);
-        const wxVariant* listValue = NULL;
-        wxVariant value;
-
-        if ( pendingList )
-        {
-            const wxString& childName = child->GetBaseName();
-
-            for ( ; node != pList->end(); ++node )
-            {
-                const wxVariant& item = *((const wxVariant*)*node);
-                if ( item.GetName() == childName )
-                {
-                    listValue = &item;
-                    value = item;
-                    break;
-                }
-            }
-        }
-
-        if ( !listValue )
-            value = child->GetValue();
-
-        if ( value.IsNull() )
-            return false;
-
-        // Check recursively
-        if ( child->GetChildCount() )
-        {
-            const wxVariant* childList = NULL;
-
-            if ( listValue && listValue->GetType() == wxPG_VARIANT_TYPE_LIST )
-                childList = listValue;
-
-            if ( !child->AreAllChildrenSpecified((wxVariant*)childList) )
-                return false;
-        }
-    }
-
-    return true;
-}
-
-wxPGProperty* wxPGProperty::UpdateParentValues()
-{
-    wxPGProperty* parent = m_parent;
-    if ( parent && parent->HasFlag(wxPG_PROP_COMPOSED_VALUE) &&
-         !parent->IsCategory() && !parent->IsRoot() )
-    {
-        wxString s;
-        parent->DoGenerateComposedValue(s);
-        parent->m_value = s;
-        return parent->UpdateParentValues();
-    }
-    return this;
-}
-
-bool wxPGProperty::IsTextEditable() const
-{
-    if ( HasFlag(wxPG_PROP_READONLY) )
-        return false;
-
-    if ( HasFlag(wxPG_PROP_NOEDITOR) &&
-         (GetChildCount() ||
-          wxString(GetEditorClass()->GetClassInfo()->GetClassName()).EndsWith(wxS("Button")))
-       )
-        return false;
-
-    return true;
-}
-
-// Call after fixed sub-properties added/removed after creation.
-// if oldSelInd >= 0 and < new max items, then selection is
-// moved to it. Note: oldSelInd -2 indicates that this property
-// should be selected.
-void wxPGProperty::SubPropsChanged( int oldSelInd )
-{
-    wxPropertyGridPageState* state = GetParentState();
-    wxPropertyGrid* grid = state->GetGrid();
-
-    //
-    // Re-repare children (recursively)
-    for ( unsigned int i=0; i<GetChildCount(); i++ )
-    {
-        wxPGProperty* child = Item(i);
-        child->InitAfterAdded(state, grid);
-    }
-
-    wxPGProperty* sel = NULL;
-    if ( oldSelInd >= (int)m_children.size() )
-        oldSelInd = (int)m_children.size() - 1;
-
-    if ( oldSelInd >= 0 )
-        sel = m_children[oldSelInd];
-    else if ( oldSelInd == -2 )
-        sel = this;
-
-    if ( sel )
-        state->DoSelectProperty(sel);
-
-    if ( state == grid->GetState() )
-    {
-        grid->GetPanel()->Refresh();
-    }
-}
-
-// -----------------------------------------------------------------------
-// wxPGRootProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxPGRootProperty,none,TextCtrl)
-IMPLEMENT_DYNAMIC_CLASS(wxPGRootProperty, wxPGProperty)
-
-
-wxPGRootProperty::wxPGRootProperty( const wxString& name )
-    : wxPGProperty()
-{
-    m_name = name;
-    m_label = m_name;
-    SetParentalType(0);
-    m_depth = 0;
-}
-
-
-wxPGRootProperty::~wxPGRootProperty()
-{
-}
-
-
-// -----------------------------------------------------------------------
-// wxPropertyCategory
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxPropertyCategory,none,TextCtrl)
-IMPLEMENT_DYNAMIC_CLASS(wxPropertyCategory, wxPGProperty)
-
-void wxPropertyCategory::Init()
-{
-    // don't set colour - prepareadditem method should do this
-    SetParentalType(wxPG_PROP_CATEGORY);
-    m_capFgColIndex = 1;
-    m_textExtent = -1;
-}
-
-wxPropertyCategory::wxPropertyCategory()
-    : wxPGProperty()
-{
-    Init();
-}
-
-
-wxPropertyCategory::wxPropertyCategory( const wxString &label, const wxString& name )
-    : wxPGProperty(label,name)
-{
-    Init();
-}
-
-
-wxPropertyCategory::~wxPropertyCategory()
-{
-}
-
-
-wxString wxPropertyCategory::ValueToString( wxVariant& WXUNUSED(value),
-                                            int WXUNUSED(argFlags) ) const
-{
-    return wxEmptyString;
-}
-
-int wxPropertyCategory::GetTextExtent( const wxWindow* wnd, const wxFont& font ) const
-{
-    if ( m_textExtent > 0 )
-        return m_textExtent;
-    int x = 0, y = 0;
-	((wxWindow*)wnd)->GetTextExtent( m_label, &x, &y, 0, 0, &font );
-    return x;
-}
-
-void wxPropertyCategory::CalculateTextExtent( wxWindow* wnd, const wxFont& font )
-{
-    int x = 0, y = 0;
-	wnd->GetTextExtent( m_label, &x, &y, 0, 0, &font );
-    m_textExtent = x;
-}
-
-// -----------------------------------------------------------------------
-// wxPGChoices
-// -----------------------------------------------------------------------
-
-wxPGChoiceEntry& wxPGChoices::Add( const wxString& label, int value )
-{
-    AllocExclusive();
-
-    wxPGChoiceEntry entry(label, value);
-    return m_data->Insert( -1, entry );
-}
-
-// -----------------------------------------------------------------------
-
-wxPGChoiceEntry& wxPGChoices::Add( const wxString& label, const wxBitmap& bitmap, int value )
-{
-    AllocExclusive();
-
-    wxPGChoiceEntry entry(label, value);
-    entry.SetBitmap(bitmap);
-    return m_data->Insert( -1, entry );
-}
-
-// -----------------------------------------------------------------------
-
-wxPGChoiceEntry& wxPGChoices::Insert( const wxPGChoiceEntry& entry, int index )
-{
-    AllocExclusive();
-
-    return m_data->Insert( index, entry );
-}
-
-// -----------------------------------------------------------------------
-
-wxPGChoiceEntry& wxPGChoices::Insert( const wxString& label, int index, int value )
-{
-    AllocExclusive();
-
-    wxPGChoiceEntry entry(label, value);
-    return m_data->Insert( index, entry );
-}
-
-// -----------------------------------------------------------------------
-
-wxPGChoiceEntry& wxPGChoices::AddAsSorted( const wxString& label, int value )
-{
-    AllocExclusive();
-
-    size_t index = 0;
-
-    while ( index < GetCount() )
-    {
-        int cmpRes = GetLabel(index).Cmp(label);
-        if ( cmpRes > 0 )
-            break;
-        index++;
-    }
-
-    wxPGChoiceEntry entry(label, value);
-    return m_data->Insert( index, entry );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::Add( const wxChar** labels, const ValArrItem* values )
-{
-    AllocExclusive();
-
-    unsigned int itemcount = 0;
-    const wxChar** p = &labels[0];
-    while ( *p ) { p++; itemcount++; }
-
-    unsigned int i;
-    for ( i = 0; i < itemcount; i++ )
-    {
-        int value = i;
-        if ( values )
-            value = values[i];
-        wxPGChoiceEntry entry(labels[i], value);
-        m_data->Insert( i, entry );
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::Add( const wxArrayString& arr, const wxArrayInt& arrint )
-{
-    AllocExclusive();
-
-    unsigned int i;
-    unsigned int itemcount = arr.size();
-
-    for ( i = 0; i < itemcount; i++ )
-    {
-        int value = i;
-        if ( &arrint && arrint.size() )
-            value = arrint[i];
-        wxPGChoiceEntry entry(arr[i], value);
-        m_data->Insert( i, entry );
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::RemoveAt(size_t nIndex, size_t count)
-{
-    AllocExclusive();
-
-    wxASSERT( m_data->m_refCount != 0xFFFFFFF );
-    m_data->m_items.erase(m_data->m_items.begin()+nIndex,
-                          m_data->m_items.begin()+nIndex+count);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::Clear()
-{
-    if ( m_data != wxPGChoicesEmptyData )
-    {
-        AllocExclusive();
-        m_data->Clear();
-    }
-}
-
-// -----------------------------------------------------------------------
-
-int wxPGChoices::Index( const wxString& str ) const
-{
-    if ( IsOk() )
-    {
-        unsigned int i;
-        for ( i=0; i< m_data->GetCount(); i++ )
-        {
-            const wxPGChoiceEntry& entry = m_data->Item(i);
-            if ( entry.HasText() && entry.GetText() == str )
-                return i;
-        }
-    }
-    return -1;
-}
-
-// -----------------------------------------------------------------------
-
-int wxPGChoices::Index( int val ) const
-{
-    if ( IsOk() )
-    {
-        unsigned int i;
-        for ( i=0; i< m_data->GetCount(); i++ )
-        {
-            const wxPGChoiceEntry& entry = m_data->Item(i);
-            if ( entry.GetValue() == val )
-                return i;
-        }
-    }
-    return -1;
-}
-
-// -----------------------------------------------------------------------
-
-wxArrayString wxPGChoices::GetLabels() const
-{
-    wxArrayString arr;
-    unsigned int i;
-
-    if ( this && IsOk() )
-        for ( i=0; i<GetCount(); i++ )
-            arr.push_back(GetLabel(i));
-
-    return arr;
-}
-
-// -----------------------------------------------------------------------
-
-wxArrayInt wxPGChoices::GetValuesForStrings( const wxArrayString& strings ) const
-{
-    wxArrayInt arr;
-
-    if ( IsOk() )
-    {
-        unsigned int i;
-        for ( i=0; i< strings.size(); i++ )
-        {
-            int index = Index(strings[i]);
-            if ( index >= 0 )
-                arr.Add(GetValue(index));
-            else
-                arr.Add(wxPG_INVALID_VALUE);
-        }
-    }
-
-    return arr;
-}
-
-// -----------------------------------------------------------------------
-
-wxArrayInt wxPGChoices::GetIndicesForStrings( const wxArrayString& strings,
-                                              wxArrayString* unmatched ) const
-{
-    wxArrayInt arr;
-
-    if ( IsOk() )
-    {
-        unsigned int i;
-        for ( i=0; i< strings.size(); i++ )
-        {
-            const wxString& str = strings[i];
-            int index = Index(str);
-            if ( index >= 0 )
-                arr.Add(index);
-            else if ( unmatched )
-                unmatched->Add(str);
-        }
-    }
-
-    return arr;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::AllocExclusive()
-{
-    EnsureData();
-
-    if ( m_data->m_refCount != 1 )
-    {
-        wxPGChoicesData* data = new wxPGChoicesData();
-        data->CopyDataFrom(m_data);
-        Free();
-        m_data = data;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::AssignData( wxPGChoicesData* data )
-{
-    Free();
-
-    if ( data != wxPGChoicesEmptyData )
-    {
-        m_data = data;
-        data->m_refCount++;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::Init()
-{
-    m_data = wxPGChoicesEmptyData;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGChoices::Free()
-{
-    if ( m_data != wxPGChoicesEmptyData )
-    {
-        m_data->DecRef();
-        m_data = wxPGChoicesEmptyData;
-    }
-}
-
-// -----------------------------------------------------------------------
-// wxPGAttributeStorage
-// -----------------------------------------------------------------------
-
-wxPGAttributeStorage::wxPGAttributeStorage()
-{
-}
-
-wxPGAttributeStorage::~wxPGAttributeStorage()
-{
-    wxPGHashMapS2P::iterator it;
-
-    for ( it = m_map.begin(); it != m_map.end(); ++it )
-    {
-        wxVariantData* data = (wxVariantData*) it->second;
-        data->DecRef();
-    }
-}
-
-void wxPGAttributeStorage::Set( const wxString& name, const wxVariant& value )
-{
-    wxVariantData* data = value.GetData();
-
-    // Free old, if any
-    wxPGHashMapS2P::iterator it = m_map.find(name);
-    if ( it != m_map.end() )
-    {
-        ((wxVariantData*)it->second)->DecRef();
-
-        if ( !data )
-        {
-            // If Null variant, just remove from set
-            m_map.erase(it);
-            return;
-        }
-    }
-
-    if ( data )
-    {
-        data->IncRef();
-
-        m_map[name] = data;
-    }
-}
-
-#endif  // wxUSE_PROPGRID
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/property.cpp
+// Purpose:     wxPGProperty and related support classes
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2008-08-23
+// RCS-ID:      $Id: property.cpp 60793 2009-05-29 16:04:22Z JMS $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcmemory.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/settings.h"
+    #include "wx/intl.h"
+#endif
+
+#include "wx/propgrid/propgrid.h"
+
+
+#define PWC_CHILD_SUMMARY_LIMIT         16 // Maximum number of children summarized in a parent property's
+                                           // value field.
+
+#define PWC_CHILD_SUMMARY_CHAR_LIMIT    64 // Character limit of summary field when not editing
+
+#if wxPG_COMPATIBILITY_1_4
+
+// Used to establish backwards compatiblity
+const char* g_invalidStringContent = "@__TOTALLY_INVALID_STRING__@";
+
+#endif
+
+// -----------------------------------------------------------------------
+
+static void wxPGDrawFocusRect( wxDC& dc, const wxRect& rect )
+{
+#if defined(__WXMSW__) && !defined(__WXWINCE__)
+    // FIXME: Use DrawFocusRect code above (currently it draws solid line
+    //   for caption focus but works ok for other stuff).
+    //   Also, it seems that this code may not work in future wx versions.
+    dc.SetLogicalFunction(wxINVERT);
+
+    wxPen pen(*wxBLACK,1,wxDOT);
+    pen.SetCap(wxCAP_BUTT);
+    dc.SetPen(pen);
+    dc.SetBrush(*wxTRANSPARENT_BRUSH);
+
+    dc.DrawRectangle(rect);
+
+    dc.SetLogicalFunction(wxCOPY);
+#else
+    dc.SetLogicalFunction(wxINVERT);
+
+    dc.SetPen(wxPen(*wxBLACK,1,wxDOT));
+    dc.SetBrush(*wxTRANSPARENT_BRUSH);
+
+    dc.DrawRectangle(rect);
+
+    dc.SetLogicalFunction(wxCOPY);
+#endif
+}
+
+// -----------------------------------------------------------------------
+// wxPGCellRenderer
+// -----------------------------------------------------------------------
+
+wxSize wxPGCellRenderer::GetImageSize( const wxPGProperty* WXUNUSED(property),
+                                       int WXUNUSED(column),
+                                       int WXUNUSED(item) ) const
+{
+     return wxSize(0, 0);
+}
+
+void wxPGCellRenderer::DrawText( wxDC& dc, const wxRect& rect,
+                                 int xOffset, const wxString& text ) const
+{
+    dc.DrawText( text,
+                 rect.x+xOffset+wxPG_XBEFORETEXT,
+                 rect.y+((rect.height-dc.GetCharHeight())/2) );
+}
+
+void wxPGCellRenderer::DrawEditorValue( wxDC& dc, const wxRect& rect,
+                                        int xOffset, const wxString& text,
+                                        wxPGProperty* property,
+                                        const wxPGEditor* editor ) const
+{
+    int yOffset = ((rect.height-dc.GetCharHeight())/2);
+
+    if ( editor )
+    {
+        wxRect rect2(rect); 
+        rect2.x += xOffset;
+        rect2.y += yOffset;
+        rect2.height -= yOffset;
+        editor->DrawValue( dc, rect2, property, text );
+    }
+    else
+    {
+        dc.DrawText( text,
+                     rect.x+xOffset+wxPG_XBEFORETEXT,
+                     rect.y+yOffset );
+    }
+}
+
+void wxPGCellRenderer::DrawCaptionSelectionRect( wxDC& dc, int x, int y, int w, int h ) const
+{
+    wxRect focusRect(x,y+((h-dc.GetCharHeight())/2),w,h);
+    wxPGDrawFocusRect(dc,focusRect);
+}
+
+int wxPGCellRenderer::PreDrawCell( wxDC& dc, const wxRect& rect, const wxPGCell& cell, int flags ) const
+{
+    int imageWidth = 0;
+
+    // If possible, use cell colours
+    if ( !(flags & DontUseCellBgCol) )
+    {
+        dc.SetPen(cell.GetBgCol());
+        dc.SetBrush(cell.GetBgCol());
+    }
+
+    if ( !(flags & DontUseCellFgCol) )
+    {
+        dc.SetTextForeground(cell.GetFgCol());
+    }
+
+    // Draw Background, but only if not rendering in control
+    // (as control already has rendered correct background).
+    if ( !(flags & (Control|ChoicePopup)) )
+        dc.DrawRectangle(rect);
+
+    const wxBitmap& bmp = cell.GetBitmap();
+    if ( bmp.Ok() &&
+        // Do not draw oversized bitmap outside choice popup
+         ((flags & ChoicePopup) || bmp.GetHeight() < rect.height )
+        )
+    {
+        dc.DrawBitmap( bmp,
+                       rect.x + wxPG_CONTROL_MARGIN + wxCC_CUSTOM_IMAGE_MARGIN1,
+                       rect.y + wxPG_CUSTOM_IMAGE_SPACINGY,
+                       true );
+        imageWidth = bmp.GetWidth();
+    }
+
+    return imageWidth;
+}
+
+// -----------------------------------------------------------------------
+// wxPGDefaultRenderer
+// -----------------------------------------------------------------------
+
+void wxPGDefaultRenderer::Render( wxDC& dc, const wxRect& rect,
+                                  const wxPropertyGrid* propertyGrid, wxPGProperty* property,
+                                  int column, int item, int flags ) const
+{
+    bool isUnspecified = property->IsValueUnspecified();
+
+    if ( column == 1 && item == -1 )
+    {
+        int cmnVal = property->GetCommonValue();
+        if ( cmnVal >= 0 )
+        {
+            // Common Value
+            if ( !isUnspecified )
+                DrawText( dc, rect, 0, propertyGrid->GetCommonValueLabel(cmnVal) );
+            return;
+        }
+    }
+
+    const wxPGEditor* editor = NULL;
+    const wxPGCell* cell = NULL;
+
+    wxString text;
+    int imageWidth = 0;
+    int preDrawFlags = flags;
+
+    property->GetDisplayInfo(column, item, flags, &text, &cell);
+
+    imageWidth = PreDrawCell( dc, rect, *cell, preDrawFlags );
+
+    if ( column == 1 )
+    {
+        if ( !isUnspecified )
+        {
+            editor = property->GetColumnEditor(column);
+
+            // Regular property value
+
+            wxSize imageSize = propertyGrid->GetImageSize(property, item);
+
+            wxPGPaintData paintdata;
+            paintdata.m_parent = propertyGrid;
+            paintdata.m_choiceItem = item;
+
+            if ( imageSize.x > 0 )
+            {
+                wxRect imageRect(rect.x + wxPG_CONTROL_MARGIN + wxCC_CUSTOM_IMAGE_MARGIN1,
+                                 rect.y+wxPG_CUSTOM_IMAGE_SPACINGY,
+                                 wxPG_CUSTOM_IMAGE_WIDTH,
+                                 rect.height-(wxPG_CUSTOM_IMAGE_SPACINGY*2));
+
+                dc.SetPen( wxPen(propertyGrid->GetCellTextColour(), 1, wxSOLID) );
+
+                paintdata.m_drawnWidth = imageSize.x;
+                paintdata.m_drawnHeight = imageSize.y;
+
+                property->OnCustomPaint( dc, imageRect, paintdata );
+
+                imageWidth = paintdata.m_drawnWidth;
+            }
+
+            text = property->GetValueAsString();
+
+            // Add units string?
+            if ( propertyGrid->GetColumnCount() <= 2 )
+            {
+                wxString unitsString = property->GetAttribute(wxPGGlobalVars->m_strUnits, wxEmptyString);
+                if ( unitsString.length() )
+                    text = wxString::Format(wxS("%s %s"), text.c_str(), unitsString.c_str() );
+            }
+        }
+
+        if ( text.length() == 0 )
+        {
+            // Try to show inline help if no text
+            wxVariant vInlineHelp = property->GetAttribute(wxPGGlobalVars->m_strInlineHelp);
+            if ( !vInlineHelp.IsNull() )
+            {
+                text = vInlineHelp.GetString();
+                dc.SetTextForeground(propertyGrid->GetCellDisabledTextColour());
+            }
+        }
+    }
+
+    int imageOffset = property->GetImageOffset(imageWidth);
+
+    DrawEditorValue( dc, rect, imageOffset, text, property, editor );
+
+    // active caption gets nice dotted rectangle
+    if ( property->IsCategory() /*&& column == 0*/ )
+    {
+        if ( flags & Selected )
+        {
+            if ( imageWidth > 0 )
+            {
+                imageOffset -= DEFAULT_IMAGE_OFFSET_INCREMENT;
+                imageWidth += wxCC_CUSTOM_IMAGE_MARGIN2 + 4;
+            }
+
+            DrawCaptionSelectionRect( dc,
+                                      rect.x+wxPG_XBEFORETEXT-wxPG_CAPRECTXMARGIN+imageOffset,
+                                      rect.y-wxPG_CAPRECTYMARGIN+1,
+                                      ((wxPropertyCategory*)property)->GetTextExtent(propertyGrid,
+                                                                                     propertyGrid->GetCaptionFont())
+                                      +(wxPG_CAPRECTXMARGIN*2),
+                                      propertyGrid->GetFontHeight()+(wxPG_CAPRECTYMARGIN*2) );
+        }
+    }
+}
+
+wxSize wxPGDefaultRenderer::GetImageSize( const wxPGProperty* property,
+                                          int column,
+                                          int item ) const
+{
+    if ( property && column == 1 )
+    {
+        if ( item == -1 )
+        {
+            wxBitmap* bmp = property->GetValueImage();
+
+            if ( bmp && bmp->Ok() )
+                return wxSize(bmp->GetWidth(),bmp->GetHeight());
+        }
+    }
+    return wxSize(0,0);
+}
+
+// -----------------------------------------------------------------------
+// wxPGCellData
+// -----------------------------------------------------------------------
+
+wxPGCellData::wxPGCellData()
+    : wxObjectRefData()
+{
+    m_hasValidText = false;
+}
+
+// -----------------------------------------------------------------------
+// wxPGCell
+// -----------------------------------------------------------------------
+
+wxPGCell::wxPGCell()
+    : wxObject()
+{
+}
+
+wxPGCell::wxPGCell( const wxString& text,
+                    const wxBitmap& bitmap,
+                    const wxColour& fgCol,
+                    const wxColour& bgCol )
+    : wxObject()
+{
+    wxPGCellData* data = new wxPGCellData();
+    m_refData = data;
+    data->m_text = text;
+    data->m_bitmap = bitmap;
+    data->m_fgCol = fgCol;
+    data->m_bgCol = bgCol;
+    data->m_hasValidText = true;
+}
+
+wxObjectRefData *wxPGCell::CloneRefData( const wxObjectRefData *data ) const
+{
+    wxPGCellData* c = new wxPGCellData();
+    const wxPGCellData* o = (const wxPGCellData*) data;
+    c->m_text = o->m_text;
+    c->m_bitmap = o->m_bitmap;
+    c->m_fgCol = o->m_fgCol;
+    c->m_bgCol = o->m_bgCol;
+    c->m_hasValidText = o->m_hasValidText;
+    return c;
+}
+
+void wxPGCell::SetText( const wxString& text )
+{
+    AllocExclusive();
+
+    GetData()->SetText(text);
+}
+
+void wxPGCell::SetBitmap( const wxBitmap& bitmap )
+{
+    AllocExclusive();
+
+    GetData()->SetBitmap(bitmap);
+}
+
+void wxPGCell::SetFgCol( const wxColour& col )
+{
+    AllocExclusive();
+
+    GetData()->SetFgCol(col);
+}
+
+void wxPGCell::SetBgCol( const wxColour& col )
+{
+    AllocExclusive();
+
+    GetData()->SetBgCol(col);
+}
+
+void wxPGCell::MergeFrom( const wxPGCell& srcCell )
+{
+    AllocExclusive();
+
+    wxPGCellData* data = GetData();
+
+    if ( srcCell.HasText() )
+        data->SetText(srcCell.GetText());
+
+    if ( srcCell.GetFgCol().IsOk() )
+        data->SetFgCol(srcCell.GetFgCol());
+
+    if ( srcCell.GetBgCol().IsOk() )
+        data->SetBgCol(srcCell.GetBgCol());
+
+    if ( srcCell.GetBitmap().IsOk() )
+        data->SetBitmap(srcCell.GetBitmap());
+}
+
+// -----------------------------------------------------------------------
+// wxPGProperty
+// -----------------------------------------------------------------------
+
+IMPLEMENT_ABSTRACT_CLASS(wxPGProperty, wxObject)
+
+wxString* wxPGProperty::sm_wxPG_LABEL = NULL;
+
+void wxPGProperty::Init()
+{
+    m_commonValue = -1;
+    m_arrIndex = 0xFFFF;
+    m_parent = NULL;
+
+    m_parentState = NULL;
+
+    m_clientData = NULL;
+    m_clientObject = NULL;
+
+    m_customEditor = NULL;
+#if wxUSE_VALIDATORS
+    m_validator = NULL;
+#endif
+    m_valueBitmap = NULL;
+
+    m_maxLen = 0; // infinite maximum length
+
+    m_flags = wxPG_PROP_PROPERTY;
+
+    m_depth = 1;
+
+    SetExpanded(true);
+}
+
+
+void wxPGProperty::Init( const wxString& label, const wxString& name )
+{
+    // We really need to check if &label and &name are NULL pointers
+    // (this can if we are called before property grid has been initalized)
+
+    if ( (&label) != NULL && label != wxPG_LABEL )
+        m_label = label;
+
+    if ( (&name) != NULL && name != wxPG_LABEL )
+        DoSetName( name );
+    else
+        DoSetName( m_label );
+
+    Init();
+}
+
+void wxPGProperty::InitAfterAdded( wxPropertyGridPageState* pageState,
+                                   wxPropertyGrid* propgrid )
+{
+    //
+    // Called after property has been added to grid or page
+    // (so propgrid can be NULL, too).
+
+    wxPGProperty* parent = m_parent;
+    bool parentIsRoot = parent->IsKindOf(CLASSINFO(wxPGRootProperty));
+
+    m_parentState = pageState;
+
+#if wxPG_COMPATIBILITY_1_4
+    // Make sure deprecated virtual functions are not implemented
+    wxString s = GetValueAsString( 0xFFFF );
+    wxASSERT_MSG( s == g_invalidStringContent,
+                  "Implement ValueToString() instead of GetValueAsString()" );
+#endif
+
+    if ( !parentIsRoot && !parent->IsCategory() )
+    {
+        m_cells = parent->m_cells;
+    }
+
+    // If in hideable adding mode, or if assigned parent is hideable, then
+    // make this one hideable.
+    if (
+         ( !parentIsRoot && parent->HasFlag(wxPG_PROP_HIDDEN) ) ||
+         ( propgrid && (propgrid->HasInternalFlag(wxPG_FL_ADDING_HIDEABLES)) )
+       )
+        SetFlag( wxPG_PROP_HIDDEN );
+
+    // Set custom image flag.
+    int custImgHeight = OnMeasureImage().y;
+    if ( custImgHeight < 0 )
+    {
+        SetFlag(wxPG_PROP_CUSTOMIMAGE);
+    }
+
+    if ( propgrid && (propgrid->HasFlag(wxPG_LIMITED_EDITING)) )
+        SetFlag(wxPG_PROP_NOEDITOR);
+
+    // Make sure parent has some parental flags
+    if ( !parent->HasFlag(wxPG_PROP_PARENTAL_FLAGS) )
+        parent->SetParentalType(wxPG_PROP_MISC_PARENT);
+
+    if ( !IsCategory() )
+    {
+        // This is not a category.
+
+        // Depth.
+        //
+        unsigned char depth = 1;
+        if ( !parentIsRoot )
+        {
+            depth = parent->m_depth;
+            if ( !parent->IsCategory() )
+                depth++;
+        }
+        m_depth = depth;
+        unsigned char greyDepth = depth;
+
+        if ( !parentIsRoot )
+        {
+            wxPropertyCategory* pc;
+
+            if ( parent->IsCategory() )
+                pc = (wxPropertyCategory* ) parent;
+            else
+                // This conditional compile is necessary to
+                // bypass some compiler bug.
+                pc = pageState->GetPropertyCategory(parent);
+
+            if ( pc )
+                greyDepth = pc->GetDepth();
+            else
+                greyDepth = parent->m_depthBgCol;
+        }
+
+        m_depthBgCol = greyDepth;
+    }
+    else
+    {
+        // This is a category.
+
+        // depth
+        unsigned char depth = 1;
+        if ( !parentIsRoot )
+        {
+            depth = parent->m_depth + 1;
+        }
+        m_depth = depth;
+        m_depthBgCol = depth;
+    }
+
+    //
+    // Has initial children
+    if ( GetChildCount() )
+    {
+        // Check parental flags
+        wxASSERT_MSG( ((m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
+                            wxPG_PROP_AGGREGATE) ||
+                      ((m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
+                            wxPG_PROP_MISC_PARENT),
+                      "wxPGProperty parental flags set incorrectly at "
+                      "this time" );
+
+        if ( HasFlag(wxPG_PROP_AGGREGATE) )
+        {
+            // Properties with private children are not expanded by default.
+            SetExpanded(false);
+        }
+        else if ( propgrid && propgrid->HasFlag(wxPG_HIDE_MARGIN) )
+        {
+            // ...unless it cannot be expanded by user and therefore must
+            // remain visible at all times
+            SetExpanded(true);
+        }
+
+        //
+        // Prepare children recursively
+        for ( unsigned int i=0; i<GetChildCount(); i++ )
+        {
+            wxPGProperty* child = Item(i);
+            child->InitAfterAdded(pageState, pageState->GetGrid());
+        }
+
+        if ( propgrid && (propgrid->GetExtraStyle() & wxPG_EX_AUTO_UNSPECIFIED_VALUES) )
+            SetFlagRecursively(wxPG_PROP_AUTO_UNSPECIFIED, true);
+    }
+}
+
+wxPGProperty::wxPGProperty()
+    : wxObject()
+{
+    Init();
+}
+
+
+wxPGProperty::wxPGProperty( const wxString& label, const wxString& name )
+    : wxObject()
+{
+    Init( label, name );
+}
+
+
+wxPGProperty::~wxPGProperty()
+{
+    delete m_clientObject;
+
+    Empty();  // this deletes items
+
+    delete m_valueBitmap;
+#if wxUSE_VALIDATORS
+    delete m_validator;
+#endif
+
+    // This makes it easier for us to detect dangling pointers
+    m_parent = NULL;
+}
+
+
+bool wxPGProperty::IsSomeParent( wxPGProperty* candidate ) const
+{
+    wxPGProperty* parent = m_parent;
+    do
+    {
+        if ( parent == candidate )
+            return true;
+        parent = parent->m_parent;
+    } while ( parent );
+    return false;
+}
+
+
+wxString wxPGProperty::GetName() const
+{
+    wxPGProperty* parent = GetParent();
+
+    if ( !m_name.length() || !parent || parent->IsCategory() || parent->IsRoot() )
+        return m_name;
+
+    return m_parent->GetName() + wxS(".") + m_name;
+}
+
+wxPropertyGrid* wxPGProperty::GetGrid() const
+{
+    if ( !m_parentState )
+        return NULL;
+    return m_parentState->GetGrid();
+}
+
+int wxPGProperty::Index( const wxPGProperty* p ) const
+{
+    for ( unsigned int i = 0; i<m_children.size(); i++ )
+    {
+        if ( p == m_children[i] )
+            return i;
+    }
+    return wxNOT_FOUND;
+}
+
+bool wxPGProperty::ValidateValue( wxVariant& WXUNUSED(value), wxPGValidationInfo& WXUNUSED(validationInfo) ) const
+{
+    return true;
+}
+
+void wxPGProperty::OnSetValue()
+{
+}
+
+void wxPGProperty::RefreshChildren ()
+{
+}
+
+void wxPGProperty::OnValidationFailure( wxVariant& WXUNUSED(pendingValue) )
+{
+}
+
+void wxPGProperty::GetDisplayInfo( unsigned int column,
+                                   int choiceIndex,
+                                   int flags,
+                                   wxString* pString,
+                                   const wxPGCell** pCell )
+{
+    const wxPGCell* cell = NULL;
+
+    if ( !(flags & wxPGCellRenderer::ChoicePopup) )
+    {
+        // Not painting listi of choice popups, so get text from property
+        cell = &GetCell(column);
+        if ( cell->HasText() )
+        {
+            *pString = cell->GetText();
+        }
+        else
+        {
+            if ( column == 0 )
+                *pString = GetLabel();
+            else if ( column == 1 )
+                *pString = GetDisplayedString();
+            else if ( column == 2 )
+                *pString = GetAttribute(wxPGGlobalVars->m_strUnits, wxEmptyString);
+        }
+    }
+    else
+    {
+        wxASSERT( column == 1 );
+
+        if ( choiceIndex != wxNOT_FOUND )
+        {
+            const wxPGChoiceEntry& entry = m_choices[choiceIndex];
+            if ( entry.GetBitmap().IsOk() ||
+                 entry.GetFgCol().IsOk() ||
+                 entry.GetBgCol().IsOk() )
+                cell = &entry;
+            *pString = m_choices.GetLabel(choiceIndex);
+        }
+    }
+
+    if ( !cell )
+        cell = &GetCell(column);
+
+    wxASSERT_MSG( cell->GetData(),
+                  wxString::Format("Invalid cell for property %s",
+                                   GetName().c_str()) );
+
+    *pCell = cell;
+}
+
+/*
+wxString wxPGProperty::GetColumnText( unsigned int col, int choiceIndex ) const
+{
+    
+    if ( col != 1 || choiceIndex == wxNOT_FOUND )
+    {
+        const wxPGCell& cell = GetCell(col);
+        if ( cell->HasText() )
+        {
+            return cell->GetText();
+        }
+        else
+        {
+            if ( col == 0 )
+                return GetLabel();
+            else if ( col == 1 )
+                return GetDisplayedString();
+            else if ( col == 2 )
+                return GetAttribute(wxPGGlobalVars->m_strUnits, wxEmptyString);
+        }
+    }
+    else
+    {
+        // Use choice
+        return m_choices.GetLabel(choiceIndex);
+    }
+
+    return wxEmptyString;
+}
+*/
+
+void wxPGProperty::DoGenerateComposedValue( wxString& text,
+                                            int argFlags,
+                                            const wxVariantList* valueOverrides,
+                                            wxPGHashMapS2S* childResults ) const
+{
+    int i;
+    int iMax = m_children.size();
+
+    text.clear();
+    if ( iMax == 0 )
+        return;
+
+    if ( iMax > PWC_CHILD_SUMMARY_LIMIT &&
+         !(argFlags & wxPG_FULL_VALUE) )
+        iMax = PWC_CHILD_SUMMARY_LIMIT;
+
+    int iMaxMinusOne = iMax-1;
+
+    if ( !IsTextEditable() )
+        argFlags |= wxPG_UNEDITABLE_COMPOSITE_FRAGMENT;
+
+    wxPGProperty* curChild = m_children[0];
+
+    bool overridesLeft = false;
+    wxVariant overrideValue;
+    wxVariantList::const_iterator node;
+
+    if ( valueOverrides )
+    {
+        node = valueOverrides->begin();
+        if ( node != valueOverrides->end() )
+        {
+            overrideValue = *node;
+            overridesLeft = true;
+        }
+    }
+
+    for ( i = 0; i < iMax; i++ )
+    {
+        wxVariant childValue;
+
+        wxString childLabel = curChild->GetLabel();
+
+        // Check for value override
+        if ( overridesLeft && overrideValue.GetName() == childLabel )
+        {
+            if ( !overrideValue.IsNull() )
+                childValue = overrideValue;
+            else
+                childValue = curChild->GetValue();
+            ++node;
+            if ( node != valueOverrides->end() )
+                overrideValue = *node;
+            else
+                overridesLeft = false;
+        }
+        else
+        {
+            childValue = curChild->GetValue();
+        }
+
+        wxString s;
+        if ( !childValue.IsNull() )
+        {
+            if ( overridesLeft &&
+                 curChild->HasFlag(wxPG_PROP_COMPOSED_VALUE) &&
+                 childValue.GetType() == wxPG_VARIANT_TYPE_LIST )
+            {
+                wxVariantList& childList = childValue.GetList();
+                DoGenerateComposedValue(s, argFlags|wxPG_COMPOSITE_FRAGMENT,
+                                        &childList, childResults);
+            }
+            else
+            {
+                s = curChild->ValueToString(childValue,
+                                            argFlags|wxPG_COMPOSITE_FRAGMENT);
+            }
+        }
+ 
+        if ( childResults && curChild->GetChildCount() )
+            (*childResults)[curChild->GetName()] = s;
+
+        bool skip = false;
+        if ( (argFlags & wxPG_UNEDITABLE_COMPOSITE_FRAGMENT) && !s.length() )
+            skip = true;
+
+        if ( !curChild->GetChildCount() || skip )
+            text += s;
+        else
+            text += wxS("[") + s + wxS("]");
+
+        if ( i < iMaxMinusOne )
+        {
+            if ( text.length() > PWC_CHILD_SUMMARY_CHAR_LIMIT &&
+                 !(argFlags & wxPG_EDITABLE_VALUE) &&
+                 !(argFlags & wxPG_FULL_VALUE) )
+                break;
+
+            if ( !skip )
+            {
+                if ( !curChild->GetChildCount() )
+                    text += wxS("; ");
+                else
+                    text += wxS(" ");
+            }
+
+            curChild = m_children[i+1];
+        }
+    }
+
+    if ( (unsigned int)i < m_children.size() )
+    {
+        if ( !text.EndsWith(wxS("; ")) )
+            text += wxS("; ...");
+        else
+            text += wxS("...");
+    }
+}
+
+wxString wxPGProperty::ValueToString( wxVariant& WXUNUSED(value),
+                                      int argFlags ) const
+{
+    wxCHECK_MSG( GetChildCount() > 0,
+                 wxString(),
+                 "If user property does not have any children, it must "
+                 "override GetValueAsString" );
+
+    // FIXME: Currently code below only works if value is actually m_value
+    wxASSERT_MSG( argFlags & wxPG_VALUE_IS_CURRENT,
+                  "Sorry, currently default wxPGProperty::ValueToString() "
+                  "implementation only works if value is m_value." );
+
+    wxString text;
+    DoGenerateComposedValue(text, argFlags);
+    return text;
+}
+
+wxString wxPGProperty::GetValueAsString( int argFlags ) const
+{
+#if wxPG_COMPATIBILITY_1_4
+    // This is backwards compatibility test
+    // That is, to make sure this function is not overridden
+    // (instead, ValueToString() should be).
+    if ( argFlags == 0xFFFF )
+    {
+        // Do not override! (for backwards compliancy)
+        return g_invalidStringContent;
+    }
+#endif
+
+    if ( IsValueUnspecified() )
+        return wxEmptyString;
+
+    if ( m_commonValue == -1 )
+    {
+        wxVariant value(GetValue());
+        return ValueToString(value, argFlags|wxPG_VALUE_IS_CURRENT);
+    }
+
+    //
+    // Return common value's string representation
+    wxPropertyGrid* pg = GetGrid();
+    const wxPGCommonValue* cv = pg->GetCommonValue(m_commonValue);
+
+    if ( argFlags & wxPG_FULL_VALUE )
+    {
+        return cv->GetLabel();
+    }
+    else if ( argFlags & wxPG_EDITABLE_VALUE )
+    {
+        return cv->GetEditableText();
+    }
+    else
+    {
+        return cv->GetLabel();
+    }
+}
+
+wxString wxPGProperty::GetValueString( int argFlags ) const
+{
+    return GetValueAsString(argFlags);
+}
+
+bool wxPGProperty::IntToValue( wxVariant& variant, int number, int WXUNUSED(argFlags) ) const
+{
+    variant = (long)number;
+    return true;
+}
+
+// Convert semicolon delimited tokens into child values.
+bool wxPGProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
+{
+    if ( !GetChildCount() )
+        return false;
+
+    unsigned int curChild = 0;
+
+    unsigned int iMax = m_children.size();
+
+    if ( iMax > PWC_CHILD_SUMMARY_LIMIT &&
+         !(argFlags & wxPG_FULL_VALUE) )
+        iMax = PWC_CHILD_SUMMARY_LIMIT;
+
+    bool changed = false;
+
+    wxString token;
+    size_t pos = 0;
+
+    // Its best only to add non-empty group items
+    bool addOnlyIfNotEmpty = false;
+    const wxChar delimeter = wxS(';');
+
+    size_t tokenStart = 0xFFFFFF;
+
+    wxVariantList temp_list;
+    wxVariant list(temp_list);
+
+    int propagatedFlags = argFlags & (wxPG_REPORT_ERROR|wxPG_PROGRAMMATIC_VALUE);
+
+    wxLogTrace("propgrid",
+               wxT(">> %s.StringToValue('%s')"), GetLabel(), text);
+
+    wxString::const_iterator it = text.begin();
+    wxUniChar a;
+
+    if ( it != text.end() )
+        a = *it;
+    else
+        a = 0;
+
+    for ( ;; )
+    {
+        // How many units we iterate string forward at the end of loop?
+        // We need to keep track of this or risk going to negative
+        // with it-- operation.
+        unsigned int strPosIncrement = 1;
+
+        if ( tokenStart != 0xFFFFFF )
+        {
+            // Token is running
+            if ( a == delimeter || a == 0 )
+            {
+                token = text.substr(tokenStart,pos-tokenStart);
+                token.Trim(true);
+                size_t len = token.length();
+
+                if ( !addOnlyIfNotEmpty || len > 0 )
+                {
+                    const wxPGProperty* child = Item(curChild);
+                    wxVariant variant(child->GetValue());
+                    wxString childName = child->GetBaseName();
+
+                    wxLogTrace("propgrid",
+                               wxT("token = '%s', child = %s"),
+                               token, childName);
+
+                    // Add only if editable or setting programmatically
+                    if ( (argFlags & wxPG_PROGRAMMATIC_VALUE) ||
+                         !child->HasFlag(wxPG_PROP_DISABLED|wxPG_PROP_READONLY) )
+                    {
+                        if ( len > 0 )
+                        {
+                            if ( child->StringToValue(variant, token,
+                                 propagatedFlags|wxPG_COMPOSITE_FRAGMENT) )
+                            {
+                                // We really need to set the variant's name
+                                // *after* child->StringToValue() has been
+                                // called, since variant's value may be set by
+                                // assigning another variant into it, which
+                                // then usually causes name to be copied (ie.
+                                // usually cleared) as well. wxBoolProperty
+                                // being case in point with its use of
+                                // wxPGVariant_Bool macro as an optimization.
+                                variant.SetName(childName);
+                                list.Append(variant);
+
+                                changed = true;
+                            }
+                        }
+                        else
+                        {
+                            // Empty, becomes unspecified
+                            variant.MakeNull();
+                            variant.SetName(childName);
+                            list.Append(variant);
+                            changed = true;
+                        }
+                    }
+
+                    curChild++;
+                    if ( curChild >= iMax )
+                        break;
+                }
+
+                tokenStart = 0xFFFFFF;
+            }
+        }
+        else
+        {
+            // Token is not running
+            if ( a != wxS(' ') )
+            {
+
+                addOnlyIfNotEmpty = false;
+
+                // Is this a group of tokens?
+                if ( a == wxS('[') )
+                {
+                    int depth = 1;
+
+                    if ( it != text.end() ) ++it;
+                    pos++;
+                    size_t startPos = pos;
+
+                    // Group item - find end
+                    while ( it != text.end() && depth > 0 )
+                    {
+                        a = *it;
+                        ++it;
+                        pos++;
+
+                        if ( a == wxS(']') )
+                            depth--;
+                        else if ( a == wxS('[') )
+                            depth++;
+                    }
+
+                    token = text.substr(startPos,pos-startPos-1);
+
+                    if ( !token.length() )
+                        break;
+
+                    const wxPGProperty* child = Item(curChild);
+
+                    wxVariant oldChildValue = child->GetValue();
+                    wxVariant variant(oldChildValue);
+
+                    if ( (argFlags & wxPG_PROGRAMMATIC_VALUE) ||
+                         !child->HasFlag(wxPG_PROP_DISABLED|wxPG_PROP_READONLY) )
+                    {
+                        wxString childName = child->GetBaseName();
+
+                        bool stvRes = child->StringToValue( variant, token,
+                                                            propagatedFlags );
+                        if ( stvRes || (variant != oldChildValue) )
+                        {
+                            variant.SetName(childName);
+                            list.Append(variant);
+
+                            changed = true;
+                        }
+                        else
+                        {
+                            // No changes...
+                        }
+                    }
+
+                    curChild++;
+                    if ( curChild >= iMax )
+                        break;
+
+                    addOnlyIfNotEmpty = true;
+
+                    tokenStart = 0xFFFFFF;
+                }
+                else
+                {
+                    tokenStart = pos;
+
+                    if ( a == delimeter )
+                        strPosIncrement -= 1;
+                }
+            }
+        }
+
+        if ( a == 0 )
+            break;
+
+        it += strPosIncrement;
+
+        if ( it != text.end() )
+        {
+            a = *it;
+        }
+        else
+        {
+            a = 0;
+        }
+
+        pos += strPosIncrement;
+    }
+
+    if ( changed )
+        variant = list;
+
+    return changed;
+}
+
+bool wxPGProperty::SetValueFromString( const wxString& text, int argFlags )
+{
+    wxVariant variant(m_value);
+    bool res = StringToValue(variant, text, argFlags);
+    if ( res )
+        SetValue(variant);
+    return res;
+}
+
+bool wxPGProperty::SetValueFromInt( long number, int argFlags )
+{
+    wxVariant variant(m_value);
+    bool res = IntToValue(variant, number, argFlags);
+    if ( res )
+        SetValue(variant);
+    return res;
+}
+
+wxSize wxPGProperty::OnMeasureImage( int WXUNUSED(item) ) const
+{
+    if ( m_valueBitmap )
+        return wxSize(m_valueBitmap->GetWidth(),-1);
+
+    return wxSize(0,0);
+}
+
+int wxPGProperty::GetImageOffset( int imageWidth ) const
+{
+    int imageOffset = 0;
+
+    if ( imageWidth )
+    {
+        // Do not increment offset too much for wide images
+        if ( imageWidth <= (wxPG_CUSTOM_IMAGE_WIDTH+5) )
+            imageOffset = imageWidth + DEFAULT_IMAGE_OFFSET_INCREMENT;
+        else
+            imageOffset = imageWidth + 1;
+    }
+
+    return imageOffset;
+}
+
+wxPGCellRenderer* wxPGProperty::GetCellRenderer( int WXUNUSED(column) ) const
+{
+    return wxPGGlobalVars->m_defaultRenderer;
+}
+
+void wxPGProperty::OnCustomPaint( wxDC& dc,
+                                  const wxRect& rect,
+                                  wxPGPaintData& )
+{
+    wxBitmap* bmp = m_valueBitmap;
+
+    wxCHECK_RET( bmp && bmp->Ok(), wxT("invalid bitmap") );
+
+    wxCHECK_RET( rect.x >= 0, wxT("unexpected measure call") );
+
+    dc.DrawBitmap(*bmp,rect.x,rect.y);
+}
+
+const wxPGEditor* wxPGProperty::DoGetEditorClass() const
+{
+    return wxPGEditor_TextCtrl;
+}
+
+// Default extra property event handling - that is, none at all.
+bool wxPGProperty::OnEvent( wxPropertyGrid*, wxWindow*, wxEvent& )
+{
+    return false;
+}
+
+
+void wxPGProperty::SetValue( wxVariant value, wxVariant* pList, int flags )
+{
+    // If auto unspecified values are not wanted (via window or property style),
+    // then get default value instead of wxNullVariant.
+    if ( value.IsNull() && (flags & wxPG_SETVAL_BY_USER) &&
+         !UsesAutoUnspecified() )
+    {
+        value = GetDefaultValue();
+    }
+
+    if ( !value.IsNull() )
+    {
+        wxVariant tempListVariant;
+
+        SetCommonValue(-1);
+        // List variants are reserved a special purpose
+        // as intermediate containers for child values
+        // of properties with children.
+        if ( value.GetType() == wxPG_VARIANT_TYPE_LIST )
+        {
+            //
+            // However, situation is different for composed string properties
+            if ( HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+            {
+                tempListVariant = value;
+                pList = &tempListVariant;
+            }
+
+            wxVariant newValue;
+            AdaptListToValue(value, &newValue);
+            value = newValue;
+            //wxLogDebug(wxT(">> %s.SetValue() adapted list value to type '%s'"),GetName().c_str(),value.GetType().c_str());
+        }
+
+        if ( HasFlag( wxPG_PROP_AGGREGATE) )
+            flags |= wxPG_SETVAL_AGGREGATED;
+
+        if ( pList && !pList->IsNull() )
+        {
+            wxASSERT( pList->GetType() == wxPG_VARIANT_TYPE_LIST );
+            wxASSERT( GetChildCount() );
+            wxASSERT( !IsCategory() );
+
+            wxVariantList& list = pList->GetList();
+            wxVariantList::iterator node;
+            unsigned int i = 0;
+
+            //wxLogDebug(wxT(">> %s.SetValue() pList parsing"),GetName().c_str());
+
+            // Children in list can be in any order, but we will give hint to
+            // GetPropertyByNameWH(). This optimizes for full list parsing.
+            for ( node = list.begin(); node != list.end(); ++node )
+            {
+                wxVariant& childValue = *((wxVariant*)*node);
+                wxPGProperty* child = GetPropertyByNameWH(childValue.GetName(), i);
+                if ( child )
+                {
+                    //wxLogDebug(wxT("%i: child = %s, childValue.GetType()=%s"),i,child->GetBaseName().c_str(),childValue.GetType().c_str());
+                    if ( childValue.GetType() == wxPG_VARIANT_TYPE_LIST )
+                    {
+                        if ( child->HasFlag(wxPG_PROP_AGGREGATE) && !(flags & wxPG_SETVAL_AGGREGATED) )
+                        {
+                            wxVariant listRefCopy = childValue;
+                            child->SetValue(childValue, &listRefCopy, flags|wxPG_SETVAL_FROM_PARENT);
+                        }
+                        else
+                        {
+                            wxVariant oldVal = child->GetValue();
+                            child->SetValue(oldVal, &childValue, flags|wxPG_SETVAL_FROM_PARENT);
+                        }
+                    }
+                    else if ( child->GetValue() != childValue )
+                    {
+                        // For aggregate properties, we will trust RefreshChildren()
+                        // to update child values.
+                        if ( !HasFlag(wxPG_PROP_AGGREGATE) )
+                            child->SetValue(childValue, NULL, flags|wxPG_SETVAL_FROM_PARENT);
+                        if ( flags & wxPG_SETVAL_BY_USER )
+                            child->SetFlag(wxPG_PROP_MODIFIED);
+                    }
+                }
+                i++;
+            }
+        }
+
+        if ( !value.IsNull() )
+        {
+            m_value = value;
+            OnSetValue();
+        }
+
+        if ( flags & wxPG_SETVAL_BY_USER )
+            SetFlag(wxPG_PROP_MODIFIED);
+
+        if ( HasFlag(wxPG_PROP_AGGREGATE) )
+            RefreshChildren();
+    }
+    else
+    {
+        if ( m_commonValue != -1 )
+        {
+            wxPropertyGrid* pg = GetGrid();
+            if ( !pg || m_commonValue != pg->GetUnspecifiedCommonValue() )
+                SetCommonValue(-1);
+        }
+
+        m_value = value;
+
+        // Set children to unspecified, but only if aggregate or
+        // value is <composed>
+        if ( AreChildrenComponents() )
+        {
+            unsigned int i;
+            for ( i=0; i<GetChildCount(); i++ )
+                Item(i)->SetValue(value, NULL, flags|wxPG_SETVAL_FROM_PARENT);
+        }
+    }
+
+    if ( !(flags & wxPG_SETVAL_FROM_PARENT) )
+        UpdateParentValues();
+
+    //
+    // Update editor control
+    //
+
+    // We need to check for these, otherwise GetGrid() may fail.
+    if ( flags & wxPG_SETVAL_REFRESH_EDITOR )
+    {
+        RefreshEditor();
+        wxPropertyGrid* pg = GetGridIfDisplayed();
+        if ( pg )
+            pg->DrawItemAndValueRelated(this);
+    }
+}
+
+
+void wxPGProperty::SetValueInEvent( wxVariant value ) const
+{
+    GetGrid()->ValueChangeInEvent(value);
+}
+
+void wxPGProperty::SetFlagRecursively( FlagType flag, bool set )
+{
+    if ( set )
+        SetFlag(flag);
+    else
+        ClearFlag(flag);
+
+    unsigned int i;
+    for ( i = 0; i < GetChildCount(); i++ )
+        Item(i)->SetFlagRecursively(flag, set);
+}
+
+void wxPGProperty::RefreshEditor()
+{
+    if ( !m_parent )
+        return;
+
+    wxPropertyGrid* pg = GetGrid();
+    if ( pg && pg->GetSelectedProperty() == this )
+        pg->RefreshEditor();
+}
+
+wxVariant wxPGProperty::GetDefaultValue() const
+{
+    wxVariant defVal = GetAttribute(wxS("DefaultValue"));
+    if ( !defVal.IsNull() )
+        return defVal;
+
+    wxVariant value = GetValue();
+
+    if ( !value.IsNull() )
+    {
+        wxString valueType(value.GetType());
+
+        if ( valueType == wxPG_VARIANT_TYPE_LONG )
+            return wxPGVariant_Zero;
+        if ( valueType == wxPG_VARIANT_TYPE_STRING )
+            return wxPGVariant_EmptyString;
+        if ( valueType == wxPG_VARIANT_TYPE_BOOL )
+            return wxPGVariant_False;
+        if ( valueType == wxPG_VARIANT_TYPE_DOUBLE )
+            return wxVariant(0.0);
+        if ( valueType == wxPG_VARIANT_TYPE_ARRSTRING )
+            return wxVariant(wxArrayString());
+        if ( valueType == wxS("wxLongLong") )
+            return WXVARIANT(wxLongLong(0));
+        if ( valueType == wxS("wxULongLong") )
+            return WXVARIANT(wxULongLong(0));
+        if ( valueType == wxS("wxColour") )
+            return WXVARIANT(*wxBLACK);
+#if wxUSE_DATETIME
+        if ( valueType == wxPG_VARIANT_TYPE_DATETIME )
+            return wxVariant(wxDateTime::Now());
+#endif
+        if ( valueType == wxS("wxFont") )
+            return WXVARIANT(*wxNORMAL_FONT);
+        if ( valueType == wxS("wxPoint") )
+            return WXVARIANT(wxPoint(0, 0));
+        if ( valueType == wxS("wxSize") )
+            return WXVARIANT(wxSize(0, 0));
+    }
+
+    return wxVariant();
+}
+
+void wxPGProperty::EnsureCells( unsigned int column )
+{
+    if ( column >= m_cells.size() )
+    {
+        // Fill empty slots with default cells
+        wxPropertyGrid* pg = GetGrid();
+        wxPGCell defaultCell;
+
+        if ( !HasFlag(wxPG_PROP_CATEGORY) )
+            defaultCell = pg->GetPropertyDefaultCell();
+        else
+            defaultCell = pg->GetCategoryDefaultCell();
+
+        // TODO: Replace with resize() call
+        unsigned int cellCountMax = column+1;
+
+        for ( unsigned int i=m_cells.size(); i<cellCountMax; i++ )
+            m_cells.push_back(defaultCell);
+    }
+}
+
+void wxPGProperty::SetCell( int column,
+                            const wxPGCell& cell )
+{
+    EnsureCells(column);
+
+    m_cells[column] = cell;
+}
+
+void wxPGProperty::AdaptiveSetCell( unsigned int firstCol,
+                                    unsigned int lastCol,
+                                    const wxPGCell& cell,
+                                    const wxPGCell& srcData,
+                                    wxPGCellData* unmodCellData,
+                                    FlagType ignoreWithFlags,
+                                    bool recursively )
+{
+    //
+    // Sets cell in memory optimizing fashion. That is, if
+    // current cell data matches unmodCellData, we will
+    // simply get reference to data from cell. Otherwise,
+    // cell information from srcData is merged into current.
+    //
+
+    if ( !(m_flags & ignoreWithFlags) && !IsRoot() )
+    {
+        EnsureCells(lastCol);
+
+        for ( unsigned int col=firstCol; col<=lastCol; col++ )
+        {
+            if ( m_cells[col].GetData() == unmodCellData )
+            {
+                // Data matches... use cell directly
+                m_cells[col] = cell;
+            }
+            else
+            {
+                // Data did not match... merge valid information
+                m_cells[col].MergeFrom(srcData);
+            }
+        }
+    }
+
+    if ( recursively )
+    {
+        for ( unsigned int i=0; i<GetChildCount(); i++ )
+            Item(i)->AdaptiveSetCell( firstCol,
+                                      lastCol,
+                                      cell,
+                                      srcData,
+                                      unmodCellData,
+                                      ignoreWithFlags,
+                                      recursively );
+    }
+}
+
+const wxPGCell& wxPGProperty::GetCell( unsigned int column ) const
+{
+    if ( m_cells.size() > column )
+        return m_cells[column];
+
+    wxPropertyGrid* pg = GetGrid();
+
+    if ( IsCategory() )
+        return pg->GetCategoryDefaultCell();
+
+    return pg->GetPropertyDefaultCell();
+}
+
+wxPGCell& wxPGProperty::GetCell( unsigned int column )
+{
+    EnsureCells(column);
+    return m_cells[column];
+}
+
+void wxPGProperty::SetBackgroundColour( const wxColour& colour,
+                                        bool recursively )
+{
+    wxPGProperty* firstProp = this;
+
+    //
+    // If category is tried to set recursively, skip it and only
+    // affect the children.
+    if ( recursively )
+    {
+        while ( firstProp->IsCategory() )
+        {
+            if ( !firstProp->GetChildCount() )
+                return;
+            firstProp = firstProp->Item(0);
+        }
+    }
+
+    wxPGCell& firstCell = firstProp->GetCell(0);
+    wxPGCellData* firstCellData = firstCell.GetData();
+
+    wxPGCell newCell(firstCell);
+    newCell.SetBgCol(colour);
+    wxPGCell srcCell;
+    srcCell.SetBgCol(colour);
+
+    AdaptiveSetCell( 0,
+                     GetParentState()->GetColumnCount()-1,
+                     newCell,
+                     srcCell,
+                     firstCellData,
+                     recursively ? wxPG_PROP_CATEGORY : 0,
+                     recursively );
+}
+
+void wxPGProperty::SetTextColour( const wxColour& colour,
+                                  bool recursively )
+{
+    wxPGProperty* firstProp = this;
+
+    //
+    // If category is tried to set recursively, skip it and only
+    // affect the children.
+    if ( recursively )
+    {
+        while ( firstProp->IsCategory() )
+        {
+            if ( !firstProp->GetChildCount() )
+                return;
+            firstProp = firstProp->Item(0);
+        }
+    }
+
+    wxPGCell& firstCell = firstProp->GetCell(0);
+    wxPGCellData* firstCellData = firstCell.GetData();
+
+    wxPGCell newCell(firstCell);
+    newCell.SetFgCol(colour);
+    wxPGCell srcCell;
+    srcCell.SetFgCol(colour);
+
+    AdaptiveSetCell( 0,
+                     GetParentState()->GetColumnCount()-1,
+                     newCell,
+                     srcCell,
+                     firstCellData,
+                     recursively ? wxPG_PROP_CATEGORY : 0,
+                     recursively );
+}
+
+wxPGEditorDialogAdapter* wxPGProperty::GetEditorDialog() const
+{
+    return NULL;
+}
+
+bool wxPGProperty::DoSetAttribute( const wxString& WXUNUSED(name), wxVariant& WXUNUSED(value) )
+{
+    return false;
+}
+
+void wxPGProperty::SetAttribute( const wxString& name, wxVariant value )
+{
+    if ( DoSetAttribute( name, value ) )
+    {
+        // Support working without grid, when possible
+        if ( wxPGGlobalVars->HasExtraStyle( wxPG_EX_WRITEONLY_BUILTIN_ATTRIBUTES ) )
+            return;
+    }
+
+    m_attributes.Set( name, value );
+}
+
+void wxPGProperty::SetAttributes( const wxPGAttributeStorage& attributes )
+{
+    wxPGAttributeStorage::const_iterator it = attributes.StartIteration();
+    wxVariant variant;
+
+    while ( attributes.GetNext(it, variant) )
+        SetAttribute( variant.GetName(), variant );
+}
+
+wxVariant wxPGProperty::DoGetAttribute( const wxString& WXUNUSED(name) ) const
+{
+    return wxVariant();
+}
+
+
+wxVariant wxPGProperty::GetAttribute( const wxString& name ) const
+{
+    return m_attributes.FindValue(name);
+}
+
+wxString wxPGProperty::GetAttribute( const wxString& name, const wxString& defVal ) const
+{
+    wxVariant variant = m_attributes.FindValue(name);
+
+    if ( !variant.IsNull() )
+        return variant.GetString();
+
+    return defVal;
+}
+
+long wxPGProperty::GetAttributeAsLong( const wxString& name, long defVal ) const
+{
+    wxVariant variant = m_attributes.FindValue(name);
+
+    return wxPGVariantToInt(variant, defVal);
+}
+
+double wxPGProperty::GetAttributeAsDouble( const wxString& name, double defVal ) const
+{
+    double retVal;
+    wxVariant variant = m_attributes.FindValue(name);
+
+    if ( wxPGVariantToDouble(variant, &retVal) )
+        return retVal;
+
+    return defVal;
+}
+
+wxVariant wxPGProperty::GetAttributesAsList() const
+{
+    wxVariantList tempList;
+    wxVariant v( tempList, wxString::Format(wxS("@%s@attr"),m_name.c_str()) );
+
+    wxPGAttributeStorage::const_iterator it = m_attributes.StartIteration();
+    wxVariant variant;
+
+    while ( m_attributes.GetNext(it, variant) )
+        v.Append(variant);
+
+    return v;
+}
+
+// Slots of utility flags are NULL
+const unsigned int gs_propFlagToStringSize = 14;
+
+static const wxChar* gs_propFlagToString[gs_propFlagToStringSize] = {
+    NULL,
+    wxT("DISABLED"),
+    wxT("HIDDEN"),
+    NULL,
+    wxT("NOEDITOR"),
+    wxT("COLLAPSED"),
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
+wxString wxPGProperty::GetFlagsAsString( FlagType flagsMask ) const
+{
+    wxString s;
+    int relevantFlags = m_flags & flagsMask & wxPG_STRING_STORED_FLAGS;
+    FlagType a = 1;
+
+    unsigned int i = 0;
+    for ( i=0; i<gs_propFlagToStringSize; i++ )
+    {
+        if ( relevantFlags & a )
+        {
+            const wxChar* fs = gs_propFlagToString[i];
+            wxASSERT(fs);
+            if ( s.length() )
+                s << wxS("|");
+            s << fs;
+        }
+        a = a << 1;
+    }
+
+    return s;
+}
+
+void wxPGProperty::SetFlagsFromString( const wxString& str )
+{
+    FlagType flags = 0;
+
+    WX_PG_TOKENIZER1_BEGIN(str, wxS('|'))
+        unsigned int i;
+        for ( i=0; i<gs_propFlagToStringSize; i++ )
+        {
+            const wxChar* fs = gs_propFlagToString[i];
+            if ( fs && str == fs )
+            {
+                flags |= (1<<i);
+                break;
+            }
+        }
+    WX_PG_TOKENIZER1_END()
+
+    m_flags = (m_flags & ~wxPG_STRING_STORED_FLAGS) | flags;
+}
+
+wxValidator* wxPGProperty::DoGetValidator() const
+{
+    return NULL;
+}
+
+int wxPGProperty::InsertChoice( const wxString& label, int index, int value )
+{
+    wxPropertyGrid* pg = GetGrid();
+    int sel = GetChoiceSelection();
+
+    int newSel = sel;
+
+    if ( index == wxNOT_FOUND )
+        index = m_choices.GetCount();
+
+    if ( index <= sel )
+        newSel++;
+
+    m_choices.Insert(label, index, value);
+
+    if ( sel != newSel )
+        SetChoiceSelection(newSel);
+
+    if ( this == pg->GetSelection() )
+        GetEditorClass()->InsertItem(pg->GetEditorControl(),label,index);
+
+    return index;
+}
+
+
+void wxPGProperty::DeleteChoice( int index )
+{
+    wxPropertyGrid* pg = GetGrid();
+
+    int sel = GetChoiceSelection();
+    int newSel = sel;
+
+    // Adjust current value
+    if ( sel == index )
+    {
+        SetValueToUnspecified();
+        newSel = 0;
+    }
+    else if ( index < sel )
+    {
+        newSel--;
+    }
+
+    m_choices.RemoveAt(index);
+
+    if ( sel != newSel )
+        SetChoiceSelection(newSel);
+
+    if ( this == pg->GetSelection() )
+        GetEditorClass()->DeleteItem(pg->GetEditorControl(), index);
+}
+
+int wxPGProperty::GetChoiceSelection() const
+{
+    wxVariant value = GetValue();
+    wxString valueType = value.GetType();
+    int index = wxNOT_FOUND;
+
+    if ( IsValueUnspecified() || !m_choices.GetCount() )
+        return wxNOT_FOUND;
+
+    if ( valueType == wxPG_VARIANT_TYPE_LONG )
+    {
+        index = value.GetLong();
+    }
+    else if ( valueType == wxPG_VARIANT_TYPE_STRING )
+    {
+        index = m_choices.Index(value.GetString());
+    }
+    else if ( valueType == wxPG_VARIANT_TYPE_BOOL )
+    {
+        index = value.GetBool()? 1 : 0;
+    }
+
+    return index;
+}
+
+void wxPGProperty::SetChoiceSelection( int newValue )
+{
+    // Changes value of a property with choices, but only
+    // works if the value type is long or string.
+    wxString valueType = GetValue().GetType();
+
+    wxCHECK_RET( m_choices.IsOk(), wxT("invalid choiceinfo") );
+
+    if ( valueType == wxPG_VARIANT_TYPE_STRING )
+    {
+        SetValue( m_choices.GetLabel(newValue) );
+    }
+    else  // if ( valueType == wxPG_VARIANT_TYPE_LONG )
+    {
+        SetValue( (long) newValue );
+    }
+}
+
+bool wxPGProperty::SetChoices( wxPGChoices& choices )
+{
+    m_choices.Assign(choices);
+
+    {
+        // This may be needed to trigger some initialization
+        // (but don't do it if property is somewhat uninitialized)
+        wxVariant defVal = GetDefaultValue();
+        if ( defVal.IsNull() )
+            return false;
+
+        SetValue(defVal);
+    }
+
+    return true;
+}
+
+
+const wxPGEditor* wxPGProperty::GetEditorClass() const
+{
+    const wxPGEditor* editor;
+
+    if ( !m_customEditor )
+    {
+        editor = DoGetEditorClass();
+    }
+    else
+        editor = m_customEditor;
+
+    //
+    // Maybe override editor if common value specified
+    if ( GetDisplayedCommonValueCount() )
+    {
+        // TextCtrlAndButton -> ComboBoxAndButton
+        if ( editor->IsKindOf(CLASSINFO(wxPGTextCtrlAndButtonEditor)) )
+            editor = wxPGEditor_ChoiceAndButton;
+
+        // TextCtrl -> ComboBox
+        else if ( editor->IsKindOf(CLASSINFO(wxPGTextCtrlEditor)) )
+            editor = wxPGEditor_ComboBox;
+    }
+
+    return editor;
+}
+
+bool wxPGProperty::HasVisibleChildren() const
+{
+    unsigned int i;
+
+    for ( i=0; i<GetChildCount(); i++ )
+    {
+        wxPGProperty* child = Item(i);
+
+        if ( !child->HasFlag(wxPG_PROP_HIDDEN) )
+            return true;
+    }
+
+    return false;
+}
+
+bool wxPGProperty::RecreateEditor()
+{
+    wxPropertyGrid* pg = GetGrid();
+    wxASSERT(pg);
+
+    wxPGProperty* selected = pg->GetSelection();
+    if ( this == selected )
+    {
+        pg->DoSelectProperty(this, wxPG_SEL_FORCE);
+        return true;
+    }
+    return false;
+}
+
+
+void wxPGProperty::SetValueImage( wxBitmap& bmp )
+{
+    delete m_valueBitmap;
+
+    if ( &bmp && bmp.Ok() )
+    {
+        // Resize the image
+        wxSize maxSz = GetGrid()->GetImageSize();
+        wxSize imSz(bmp.GetWidth(),bmp.GetHeight());
+
+        if ( imSz.y != maxSz.y )
+        {
+            // Create a memory DC
+            wxBitmap* bmpNew = new wxBitmap(maxSz.x,maxSz.y,bmp.GetDepth());
+
+            wxMemoryDC dc;
+            dc.SelectObject(*bmpNew);
+
+            // Scale
+            // FIXME: This is ugly - use image or wait for scaling patch.
+            double scaleY = (double)maxSz.y / (double)imSz.y;
+
+            dc.SetUserScale(scaleY, scaleY);
+
+            dc.DrawBitmap(bmp, 0, 0);
+
+            m_valueBitmap = bmpNew;
+        }
+        else
+        {
+            m_valueBitmap = new wxBitmap(bmp);
+        }
+
+        m_flags |= wxPG_PROP_CUSTOMIMAGE;
+    }
+    else
+    {
+        m_valueBitmap = NULL;
+        m_flags &= ~(wxPG_PROP_CUSTOMIMAGE);
+    }
+}
+
+
+wxPGProperty* wxPGProperty::GetMainParent() const
+{
+    const wxPGProperty* curChild = this;
+    const wxPGProperty* curParent = m_parent;
+
+    while ( curParent && !curParent->IsCategory() )
+    {
+        curChild = curParent;
+        curParent = curParent->m_parent;
+    }
+
+    return (wxPGProperty*) curChild;
+}
+
+
+const wxPGProperty* wxPGProperty::GetLastVisibleSubItem() const
+{
+    //
+    // Returns last visible sub-item, recursively.
+    if ( !IsExpanded() || !GetChildCount() )
+        return this;
+
+    return Last()->GetLastVisibleSubItem();
+}
+
+
+bool wxPGProperty::IsVisible() const
+{
+    const wxPGProperty* parent;
+
+    if ( HasFlag(wxPG_PROP_HIDDEN) )
+        return false;
+
+    for ( parent = GetParent(); parent != NULL; parent = parent->GetParent() )
+    {
+        if ( !parent->IsExpanded() || parent->HasFlag(wxPG_PROP_HIDDEN) )
+            return false;
+    }
+
+    return true;
+}
+
+wxPropertyGrid* wxPGProperty::GetGridIfDisplayed() const
+{
+    wxPropertyGridPageState* state = GetParentState();
+    if ( !state )
+        return NULL;
+    wxPropertyGrid* propGrid = state->GetGrid();
+    if ( state == propGrid->GetState() )
+        return propGrid;
+    return NULL;
+}
+
+
+int wxPGProperty::GetY2( int lh ) const
+{
+    const wxPGProperty* parent;
+    const wxPGProperty* child = this;
+
+    int y = 0;
+
+    for ( parent = GetParent(); parent != NULL; parent = child->GetParent() )
+    {
+        if ( !parent->IsExpanded() )
+            return -1;
+        y += parent->GetChildrenHeight(lh, child->GetIndexInParent());
+        y += lh;
+        child = parent;
+    }
+
+    y -= lh;  // need to reduce one level
+
+    return y;
+}
+
+
+int wxPGProperty::GetY() const
+{
+    return GetY2(GetGrid()->GetRowHeight());
+}
+
+// This is used by Insert etc.
+void wxPGProperty::DoAddChild( wxPGProperty* prop, int index,
+                               bool correct_mode )
+{
+    if ( index < 0 || (size_t)index >= m_children.size() )
+    {
+        if ( correct_mode ) prop->m_arrIndex = m_children.size();
+        m_children.push_back( prop );
+    }
+    else
+    {
+        m_children.insert( m_children.begin()+index, prop);
+        if ( correct_mode ) FixIndicesOfChildren( index );
+    }
+
+    prop->m_parent = this;
+}
+
+void wxPGProperty::DoPreAddChild( int index, wxPGProperty* prop )
+{
+    wxASSERT_MSG( prop->GetBaseName().length(),
+                  "Property's children must have unique, non-empty "
+                  "names within their scope" );
+
+    prop->m_arrIndex = index;
+    m_children.insert( m_children.begin()+index,
+                       prop );
+
+    int custImgHeight = prop->OnMeasureImage().y;
+    if ( custImgHeight < 0 /*|| custImgHeight > 1*/ )
+        prop->m_flags |= wxPG_PROP_CUSTOMIMAGE;
+
+    prop->m_parent = this;
+}
+
+void wxPGProperty::AddPrivateChild( wxPGProperty* prop )
+{
+    if ( !(m_flags & wxPG_PROP_PARENTAL_FLAGS) )
+        SetParentalType(wxPG_PROP_AGGREGATE);
+
+    wxASSERT_MSG( (m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
+                    wxPG_PROP_AGGREGATE,
+                  "Do not mix up AddPrivateChild() calls with other "
+                  "property adders." );
+
+    DoPreAddChild( m_children.size(), prop );
+}
+
+#if wxPG_COMPATIBILITY_1_4
+void wxPGProperty::AddChild( wxPGProperty* prop )
+{
+    AddPrivateChild(prop);
+}
+#endif
+
+wxPGProperty* wxPGProperty::InsertChild( int index,
+                                         wxPGProperty* childProperty )
+{
+    if ( index < 0 )
+        index = m_children.size();
+
+    if ( m_parentState )
+    {
+        m_parentState->DoInsert(this, index, childProperty);
+    }
+    else
+    {
+        if ( !(m_flags & wxPG_PROP_PARENTAL_FLAGS) )
+            SetParentalType(wxPG_PROP_MISC_PARENT);
+
+        wxASSERT_MSG( (m_flags & wxPG_PROP_PARENTAL_FLAGS) ==
+                        wxPG_PROP_MISC_PARENT,
+                      "Do not mix up AddPrivateChild() calls with other "
+                      "property adders." );
+
+        DoPreAddChild( index, childProperty );
+    }
+
+    return childProperty;
+}
+
+void wxPGProperty::RemoveChild( wxPGProperty* p )
+{
+    wxArrayPGProperty::iterator it;
+    wxArrayPGProperty& children = m_children;
+
+    for ( it=children.begin(); it != children.end(); it++ )
+    {
+        if ( *it == p )
+        {
+            m_children.erase(it);
+            break;
+        }
+    }
+}
+
+void wxPGProperty::AdaptListToValue( wxVariant& list, wxVariant* value ) const
+{
+    wxASSERT( GetChildCount() );
+    wxASSERT( !IsCategory() );
+
+    *value = GetValue();
+
+    if ( !list.GetCount() )
+        return;
+
+    wxASSERT( GetChildCount() >= (unsigned int)list.GetCount() );
+
+    bool allChildrenSpecified;
+
+    // Don't fully update aggregate properties unless all children have
+    // specified value
+    if ( HasFlag(wxPG_PROP_AGGREGATE) )
+        allChildrenSpecified = AreAllChildrenSpecified(&list);
+    else
+        allChildrenSpecified = true;
+
+    wxVariant childValue = list[0];
+    unsigned int i;
+    unsigned int n = 0;
+
+    //wxLogDebug(wxT(">> %s.AdaptListToValue()"),GetBaseName().c_str());
+
+    for ( i=0; i<GetChildCount(); i++ )
+    {
+        const wxPGProperty* child = Item(i);
+
+        if ( childValue.GetName() == child->GetBaseName() )
+        {
+            //wxLogDebug(wxT("  %s(n=%i), %s"),childValue.GetName().c_str(),n,childValue.GetType().c_str());
+
+            if ( childValue.GetType() == wxPG_VARIANT_TYPE_LIST )
+            {
+                wxVariant cv2(child->GetValue());
+                child->AdaptListToValue(childValue, &cv2);
+                childValue = cv2;
+            }
+
+            if ( allChildrenSpecified )
+                ChildChanged(*value, i, childValue);
+            n++;
+            if ( n == (unsigned int)list.GetCount() )
+                break;
+            childValue = list[n];
+        }
+    }
+}
+
+
+void wxPGProperty::FixIndicesOfChildren( unsigned int starthere )
+{
+    size_t i;
+    for ( i=starthere;i<GetChildCount();i++)
+        Item(i)->m_arrIndex = i;
+}
+
+
+// Returns (direct) child property with given name (or NULL if not found)
+wxPGProperty* wxPGProperty::GetPropertyByName( const wxString& name ) const
+{
+    size_t i;
+
+    for ( i=0; i<GetChildCount(); i++ )
+    {
+        wxPGProperty* p = Item(i);
+        if ( p->m_name == name )
+            return p;
+    }
+
+    // Does it have point, then?
+    int pos = name.Find(wxS('.'));
+    if ( pos <= 0 )
+        return NULL;
+
+    wxPGProperty* p = GetPropertyByName(name. substr(0,pos));
+
+    if ( !p || !p->GetChildCount() )
+        return NULL;
+
+    return p->GetPropertyByName(name.substr(pos+1,name.length()-pos-1));
+}
+
+wxPGProperty* wxPGProperty::GetPropertyByNameWH( const wxString& name, unsigned int hintIndex ) const
+{
+    unsigned int i = hintIndex;
+
+    if ( i >= GetChildCount() )
+        i = 0;
+
+    unsigned int lastIndex = i - 1;
+
+    if ( lastIndex >= GetChildCount() )
+        lastIndex = GetChildCount() - 1;
+
+    for (;;)
+    {
+        wxPGProperty* p = Item(i);
+        if ( p->m_name == name )
+            return p;
+
+        if ( i == lastIndex )
+            break;
+
+        i++;
+        if ( i == GetChildCount() )
+            i = 0;
+    };
+
+    return NULL;
+}
+
+int wxPGProperty::GetChildrenHeight( int lh, int iMax_ ) const
+{
+    // Returns height of children, recursively, and
+    // by taking expanded/collapsed status into account.
+    //
+    // iMax is used when finding property y-positions.
+    //
+    unsigned int i = 0;
+    int h = 0;
+
+    if ( iMax_ == -1 )
+        iMax_ = GetChildCount();
+
+    unsigned int iMax = iMax_;
+
+    wxASSERT( iMax <= GetChildCount() );
+
+    if ( !IsExpanded() && GetParent() )
+        return 0;
+
+    while ( i < iMax )
+    {
+        wxPGProperty* pwc = (wxPGProperty*) Item(i);
+
+        if ( !pwc->HasFlag(wxPG_PROP_HIDDEN) )
+        {
+            if ( !pwc->IsExpanded() ||
+                 pwc->GetChildCount() == 0 )
+                h += lh;
+            else
+                h += pwc->GetChildrenHeight(lh) + lh;
+        }
+
+        i++;
+    }
+
+    return h;
+}
+
+wxPGProperty* wxPGProperty::GetItemAtY( unsigned int y, unsigned int lh, unsigned int* nextItemY ) const
+{
+    wxASSERT( nextItemY );
+
+    // Linear search at the moment
+    //
+    // nextItemY = y of next visible property, final value will be written back.
+    wxPGProperty* result = NULL;
+    wxPGProperty* current = NULL;
+    unsigned int iy = *nextItemY;
+    unsigned int i = 0;
+    unsigned int iMax = GetChildCount();
+
+    while ( i < iMax )
+    {
+        wxPGProperty* pwc = Item(i);
+
+        if ( !pwc->HasFlag(wxPG_PROP_HIDDEN) )
+        {
+            // Found?
+            if ( y < iy )
+            {
+                result = current;
+                break;
+            }
+
+            iy += lh;
+
+            if ( pwc->IsExpanded() &&
+                 pwc->GetChildCount() > 0 )
+            {
+                result = (wxPGProperty*) pwc->GetItemAtY( y, lh, &iy );
+                if ( result )
+                    break;
+            }
+
+            current = pwc;
+        }
+
+        i++;
+    }
+
+    // Found?
+    if ( !result && y < iy )
+        result = current;
+
+    *nextItemY = iy;
+
+    /*
+    if ( current )
+        wxLogDebug(wxT("%s::GetItemAtY(%i) -> %s"),this->GetLabel().c_str(),y,current->GetLabel().c_str());
+    else
+        wxLogDebug(wxT("%s::GetItemAtY(%i) -> NULL"),this->GetLabel().c_str(),y);
+    */
+
+    return (wxPGProperty*) result;
+}
+
+wxPGProperty* wxPGProperty::GetItemAtY( unsigned int y ) const
+{
+    unsigned int nextItemY;
+    return GetItemAtY(y, GetGrid()->GetRowHeight(), &nextItemY);
+}
+
+void wxPGProperty::Empty()
+{
+    size_t i;
+    if ( !HasFlag(wxPG_PROP_CHILDREN_ARE_COPIES) )
+    {
+        for ( i=0; i<GetChildCount(); i++ )
+        {
+            delete m_children[i];
+        }
+    }
+
+    m_children.clear();
+}
+
+void wxPGProperty::DeleteChildren()
+{
+    wxPropertyGridPageState* state = m_parentState;
+
+    while ( GetChildCount() )
+    {
+        wxPGProperty* child = Item(GetChildCount()-1);
+        state->DoDelete(child, true);
+    }
+}
+
+void wxPGProperty::ChildChanged( wxVariant& WXUNUSED(thisValue),
+                                 int WXUNUSED(childIndex),
+                                 wxVariant& WXUNUSED(childValue) ) const
+{
+}
+
+bool wxPGProperty::AreAllChildrenSpecified( wxVariant* pendingList ) const
+{
+    unsigned int i;
+
+    const wxVariantList* pList = NULL;
+    wxVariantList::const_iterator node;
+
+    if ( pendingList )
+    {
+        pList = &pendingList->GetList();
+        node = pList->begin();
+    }
+
+    for ( i=0; i<GetChildCount(); i++ )
+    {
+        wxPGProperty* child = Item(i);
+        const wxVariant* listValue = NULL;
+        wxVariant value;
+
+        if ( pendingList )
+        {
+            const wxString& childName = child->GetBaseName();
+
+            for ( ; node != pList->end(); ++node )
+            {
+                const wxVariant& item = *((const wxVariant*)*node);
+                if ( item.GetName() == childName )
+                {
+                    listValue = &item;
+                    value = item;
+                    break;
+                }
+            }
+        }
+
+        if ( !listValue )
+            value = child->GetValue();
+
+        if ( value.IsNull() )
+            return false;
+
+        // Check recursively
+        if ( child->GetChildCount() )
+        {
+            const wxVariant* childList = NULL;
+
+            if ( listValue && listValue->GetType() == wxPG_VARIANT_TYPE_LIST )
+                childList = listValue;
+
+            if ( !child->AreAllChildrenSpecified((wxVariant*)childList) )
+                return false;
+        }
+    }
+
+    return true;
+}
+
+wxPGProperty* wxPGProperty::UpdateParentValues()
+{
+    wxPGProperty* parent = m_parent;
+    if ( parent && parent->HasFlag(wxPG_PROP_COMPOSED_VALUE) &&
+         !parent->IsCategory() && !parent->IsRoot() )
+    {
+        wxString s;
+        parent->DoGenerateComposedValue(s);
+        parent->m_value = s;
+        return parent->UpdateParentValues();
+    }
+    return this;
+}
+
+bool wxPGProperty::IsTextEditable() const
+{
+    if ( HasFlag(wxPG_PROP_READONLY) )
+        return false;
+
+    if ( HasFlag(wxPG_PROP_NOEDITOR) &&
+         (GetChildCount() ||
+          wxString(GetEditorClass()->GetClassInfo()->GetClassName()).EndsWith(wxS("Button")))
+       )
+        return false;
+
+    return true;
+}
+
+// Call after fixed sub-properties added/removed after creation.
+// if oldSelInd >= 0 and < new max items, then selection is
+// moved to it. Note: oldSelInd -2 indicates that this property
+// should be selected.
+void wxPGProperty::SubPropsChanged( int oldSelInd )
+{
+    wxPropertyGridPageState* state = GetParentState();
+    wxPropertyGrid* grid = state->GetGrid();
+
+    //
+    // Re-repare children (recursively)
+    for ( unsigned int i=0; i<GetChildCount(); i++ )
+    {
+        wxPGProperty* child = Item(i);
+        child->InitAfterAdded(state, grid);
+    }
+
+    wxPGProperty* sel = NULL;
+    if ( oldSelInd >= (int)m_children.size() )
+        oldSelInd = (int)m_children.size() - 1;
+
+    if ( oldSelInd >= 0 )
+        sel = m_children[oldSelInd];
+    else if ( oldSelInd == -2 )
+        sel = this;
+
+    if ( sel )
+        state->DoSelectProperty(sel);
+
+    if ( state == grid->GetState() )
+    {
+        grid->GetPanel()->Refresh();
+    }
+}
+
+// -----------------------------------------------------------------------
+// wxPGRootProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxPGRootProperty,none,TextCtrl)
+IMPLEMENT_DYNAMIC_CLASS(wxPGRootProperty, wxPGProperty)
+
+
+wxPGRootProperty::wxPGRootProperty( const wxString& name )
+    : wxPGProperty()
+{
+    m_name = name;
+    m_label = m_name;
+    SetParentalType(0);
+    m_depth = 0;
+}
+
+
+wxPGRootProperty::~wxPGRootProperty()
+{
+}
+
+
+// -----------------------------------------------------------------------
+// wxPropertyCategory
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxPropertyCategory,none,TextCtrl)
+IMPLEMENT_DYNAMIC_CLASS(wxPropertyCategory, wxPGProperty)
+
+void wxPropertyCategory::Init()
+{
+    // don't set colour - prepareadditem method should do this
+    SetParentalType(wxPG_PROP_CATEGORY);
+    m_capFgColIndex = 1;
+    m_textExtent = -1;
+}
+
+wxPropertyCategory::wxPropertyCategory()
+    : wxPGProperty()
+{
+    Init();
+}
+
+
+wxPropertyCategory::wxPropertyCategory( const wxString &label, const wxString& name )
+    : wxPGProperty(label,name)
+{
+    Init();
+}
+
+
+wxPropertyCategory::~wxPropertyCategory()
+{
+}
+
+
+wxString wxPropertyCategory::ValueToString( wxVariant& WXUNUSED(value),
+                                            int WXUNUSED(argFlags) ) const
+{
+    return wxEmptyString;
+}
+
+int wxPropertyCategory::GetTextExtent( const wxWindow* wnd, const wxFont& font ) const
+{
+    if ( m_textExtent > 0 )
+        return m_textExtent;
+    int x = 0, y = 0;
+	((wxWindow*)wnd)->GetTextExtent( m_label, &x, &y, 0, 0, &font );
+    return x;
+}
+
+void wxPropertyCategory::CalculateTextExtent( wxWindow* wnd, const wxFont& font )
+{
+    int x = 0, y = 0;
+	wnd->GetTextExtent( m_label, &x, &y, 0, 0, &font );
+    m_textExtent = x;
+}
+
+// -----------------------------------------------------------------------
+// wxPGChoices
+// -----------------------------------------------------------------------
+
+wxPGChoiceEntry& wxPGChoices::Add( const wxString& label, int value )
+{
+    AllocExclusive();
+
+    wxPGChoiceEntry entry(label, value);
+    return m_data->Insert( -1, entry );
+}
+
+// -----------------------------------------------------------------------
+
+wxPGChoiceEntry& wxPGChoices::Add( const wxString& label, const wxBitmap& bitmap, int value )
+{
+    AllocExclusive();
+
+    wxPGChoiceEntry entry(label, value);
+    entry.SetBitmap(bitmap);
+    return m_data->Insert( -1, entry );
+}
+
+// -----------------------------------------------------------------------
+
+wxPGChoiceEntry& wxPGChoices::Insert( const wxPGChoiceEntry& entry, int index )
+{
+    AllocExclusive();
+
+    return m_data->Insert( index, entry );
+}
+
+// -----------------------------------------------------------------------
+
+wxPGChoiceEntry& wxPGChoices::Insert( const wxString& label, int index, int value )
+{
+    AllocExclusive();
+
+    wxPGChoiceEntry entry(label, value);
+    return m_data->Insert( index, entry );
+}
+
+// -----------------------------------------------------------------------
+
+wxPGChoiceEntry& wxPGChoices::AddAsSorted( const wxString& label, int value )
+{
+    AllocExclusive();
+
+    size_t index = 0;
+
+    while ( index < GetCount() )
+    {
+        int cmpRes = GetLabel(index).Cmp(label);
+        if ( cmpRes > 0 )
+            break;
+        index++;
+    }
+
+    wxPGChoiceEntry entry(label, value);
+    return m_data->Insert( index, entry );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::Add( const wxChar** labels, const ValArrItem* values )
+{
+    AllocExclusive();
+
+    unsigned int itemcount = 0;
+    const wxChar** p = &labels[0];
+    while ( *p ) { p++; itemcount++; }
+
+    unsigned int i;
+    for ( i = 0; i < itemcount; i++ )
+    {
+        int value = i;
+        if ( values )
+            value = values[i];
+        wxPGChoiceEntry entry(labels[i], value);
+        m_data->Insert( i, entry );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::Add( const wxArrayString& arr, const wxArrayInt& arrint )
+{
+    AllocExclusive();
+
+    unsigned int i;
+    unsigned int itemcount = arr.size();
+
+    for ( i = 0; i < itemcount; i++ )
+    {
+        int value = i;
+        if ( &arrint && arrint.size() )
+            value = arrint[i];
+        wxPGChoiceEntry entry(arr[i], value);
+        m_data->Insert( i, entry );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::RemoveAt(size_t nIndex, size_t count)
+{
+    AllocExclusive();
+
+    wxASSERT( m_data->m_refCount != 0xFFFFFFF );
+    m_data->m_items.erase(m_data->m_items.begin()+nIndex,
+                          m_data->m_items.begin()+nIndex+count);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::Clear()
+{
+    if ( m_data != wxPGChoicesEmptyData )
+    {
+        AllocExclusive();
+        m_data->Clear();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+int wxPGChoices::Index( const wxString& str ) const
+{
+    if ( IsOk() )
+    {
+        unsigned int i;
+        for ( i=0; i< m_data->GetCount(); i++ )
+        {
+            const wxPGChoiceEntry& entry = m_data->Item(i);
+            if ( entry.HasText() && entry.GetText() == str )
+                return i;
+        }
+    }
+    return -1;
+}
+
+// -----------------------------------------------------------------------
+
+int wxPGChoices::Index( int val ) const
+{
+    if ( IsOk() )
+    {
+        unsigned int i;
+        for ( i=0; i< m_data->GetCount(); i++ )
+        {
+            const wxPGChoiceEntry& entry = m_data->Item(i);
+            if ( entry.GetValue() == val )
+                return i;
+        }
+    }
+    return -1;
+}
+
+// -----------------------------------------------------------------------
+
+wxArrayString wxPGChoices::GetLabels() const
+{
+    wxArrayString arr;
+    unsigned int i;
+
+    if ( this && IsOk() )
+        for ( i=0; i<GetCount(); i++ )
+            arr.push_back(GetLabel(i));
+
+    return arr;
+}
+
+// -----------------------------------------------------------------------
+
+wxArrayInt wxPGChoices::GetValuesForStrings( const wxArrayString& strings ) const
+{
+    wxArrayInt arr;
+
+    if ( IsOk() )
+    {
+        unsigned int i;
+        for ( i=0; i< strings.size(); i++ )
+        {
+            int index = Index(strings[i]);
+            if ( index >= 0 )
+                arr.Add(GetValue(index));
+            else
+                arr.Add(wxPG_INVALID_VALUE);
+        }
+    }
+
+    return arr;
+}
+
+// -----------------------------------------------------------------------
+
+wxArrayInt wxPGChoices::GetIndicesForStrings( const wxArrayString& strings,
+                                              wxArrayString* unmatched ) const
+{
+    wxArrayInt arr;
+
+    if ( IsOk() )
+    {
+        unsigned int i;
+        for ( i=0; i< strings.size(); i++ )
+        {
+            const wxString& str = strings[i];
+            int index = Index(str);
+            if ( index >= 0 )
+                arr.Add(index);
+            else if ( unmatched )
+                unmatched->Add(str);
+        }
+    }
+
+    return arr;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::AllocExclusive()
+{
+    EnsureData();
+
+    if ( m_data->m_refCount != 1 )
+    {
+        wxPGChoicesData* data = new wxPGChoicesData();
+        data->CopyDataFrom(m_data);
+        Free();
+        m_data = data;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::AssignData( wxPGChoicesData* data )
+{
+    Free();
+
+    if ( data != wxPGChoicesEmptyData )
+    {
+        m_data = data;
+        data->m_refCount++;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::Init()
+{
+    m_data = wxPGChoicesEmptyData;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGChoices::Free()
+{
+    if ( m_data != wxPGChoicesEmptyData )
+    {
+        m_data->DecRef();
+        m_data = wxPGChoicesEmptyData;
+    }
+}
+
+// -----------------------------------------------------------------------
+// wxPGAttributeStorage
+// -----------------------------------------------------------------------
+
+wxPGAttributeStorage::wxPGAttributeStorage()
+{
+}
+
+wxPGAttributeStorage::~wxPGAttributeStorage()
+{
+    wxPGHashMapS2P::iterator it;
+
+    for ( it = m_map.begin(); it != m_map.end(); ++it )
+    {
+        wxVariantData* data = (wxVariantData*) it->second;
+        data->DecRef();
+    }
+}
+
+void wxPGAttributeStorage::Set( const wxString& name, const wxVariant& value )
+{
+    wxVariantData* data = value.GetData();
+
+    // Free old, if any
+    wxPGHashMapS2P::iterator it = m_map.find(name);
+    if ( it != m_map.end() )
+    {
+        ((wxVariantData*)it->second)->DecRef();
+
+        if ( !data )
+        {
+            // If Null variant, just remove from set
+            m_map.erase(it);
+            return;
+        }
+    }
+
+    if ( data )
+    {
+        data->IncRef();
+
+        m_map[name] = data;
+    }
+}
+
+#endif  // wxUSE_PROPGRID
Index: propgrid.cpp
===================================================================
--- propgrid.cpp	(revision 102)
+++ propgrid.cpp	(working copy)
@@ -1,5606 +1,5606 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/propgrid.cpp
-// Purpose:     wxPropertyGrid
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2004-09-25
-// RCS-ID:      $Id: propgrid.cpp 61014 2009-06-12 13:39:36Z JMS $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcmemory.h"
-    #include "wx/button.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/cursor.h"
-    #include "wx/dialog.h"
-    #include "wx/settings.h"
-    #include "wx/msgdlg.h"
-    #include "wx/choice.h"
-    #include "wx/stattext.h"
-    #include "wx/scrolwin.h"
-    #include "wx/dirdlg.h"
-    #include "wx/sizer.h"
-    #include "wx/textdlg.h"
-    #include "wx/filedlg.h"
-    #include "wx/statusbr.h"
-    #include "wx/intl.h"
-    #include "wx/frame.h"
-#endif
-
-
-// This define is necessary to prevent macro clearing
-#define __wxPG_SOURCE_FILE__
-
-#include "wx/propgrid/propgrid.h"
-#include "wx/propgrid/editors.h"
-
-#if wxPG_USE_RENDERER_NATIVE
-    #include "wx/renderer.h"
-#endif
-
-#include "wx/odcombo.h"
-
-#include "wx/timer.h"
-#include "wx/dcbuffer.h"
-#include "wx/clipbrd.h"
-#include "wx/dataobj.h"
-
-#ifdef __WXMSW__
-    #include "wx/msw/private.h"
-#endif
-
-// Two pics for the expand / collapse buttons.
-// Files are not supplied with this project (since it is
-// recommended to use either custom or native rendering).
-// If you want them, get wxTreeMultiCtrl by Jorgen Bodde,
-// and copy xpm files from archive to wxPropertyGrid src directory
-// (and also comment/undef wxPG_ICON_WIDTH in propGrid.h
-// and set wxPG_USE_RENDERER_NATIVE to 0).
-#ifndef wxPG_ICON_WIDTH
-  #if defined(__WXMAC__)
-    #include "mac_collapse.xpm"
-    #include "mac_expand.xpm"
-  #elif defined(__WXGTK__)
-    #include "linux_collapse.xpm"
-    #include "linux_expand.xpm"
-  #else
-    #include "default_collapse.xpm"
-    #include "default_expand.xpm"
-  #endif
-#endif
-
-
-//#define wxPG_TEXT_INDENT                4 // For the wxComboControl
-//#define wxPG_ALLOW_CLIPPING             1 // If 1, GetUpdateRegion() in OnPaint event handler is not ignored
-#define wxPG_GUTTER_DIV                 3 // gutter is max(iconwidth/gutter_div,gutter_min)
-#define wxPG_GUTTER_MIN                 3 // gutter before and after image of [+] or [-]
-#define wxPG_YSPACING_MIN               1
-#define wxPG_DEFAULT_VSPACING           2 // This matches .NET propertygrid's value,
-                                          // but causes normal combobox to spill out under MSW
-
-//#define wxPG_OPTIMAL_WIDTH              200 // Arbitrary
-
-//#define wxPG_MIN_SCROLLBAR_WIDTH        10 // Smallest scrollbar width on any platform
-                                           // Must be larger than largest control border
-                                           // width * 2.
-
-
-#define wxPG_DEFAULT_CURSOR             wxNullCursor
-
-
-//#define wxPG_NAT_CHOICE_BORDER_ANY   0
-
-//#define wxPG_HIDER_BUTTON_HEIGHT        25
-
-#define wxPG_PIXELS_PER_UNIT            m_lineHeight
-
-#ifdef wxPG_ICON_WIDTH
-  #define m_iconHeight m_iconWidth
-#endif
-
-//#define wxPG_TOOLTIP_DELAY              1000
-
-// -----------------------------------------------------------------------
-
-#if wxUSE_INTL
-void wxPropertyGrid::AutoGetTranslation ( bool enable )
-{
-    wxPGGlobalVars->m_autoGetTranslation = enable;
-}
-#else
-void wxPropertyGrid::AutoGetTranslation ( bool ) { }
-#endif
-
-// -----------------------------------------------------------------------
-
-const char wxPropertyGridNameStr[] = "wxPropertyGrid";
-
-// -----------------------------------------------------------------------
-// Statics in one class for easy destruction.
-// -----------------------------------------------------------------------
-
-#include "wx/module.h"
-
-class wxPGGlobalVarsClassManager : public wxModule
-{
-    DECLARE_DYNAMIC_CLASS(wxPGGlobalVarsClassManager)
-public:
-    wxPGGlobalVarsClassManager() {}
-    virtual bool OnInit() { wxPGGlobalVars = new wxPGGlobalVarsClass(); return true; }
-    virtual void OnExit() { delete wxPGGlobalVars; wxPGGlobalVars = NULL; }
-};
-
-IMPLEMENT_DYNAMIC_CLASS(wxPGGlobalVarsClassManager, wxModule)
-
-
-// When wxPG is loaded dynamically after the application is already running
-// then the built-in module system won't pick this one up.  Add it manually.
-void wxPGInitResourceModule()
-{
-    wxModule* module = new wxPGGlobalVarsClassManager;
-    module->Init();
-    wxModule::RegisterModule(module);
-}
-
-wxPGGlobalVarsClass* wxPGGlobalVars = NULL;
-
-
-wxPGGlobalVarsClass::wxPGGlobalVarsClass()
-{
-    wxPGProperty::sm_wxPG_LABEL = new wxString(wxPG_LABEL_STRING);
-
-    m_boolChoices.Add(_("False"));
-    m_boolChoices.Add(_("True"));
-
-    m_fontFamilyChoices = NULL;
-
-    m_defaultRenderer = new wxPGDefaultRenderer();
-
-    m_autoGetTranslation = false;
-
-    m_offline = 0;
-
-    m_extraStyle = 0;
-
-    wxVariant v;
-
-    // Prepare some shared variants
-    m_vEmptyString = wxString();
-    m_vZero = (long) 0;
-    m_vMinusOne = (long) -1;
-    m_vTrue = true;
-    m_vFalse = false;
-
-    // Prepare cached string constants
-    m_strstring = wxS("string");
-    m_strlong = wxS("long");
-    m_strbool = wxS("bool");
-    m_strlist = wxS("list");
-    m_strMin = wxS("Min");
-    m_strMax = wxS("Max");
-    m_strUnits = wxS("Units");
-    m_strInlineHelp = wxS("InlineHelp");
-
-    m_warnings = 0;
-}
-
-
-wxPGGlobalVarsClass::~wxPGGlobalVarsClass()
-{
-    size_t i;
-
-    delete m_defaultRenderer;
-
-    // This will always have one ref
-    delete m_fontFamilyChoices;
-
-#if wxUSE_VALIDATORS
-    for ( i=0; i<m_arrValidators.size(); i++ )
-        delete ((wxValidator*)m_arrValidators[i]);
-#endif
-
-    //
-    // Destroy value type class instances.
-    wxPGHashMapS2P::iterator vt_it;
-
-    // Destroy editor class instances.
-    // iterate over all the elements in the class
-    for( vt_it = m_mapEditorClasses.begin(); vt_it != m_mapEditorClasses.end(); ++vt_it )
-    {
-        delete ((wxPGEditor*)vt_it->second);
-    }
-
-    delete wxPGProperty::sm_wxPG_LABEL;
-}
-
-void wxPropertyGridInitGlobalsIfNeeded()
-{
-}
-
-// -----------------------------------------------------------------------
-// wxPGTLWHandler
-//   Intercepts Close-events sent to wxPropertyGrid's top-level parent,
-//   and tries to commit property value.
-// -----------------------------------------------------------------------
-
-class wxPGTLWHandler : public wxEvtHandler
-{
-public:
-
-    wxPGTLWHandler( wxPropertyGrid* pg )
-        : wxEvtHandler()
-    {
-        m_pg = pg;
-    }
-
-protected:
-
-    void OnClose( wxCloseEvent& event )
-    {
-        // ClearSelection forces value validation/commit.
-        if ( event.CanVeto() && !m_pg->ClearSelection() )
-        {
-            event.Veto();
-            return;
-        }
-
-        event.Skip();
-    }
-
-private:
-    wxPropertyGrid*     m_pg;
-
-    DECLARE_EVENT_TABLE()
-};
-
-BEGIN_EVENT_TABLE(wxPGTLWHandler, wxEvtHandler)
-    EVT_CLOSE(wxPGTLWHandler::OnClose)
-END_EVENT_TABLE()
-
-// -----------------------------------------------------------------------
-// wxPGCanvas
-// -----------------------------------------------------------------------
-
-//
-// wxPGCanvas acts as a graphics sub-window of the
-// wxScrolledWindow that wxPropertyGrid is.
-//
-class wxPGCanvas : public wxPanel
-{
-public:
-    wxPGCanvas() : wxPanel()
-    {
-    }
-    virtual ~wxPGCanvas() { }
-
-protected:
-    void OnMouseMove( wxMouseEvent &event )
-    {
-        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-        pg->OnMouseMove( event );
-    }
-
-    void OnMouseClick( wxMouseEvent &event )
-    {
-        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-        pg->OnMouseClick( event );
-    }
-
-    void OnMouseUp( wxMouseEvent &event )
-    {
-        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-        pg->OnMouseUp( event );
-    }
-
-    void OnMouseRightClick( wxMouseEvent &event )
-    {
-        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-        pg->OnMouseRightClick( event );
-    }
-
-    void OnMouseDoubleClick( wxMouseEvent &event )
-    {
-        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-        pg->OnMouseDoubleClick( event );
-    }
-
-    void OnKey( wxKeyEvent& event )
-    {
-        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-        pg->OnKey( event );
-    }
-
-    void OnPaint( wxPaintEvent& event );
-
-    // Always be focussable, even with child windows
-    virtual void SetCanFocus(bool WXUNUSED(canFocus))
-    {  wxPanel::SetCanFocus(true); }
-
-
-private:
-    DECLARE_EVENT_TABLE()
-    DECLARE_ABSTRACT_CLASS(wxPGCanvas)
-};
-
-
-IMPLEMENT_ABSTRACT_CLASS(wxPGCanvas,wxPanel)
-
-BEGIN_EVENT_TABLE(wxPGCanvas, wxPanel)
-    EVT_MOTION(wxPGCanvas::OnMouseMove)
-    EVT_PAINT(wxPGCanvas::OnPaint)
-    EVT_LEFT_DOWN(wxPGCanvas::OnMouseClick)
-    EVT_LEFT_UP(wxPGCanvas::OnMouseUp)
-    EVT_RIGHT_UP(wxPGCanvas::OnMouseRightClick)
-    EVT_LEFT_DCLICK(wxPGCanvas::OnMouseDoubleClick)
-    EVT_KEY_DOWN(wxPGCanvas::OnKey)
-END_EVENT_TABLE()
-
-
-void wxPGCanvas::OnPaint( wxPaintEvent& WXUNUSED(event) )
-{
-    wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
-    wxASSERT( pg->IsKindOf(CLASSINFO(wxPropertyGrid)) );
-
-    wxPaintDC dc(this);
-
-    // Don't paint after destruction has begun
-    if ( !(pg->GetInternalFlags() & wxPG_FL_INITIALIZED) )
-        return;
-
-    // Update everything inside the box
-    wxRect r = GetUpdateRegion().GetBox();
-
-    // FIXME: This is just a workaround for a bug that causes splitters not
-    //        to paint when other windows are being dragged over the grid.
-    wxRect fullRect = GetRect();
-    r.x = fullRect.x;
-    r.width = fullRect.width;
-
-    // Repaint this rectangle
-    pg->DrawItems( dc, r.y, r.y + r.height, &r );
-
-    // We assume that the size set when grid is shown
-    // is what is desired.
-    pg->SetInternalFlag(wxPG_FL_GOOD_SIZE_SET);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxPropertyGrid, wxScrolledWindow)
-
-BEGIN_EVENT_TABLE(wxPropertyGrid, wxScrolledWindow)
-  EVT_IDLE(wxPropertyGrid::OnIdle)
-  EVT_MOTION(wxPropertyGrid::OnMouseMoveBottom)
-  EVT_PAINT(wxPropertyGrid::OnPaint)
-  EVT_SIZE(wxPropertyGrid::OnResize)
-  EVT_ENTER_WINDOW(wxPropertyGrid::OnMouseEntry)
-  EVT_LEAVE_WINDOW(wxPropertyGrid::OnMouseEntry)
-  EVT_MOUSE_CAPTURE_CHANGED(wxPropertyGrid::OnCaptureChange)
-  EVT_SCROLLWIN(wxPropertyGrid::OnScrollEvent)
-  EVT_CHILD_FOCUS(wxPropertyGrid::OnChildFocusEvent)
-  EVT_SET_FOCUS(wxPropertyGrid::OnFocusEvent)
-  EVT_KILL_FOCUS(wxPropertyGrid::OnFocusEvent)
-  EVT_SYS_COLOUR_CHANGED(wxPropertyGrid::OnSysColourChanged)
-END_EVENT_TABLE()
-
-
-// -----------------------------------------------------------------------
-
-wxPropertyGrid::wxPropertyGrid()
-    : wxScrolledWindow()
-{
-    Init1();
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGrid::wxPropertyGrid( wxWindow *parent,
-                                wxWindowID id,
-                                const wxPoint& pos,
-                                const wxSize& size,
-                                long style,
-                                const wxString& name )
-    : wxScrolledWindow()
-{
-    Init1();
-    Create(parent,id,pos,size,style,name);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::Create( wxWindow *parent,
-                             wxWindowID id,
-                             const wxPoint& pos,
-                             const wxSize& size,
-                             long style,
-                             const wxString& name )
-{
-
-    if ( !(style&wxBORDER_MASK) )
-        style |= wxSIMPLE_BORDER;
-
-    style |= wxVSCROLL;
-
-    // Filter out wxTAB_TRAVERSAL - we will handle TABs manually
-    style &= ~(wxTAB_TRAVERSAL);
-    style |= wxWANTS_CHARS;
-
-    wxScrolledWindow::Create(parent,id,pos,size,style,name);
-
-    Init2();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-//
-// Initialize values to defaults
-//
-void wxPropertyGrid::Init1()
-{
-    // Register editor classes, if necessary.
-    if ( wxPGGlobalVars->m_mapEditorClasses.empty() )
-        wxPropertyGrid::RegisterDefaultEditors();
-
-    m_iFlags = 0;
-    m_pState = NULL;
-    m_wndEditor = m_wndEditor2 = NULL;
-    m_selected = NULL;
-    m_selColumn = -1;
-    m_propHover = NULL;
-    m_eventObject = this;
-    m_curFocused = NULL;
-    m_tlwHandler = NULL;
-    m_sortFunction = NULL;
-    m_inDoPropertyChanged = 0;
-    m_inCommitChangesFromEditor = 0;
-    m_inDoSelectProperty = 0;
-    m_permanentValidationFailureBehavior = wxPG_VFB_DEFAULT;
-    m_dragStatus = 0;
-    m_mouseSide = 16;
-    m_editorFocused = 0;
-
-    // Set default keys
-    AddActionTrigger( wxPG_ACTION_NEXT_PROPERTY, WXK_RIGHT );
-    AddActionTrigger( wxPG_ACTION_NEXT_PROPERTY, WXK_DOWN );
-    AddActionTrigger( wxPG_ACTION_PREV_PROPERTY, WXK_LEFT );
-    AddActionTrigger( wxPG_ACTION_PREV_PROPERTY, WXK_UP );
-    AddActionTrigger( wxPG_ACTION_EXPAND_PROPERTY, WXK_RIGHT);
-    AddActionTrigger( wxPG_ACTION_COLLAPSE_PROPERTY, WXK_LEFT);
-    AddActionTrigger( wxPG_ACTION_CANCEL_EDIT, WXK_ESCAPE );
-    AddActionTrigger( wxPG_ACTION_PRESS_BUTTON, WXK_DOWN, wxMOD_ALT );
-    AddActionTrigger( wxPG_ACTION_PRESS_BUTTON, WXK_F4 );
-
-    m_coloursCustomized = 0;
-    m_frozen = 0;
-
-    m_canvas = NULL;
-
-#if wxPG_DOUBLE_BUFFER
-    m_doubleBuffer = NULL;
-#endif
-
-#ifndef wxPG_ICON_WIDTH
-    m_expandbmp = NULL;
-    m_collbmp = NULL;
-    m_iconWidth = 11;
-    m_iconHeight = 11;
-#else
-    m_iconWidth = wxPG_ICON_WIDTH;
-#endif
-
-    m_prevVY = -1;
-
-    m_gutterWidth = wxPG_GUTTER_MIN;
-    m_subgroup_extramargin = 10;
-
-    m_lineHeight = 0;
-
-    m_width = m_height = 0;
-
-    m_commonValues.push_back(new wxPGCommonValue(_("Unspecified"), wxPGGlobalVars->m_defaultRenderer) );
-    m_cvUnspecified = 0;
-
-    m_chgInfo_changedProperty = NULL;
-}
-
-// -----------------------------------------------------------------------
-
-//
-// Initialize after parent etc. set
-//
-void wxPropertyGrid::Init2()
-{
-    wxASSERT( !(m_iFlags & wxPG_FL_INITIALIZED ) );
-
-#ifdef __WXMAC__
-   // Smaller controls on Mac
-   SetWindowVariant(wxWINDOW_VARIANT_SMALL);
-#endif
-
-    // Now create state, if one didn't exist already
-    // (wxPropertyGridManager might have created it for us).
-    if ( !m_pState )
-    {
-        m_pState = CreateState();
-        m_pState->m_pPropGrid = this;
-        m_iFlags |= wxPG_FL_CREATEDSTATE;
-    }
-
-    if ( !(m_windowStyle & wxPG_SPLITTER_AUTO_CENTER) )
-        m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
-
-    if ( m_windowStyle & wxPG_HIDE_CATEGORIES )
-    {
-        m_pState->InitNonCatMode();
-
-        m_pState->m_properties = m_pState->m_abcArray;
-    }
-
-    GetClientSize(&m_width,&m_height);
-
-#ifndef wxPG_ICON_WIDTH
-    // create two bitmap nodes for drawing
-    m_expandbmp = new wxBitmap(expand_xpm);
-    m_collbmp = new wxBitmap(collapse_xpm);
-
-    // calculate average font height for bitmap centering
-
-    m_iconWidth = m_expandbmp->GetWidth();
-    m_iconHeight = m_expandbmp->GetHeight();
-#endif
-
-    m_curcursor = wxCURSOR_ARROW;
-    m_cursorSizeWE = new wxCursor( wxCURSOR_SIZEWE );
-
-    // adjust bitmap icon y position so they are centered
-    m_vspacing = wxPG_DEFAULT_VSPACING;
-
-    CalculateFontAndBitmapStuff( wxPG_DEFAULT_VSPACING );
-
-    // Allocate cell datas indirectly by calling setter
-    m_propertyDefaultCell.SetBgCol(*wxBLACK);
-    m_categoryDefaultCell.SetBgCol(*wxBLACK);
-
-    RegainColours();
-
-    // This helps with flicker
-    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
-
-    // Hook the TLW
-    wxPGTLWHandler* handler = new wxPGTLWHandler(this);
-    m_tlp = ::wxGetTopLevelParent(this);
-    m_tlwHandler = handler;
-    m_tlp->PushEventHandler(handler);
-
-    // set virtual size to this window size
-    wxSize wndsize = GetSize();
-    SetVirtualSize(wndsize.GetWidth(), wndsize.GetWidth());
-
-    m_timeCreated = ::wxGetLocalTimeMillis();
-
-    m_canvas = new wxPGCanvas();
-    m_canvas->Create(this, 1, wxPoint(0, 0), GetClientSize(),
-                     wxWANTS_CHARS | wxCLIP_CHILDREN);
-    m_canvas->SetBackgroundStyle( wxBG_STYLE_CUSTOM );
-
-    m_iFlags |= wxPG_FL_INITIALIZED;
-
-    m_ncWidth = wndsize.GetWidth();
-
-    // Need to call OnResize handler or size given in constructor/Create
-    // will never work.
-    wxSizeEvent sizeEvent(wndsize,0);
-    OnResize(sizeEvent);
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGrid::~wxPropertyGrid()
-{
-    size_t i;
-
-    DoSelectProperty(NULL);
-
-    // This should do prevent things from going too badly wrong
-    m_iFlags &= ~(wxPG_FL_INITIALIZED);
-
-    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
-        m_canvas->ReleaseMouse();
-
-    wxPGTLWHandler* handler = (wxPGTLWHandler*) m_tlwHandler;
-    m_tlp->RemoveEventHandler(handler);
-    delete handler;
-
-    wxASSERT_MSG( !IsEditorsValueModified(),
-                  wxS("Most recent change in property editor was lost!!! ")
-                  wxS("(if you don't want this to happen, close your frames ")
-                  wxS("and dialogs using Close(false).)") );
-
-#if wxPG_DOUBLE_BUFFER
-    if ( m_doubleBuffer )
-        delete m_doubleBuffer;
-#endif
-
-    //m_selected = NULL;
-
-    if ( m_iFlags & wxPG_FL_CREATEDSTATE )
-        delete m_pState;
-
-    delete m_cursorSizeWE;
-
-#ifndef wxPG_ICON_WIDTH
-    delete m_expandbmp;
-    delete m_collbmp;
-#endif
-
-    // Delete common value records
-    for ( i=0; i<m_commonValues.size(); i++ )
-    {
-        delete GetCommonValue(i);
-    }
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::Destroy()
-{
-    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
-        m_canvas->ReleaseMouse();
-
-    return wxScrolledWindow::Destroy();
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridPageState* wxPropertyGrid::CreateState() const
-{
-    return new wxPropertyGridPageState();
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid overridden wxWindow methods
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetWindowStyleFlag( long style )
-{
-    long old_style = m_windowStyle;
-
-    if ( m_iFlags & wxPG_FL_INITIALIZED )
-    {
-        wxASSERT( m_pState );
-
-        if ( !(style & wxPG_HIDE_CATEGORIES) && (old_style & wxPG_HIDE_CATEGORIES) )
-        {
-        // Enable categories
-            EnableCategories( true );
-        }
-        else if ( (style & wxPG_HIDE_CATEGORIES) && !(old_style & wxPG_HIDE_CATEGORIES) )
-        {
-        // Disable categories
-            EnableCategories( false );
-        }
-        if ( !(old_style & wxPG_AUTO_SORT) && (style & wxPG_AUTO_SORT) )
-        {
-            //
-            // Autosort enabled
-            //
-            if ( !m_frozen )
-                PrepareAfterItemsAdded();
-            else
-                m_pState->m_itemsAdded = 1;
-        }
-    #if wxPG_SUPPORT_TOOLTIPS
-        if ( !(old_style & wxPG_TOOLTIPS) && (style & wxPG_TOOLTIPS) )
-        {
-            //
-            // Tooltips enabled
-            //
-            /*
-            wxToolTip* tooltip = new wxToolTip ( wxEmptyString );
-            SetToolTip ( tooltip );
-            tooltip->SetDelay ( wxPG_TOOLTIP_DELAY );
-            */
-        }
-        else if ( (old_style & wxPG_TOOLTIPS) && !(style & wxPG_TOOLTIPS) )
-        {
-            //
-            // Tooltips disabled
-            //
-            m_canvas->SetToolTip( NULL );
-        }
-    #endif
-    }
-
-    wxScrolledWindow::SetWindowStyleFlag ( style );
-
-    if ( m_iFlags & wxPG_FL_INITIALIZED )
-    {
-        if ( (old_style & wxPG_HIDE_MARGIN) != (style & wxPG_HIDE_MARGIN) )
-        {
-            CalculateFontAndBitmapStuff( m_vspacing );
-            Refresh();
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::Freeze()
-{
-    if ( !m_frozen )
-    {
-        wxScrolledWindow::Freeze();
-    }
-    m_frozen++;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::Thaw()
-{
-    m_frozen--;
-
-    if ( !m_frozen )
-    {
-        wxScrolledWindow::Thaw();
-        RecalculateVirtualSize();
-    #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-        m_canvas->Refresh();
-    #endif
-
-        // Force property re-selection
-        if ( m_selected )
-            DoSelectProperty(m_selected, wxPG_SEL_FORCE);
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetExtraStyle( long exStyle )
-{
-    if ( exStyle & wxPG_EX_NATIVE_DOUBLE_BUFFERING )
-    {
-#if defined(__WXMSW__)
-
-        /*
-        // Don't use WS_EX_COMPOSITED just now.
-        HWND hWnd;
-
-        if ( m_iFlags & wxPG_FL_IN_MANAGER )
-            hWnd = (HWND)GetParent()->GetHWND();
-        else
-            hWnd = (HWND)GetHWND();
-
-        ::SetWindowLong( hWnd, GWL_EXSTYLE,
-                         ::GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED );
-        */
-
-//#elif defined(__WXGTK20__)
-#endif
-        // Only apply wxPG_EX_NATIVE_DOUBLE_BUFFERING if the window
-        // truly was double-buffered.
-        if ( !this->IsDoubleBuffered() )
-        {
-            exStyle &= ~(wxPG_EX_NATIVE_DOUBLE_BUFFERING);
-        }
-        else
-        {
-        #if wxPG_DOUBLE_BUFFER
-            delete m_doubleBuffer;
-            m_doubleBuffer = NULL;
-        #endif
-        }
-    }
-
-    wxScrolledWindow::SetExtraStyle( exStyle );
-
-    if ( exStyle & wxPG_EX_INIT_NOCAT )
-        m_pState->InitNonCatMode();
-
-    if ( exStyle & wxPG_EX_HELP_AS_TOOLTIPS )
-        m_windowStyle |= wxPG_TOOLTIPS;
-
-    // Set global style
-    wxPGGlobalVars->m_extraStyle = exStyle;
-}
-
-// -----------------------------------------------------------------------
-
-// returns the best acceptable minimal size
-wxSize wxPropertyGrid::DoGetBestSize() const
-{
-    int hei = 15;
-    if ( m_lineHeight > hei )
-        hei = m_lineHeight;
-    wxSize sz = wxSize( 60, hei+40 );
-
-    CacheBestSize(sz);
-    return sz;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid Font and Colour Methods
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::CalculateFontAndBitmapStuff( int vspacing )
-{
-    int x = 0, y = 0;
-
-    m_captionFont = wxScrolledWindow::GetFont();
-
-    GetTextExtent(wxS("jG"), &x, &y, 0, 0, &m_captionFont);
-    m_subgroup_extramargin = x + (x/2);
-    m_fontHeight = y;
-
-#if wxPG_USE_RENDERER_NATIVE
-    m_iconWidth = wxPG_ICON_WIDTH;
-#elif wxPG_ICON_WIDTH
-    // scale icon
-    m_iconWidth = (m_fontHeight * wxPG_ICON_WIDTH) / 13;
-    if ( m_iconWidth < 5 ) m_iconWidth = 5;
-    else if ( !(m_iconWidth & 0x01) ) m_iconWidth++; // must be odd
-
-#endif
-
-    m_gutterWidth = m_iconWidth / wxPG_GUTTER_DIV;
-    if ( m_gutterWidth < wxPG_GUTTER_MIN )
-        m_gutterWidth = wxPG_GUTTER_MIN;
-
-    int vdiv = 6;
-    if ( vspacing <= 1 ) vdiv = 12;
-    else if ( vspacing >= 3 ) vdiv = 3;
-
-    m_spacingy = m_fontHeight / vdiv;
-    if ( m_spacingy < wxPG_YSPACING_MIN )
-        m_spacingy = wxPG_YSPACING_MIN;
-
-    m_marginWidth = 0;
-    if ( !(m_windowStyle & wxPG_HIDE_MARGIN) )
-        m_marginWidth = m_gutterWidth*2 + m_iconWidth;
-
-    m_captionFont.SetWeight(wxBOLD);
-    GetTextExtent(wxS("jG"), &x, &y, 0, 0, &m_captionFont);
-
-    m_lineHeight = m_fontHeight+(2*m_spacingy)+1;
-
-    // button spacing
-    m_buttonSpacingY = (m_lineHeight - m_iconHeight) / 2;
-    if ( m_buttonSpacingY < 0 ) m_buttonSpacingY = 0;
-
-    if ( m_pState )
-        m_pState->CalculateFontAndBitmapStuff(vspacing);
-
-    if ( m_iFlags & wxPG_FL_INITIALIZED )
-        RecalculateVirtualSize();
-
-    InvalidateBestSize();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnSysColourChanged( wxSysColourChangedEvent &WXUNUSED(event) )
-{
-    RegainColours();
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-static wxColour wxPGAdjustColour(const wxColour& src, int ra,
-                                 int ga = 1000, int ba = 1000,
-                                 bool forceDifferent = false)
-{
-    if ( ga >= 1000 )
-        ga = ra;
-    if ( ba >= 1000 )
-        ba = ra;
-
-    // Recursion guard (allow 2 max)
-    static int isinside = 0;
-    isinside++;
-    wxCHECK_MSG( isinside < 3,
-                 *wxBLACK,
-                 wxT("wxPGAdjustColour should not be recursively called more than once") );
-
-    wxColour dst;
-
-    int r = src.Red();
-    int g = src.Green();
-    int b = src.Blue();
-    int r2 = r + ra;
-    if ( r2>255 ) r2 = 255;
-    else if ( r2<0) r2 = 0;
-    int g2 = g + ga;
-    if ( g2>255 ) g2 = 255;
-    else if ( g2<0) g2 = 0;
-    int b2 = b + ba;
-    if ( b2>255 ) b2 = 255;
-    else if ( b2<0) b2 = 0;
-
-    // Make sure they are somewhat different
-    if ( forceDifferent && (abs((r+g+b)-(r2+g2+b2)) < abs(ra/2)) )
-        dst = wxPGAdjustColour(src,-(ra*2));
-    else
-        dst = wxColour(r2,g2,b2);
-
-    // Recursion guard (allow 2 max)
-    isinside--;
-
-    return dst;
-}
-
-
-static int wxPGGetColAvg( const wxColour& col )
-{
-    return (col.Red() + col.Green() + col.Blue()) / 3;
-}
-
-
-void wxPropertyGrid::RegainColours()
-{
-    if ( !(m_coloursCustomized & 0x0002) )
-    {
-        wxColour col = wxSystemSettings::GetColour( wxSYS_COLOUR_BTNFACE );
-
-        // Make sure colour is dark enough
-    #ifdef __WXGTK__
-        int colDec = wxPGGetColAvg(col) - 230;
-    #else
-        int colDec = wxPGGetColAvg(col) - 200;
-    #endif
-        if ( colDec > 0 )
-            m_colCapBack = wxPGAdjustColour(col,-colDec);
-        else
-            m_colCapBack = col;
-        m_categoryDefaultCell.GetData()->SetBgCol(m_colCapBack);
-    }
-
-    if ( !(m_coloursCustomized & 0x0001) )
-        m_colMargin = m_colCapBack;
-
-    if ( !(m_coloursCustomized & 0x0004) )
-    {
-    #ifdef __WXGTK__
-        int colDec = -90;
-    #else
-        int colDec = -72;
-    #endif
-        wxColour capForeCol = wxPGAdjustColour(m_colCapBack,colDec,5000,5000,true);
-        m_colCapFore = capForeCol;
-        m_categoryDefaultCell.GetData()->SetFgCol(capForeCol);
-    }
-
-    if ( !(m_coloursCustomized & 0x0008) )
-    {
-        wxColour bgCol = wxSystemSettings::GetColour( wxSYS_COLOUR_WINDOW );
-        m_colPropBack = bgCol;
-        m_propertyDefaultCell.GetData()->SetBgCol(bgCol);
-    }
-
-    if ( !(m_coloursCustomized & 0x0010) )
-    {
-        wxColour fgCol = wxSystemSettings::GetColour( wxSYS_COLOUR_WINDOWTEXT );
-        m_colPropFore = fgCol;
-        m_propertyDefaultCell.GetData()->SetFgCol(fgCol);
-    }
-
-    if ( !(m_coloursCustomized & 0x0020) )
-        m_colSelBack = wxSystemSettings::GetColour( wxSYS_COLOUR_HIGHLIGHT );
-
-    if ( !(m_coloursCustomized & 0x0040) )
-        m_colSelFore = wxSystemSettings::GetColour( wxSYS_COLOUR_HIGHLIGHTTEXT );
-
-    if ( !(m_coloursCustomized & 0x0080) )
-        m_colLine = m_colCapBack;
-
-    if ( !(m_coloursCustomized & 0x0100) )
-        m_colDisPropFore = m_colCapFore;
-
-    m_colEmptySpace = wxSystemSettings::GetColour( wxSYS_COLOUR_WINDOW );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::ResetColours()
-{
-    m_coloursCustomized = 0;
-
-    RegainColours();
-
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::SetFont( const wxFont& font )
-{
-    // Must disable active editor.
-    ClearSelection(false);
-
-    bool res = wxScrolledWindow::SetFont( font );
-    if ( res && GetParent()) // may not have been Create()ed yet
-    {
-        CalculateFontAndBitmapStuff( m_vspacing );
-        Refresh();
-    }
-
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetLineColour( const wxColour& col )
-{
-    m_colLine = col;
-    m_coloursCustomized |= 0x80;
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetMarginColour( const wxColour& col )
-{
-    m_colMargin = col;
-    m_coloursCustomized |= 0x01;
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetCellBackgroundColour( const wxColour& col )
-{
-    m_colPropBack = col;
-    m_coloursCustomized |= 0x08;
-
-    m_propertyDefaultCell.GetData()->SetBgCol(col);
-
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetCellTextColour( const wxColour& col )
-{
-    m_colPropFore = col;
-    m_coloursCustomized |= 0x10;
-
-    m_propertyDefaultCell.GetData()->SetFgCol(col);
-
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetEmptySpaceColour( const wxColour& col )
-{
-    m_colEmptySpace = col;
-
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetCellDisabledTextColour( const wxColour& col )
-{
-    m_colDisPropFore = col;
-    m_coloursCustomized |= 0x100;
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetSelectionBackgroundColour( const wxColour& col )
-{
-    m_colSelBack = col;
-    m_coloursCustomized |= 0x20;
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetSelectionTextColour( const wxColour& col )
-{
-    m_colSelFore = col;
-    m_coloursCustomized |= 0x40;
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetCaptionBackgroundColour( const wxColour& col )
-{
-    m_colCapBack = col;
-    m_coloursCustomized |= 0x02;
-
-    m_categoryDefaultCell.GetData()->SetBgCol(col);
-
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetCaptionTextColour( const wxColour& col )
-{
-    m_colCapFore = col;
-    m_coloursCustomized |= 0x04;
-
-    m_categoryDefaultCell.GetData()->SetFgCol(col);
-
-    Refresh();
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid property adding and removal
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::PrepareAfterItemsAdded()
-{
-    if ( !m_pState || !m_pState->m_itemsAdded ) return;
-
-    m_pState->m_itemsAdded = 0;
-
-    if ( m_windowStyle & wxPG_AUTO_SORT )
-        Sort(wxPG_SORT_TOP_LEVEL_ONLY);
-
-    RecalculateVirtualSize();
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid property operations
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::EnsureVisible( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-
-    Update();
-
-    bool changed = false;
-
-    // Is it inside collapsed section?
-    if ( !p->IsVisible() )
-    {
-        // expand parents
-        wxPGProperty* parent = p->GetParent();
-        wxPGProperty* grandparent = parent->GetParent();
-
-        if ( grandparent && grandparent != m_pState->m_properties )
-            Expand( grandparent );
-
-        Expand( parent );
-        changed = true;
-    }
-
-    // Need to scroll?
-    int vx, vy;
-    GetViewStart(&vx,&vy);
-    vy*=wxPG_PIXELS_PER_UNIT;
-
-    int y = p->GetY();
-
-    if ( y < vy )
-    {
-        Scroll(vx, y/wxPG_PIXELS_PER_UNIT );
-        m_iFlags |= wxPG_FL_SCROLLED;
-        changed = true;
-    }
-    else if ( (y+m_lineHeight) > (vy+m_height) )
-    {
-        Scroll(vx, (y-m_height+(m_lineHeight*2))/wxPG_PIXELS_PER_UNIT );
-        m_iFlags |= wxPG_FL_SCROLLED;
-        changed = true;
-    }
-
-    if ( changed )
-        DrawItems( p, p );
-
-    return changed;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid helper methods called by properties
-// -----------------------------------------------------------------------
-
-// Control font changer helper.
-void wxPropertyGrid::SetCurControlBoldFont()
-{
-    wxASSERT( m_wndEditor );
-    m_wndEditor->SetFont( m_captionFont );
-}
-
-// -----------------------------------------------------------------------
-
-wxPoint wxPropertyGrid::GetGoodEditorDialogPosition( wxPGProperty* p,
-                                                     const wxSize& sz )
-{
-#if wxPG_SMALL_SCREEN
-    // On small-screen devices, always show dialogs with default position and size.
-    return wxDefaultPosition;
-#else
-    int splitterX = GetSplitterPosition();
-    int x = splitterX;
-    int y = p->GetY();
-
-    wxCHECK_MSG( y >= 0, wxPoint(-1,-1), wxT("invalid y?") );
-
-    ImprovedClientToScreen( &x, &y );
-
-    int sw = wxSystemSettings::GetMetric( ::wxSYS_SCREEN_X );
-    int sh = wxSystemSettings::GetMetric( ::wxSYS_SCREEN_Y );
-
-    int new_x;
-    int new_y;
-
-    if ( x > (sw/2) )
-        // left
-        new_x = x + (m_width-splitterX) - sz.x;
-    else
-        // right
-        new_x = x;
-
-    if ( y > (sh/2) )
-        // above
-        new_y = y - sz.y;
-    else
-        // below
-        new_y = y + m_lineHeight;
-
-    return wxPoint(new_x,new_y);
-#endif
-}
-
-// -----------------------------------------------------------------------
-
-wxString& wxPropertyGrid::ExpandEscapeSequences( wxString& dst_str, wxString& src_str )
-{
-    if ( src_str.length() == 0 )
-    {
-        dst_str = src_str;
-        return src_str;
-    }
-
-    bool prev_is_slash = false;
-
-    wxString::const_iterator i = src_str.begin();
-
-    dst_str.clear();
-
-    for ( ; i != src_str.end(); ++i )
-    {
-        wxUniChar a = *i;
-
-        if ( a != wxS('\\') )
-        {
-            if ( !prev_is_slash )
-            {
-                dst_str << a;
-            }
-            else
-            {
-                if ( a == wxS('n') )
-                {
-            #ifdef __WXMSW__
-                    dst_str << wxS('\n');
-            #else
-                    dst_str << wxS('\n');
-            #endif
-                }
-                else if ( a == wxS('t') )
-                    dst_str << wxS('\t');
-                else
-                    dst_str << a;
-            }
-            prev_is_slash = false;
-        }
-        else
-        {
-            if ( prev_is_slash )
-            {
-                dst_str << wxS('\\');
-                prev_is_slash = false;
-            }
-            else
-            {
-                prev_is_slash = true;
-            }
-        }
-    }
-    return dst_str;
-}
-
-// -----------------------------------------------------------------------
-
-wxString& wxPropertyGrid::CreateEscapeSequences( wxString& dst_str, wxString& src_str )
-{
-    if ( src_str.length() == 0 )
-    {
-        dst_str = src_str;
-        return src_str;
-    }
-
-    wxString::const_iterator i = src_str.begin();
-    wxUniChar prev_a = wxS('\0');
-
-    dst_str.clear();
-
-    for ( ; i != src_str.end(); ++i )
-    {
-        wxChar a = *i;
-
-        if ( a >= wxS(' ') )
-        {
-            // This surely is not something that requires an escape sequence.
-            dst_str << a;
-        }
-        else
-        {
-            // This might need...
-            if ( a == wxS('\r')  )
-            {
-                // DOS style line end.
-                // Already taken care below
-            }
-            else if ( a == wxS('\n') )
-                // UNIX style line end.
-                dst_str << wxS("\\n");
-            else if ( a == wxS('\t') )
-                // Tab.
-                dst_str << wxS('\t');
-            else
-            {
-                //wxLogDebug(wxT("WARNING: Could not create escape sequence for character #%i"),(int)a);
-                dst_str << a;
-            }
-        }
-
-        prev_a = a;
-    }
-    return dst_str;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGrid::DoGetItemAtY( int y ) const
-{
-    // Outside?
-    if ( y < 0 )
-        return NULL;
-
-    unsigned int a = 0;
-    return m_pState->m_properties->GetItemAtY(y, m_lineHeight, &a);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid graphics related methods
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnPaint( wxPaintEvent& WXUNUSED(event) )
-{
-    wxPaintDC dc(this);
-
-    // Update everything inside the box
-    wxRect r = GetUpdateRegion().GetBox();
-
-    dc.SetPen(m_colEmptySpace);
-    dc.SetBrush(m_colEmptySpace);
-    dc.DrawRectangle(r);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::DrawExpanderButton( wxDC& dc, const wxRect& rect,
-                                         wxPGProperty* property ) const
-{
-    // Prepare rectangle to be used
-    wxRect r(rect);
-    r.x += m_gutterWidth; r.y += m_buttonSpacingY;
-    r.width = m_iconWidth; r.height = m_iconHeight;
-
-#if (wxPG_USE_RENDERER_NATIVE)
-    //
-#elif wxPG_ICON_WIDTH
-    // Drawing expand/collapse button manually
-    dc.SetPen(m_colPropFore);
-    if ( property->IsCategory() )
-        dc.SetBrush(*wxTRANSPARENT_BRUSH);
-    else
-        dc.SetBrush(m_colPropBack);
-
-    dc.DrawRectangle( r );
-    int _y = r.y+(m_iconWidth/2);
-    dc.DrawLine(r.x+2,_y,r.x+m_iconWidth-2,_y);
-#else
-    wxBitmap* bmp;
-#endif
-
-    if ( property->IsExpanded() )
-    {
-    // wxRenderer functions are non-mutating in nature, so it
-    // should be safe to cast "const wxPropertyGrid*" to "wxWindow*".
-    // Hopefully this does not cause problems.
-    #if (wxPG_USE_RENDERER_NATIVE)
-        wxRendererNative::Get().DrawTreeItemButton(
-                (wxWindow*)this,
-                dc,
-                r,
-                wxCONTROL_EXPANDED
-            );
-    #elif wxPG_ICON_WIDTH
-        //
-    #else
-        bmp = m_collbmp;
-    #endif
-
-    }
-    else
-    {
-    #if (wxPG_USE_RENDERER_NATIVE)
-        wxRendererNative::Get().DrawTreeItemButton(
-                (wxWindow*)this,
-                dc,
-                r,
-                0
-            );
-    #elif wxPG_ICON_WIDTH
-        int _x = r.x+(m_iconWidth/2);
-        dc.DrawLine(_x,r.y+2,_x,r.y+m_iconWidth-2);
-    #else
-        bmp = m_expandbmp;
-    #endif
-    }
-
-#if (wxPG_USE_RENDERER_NATIVE)
-    //
-#elif wxPG_ICON_WIDTH
-    //
-#else
-    dc.DrawBitmap( *bmp, r.x, r.y, true );
-#endif
-}
-
-// -----------------------------------------------------------------------
-
-//
-// This is the one called by OnPaint event handler and others.
-// topy and bottomy are already unscrolled (ie. physical)
-//
-void wxPropertyGrid::DrawItems( wxDC& dc,
-                                unsigned int topy,
-                                unsigned int bottomy,
-                                const wxRect* clipRect )
-{
-    if ( m_frozen || m_height < 1 || bottomy < topy || !m_pState ) return;
-
-    m_pState->EnsureVirtualHeight();
-
-    wxRect tempClipRect;
-    if ( !clipRect )
-    {
-        tempClipRect = wxRect(0,topy,m_pState->m_width,bottomy);
-        clipRect = &tempClipRect;
-    }
-
-    // items added check
-    if ( m_pState->m_itemsAdded ) PrepareAfterItemsAdded();
-
-    int paintFinishY = 0;
-
-    if ( m_pState->m_properties->GetChildCount() > 0 )
-    {
-        wxDC* dcPtr = &dc;
-        bool isBuffered = false;
-
-    #if wxPG_DOUBLE_BUFFER
-        wxMemoryDC* bufferDC = NULL;
-
-        if ( !(GetExtraStyle() & wxPG_EX_NATIVE_DOUBLE_BUFFERING) )
-        {
-            if ( !m_doubleBuffer )
-            {
-                paintFinishY = clipRect->y;
-                dcPtr = NULL;
-            }
-            else
-            {
-                bufferDC = new wxMemoryDC();
-
-                // If nothing was changed, then just copy from double-buffer
-                bufferDC->SelectObject( *m_doubleBuffer );
-                dcPtr = bufferDC;
-
-                isBuffered = true;
-            }
-        }
-    #endif
-
-        if ( dcPtr )
-        {
-            dc.SetClippingRegion( *clipRect );
-            paintFinishY = DoDrawItems( *dcPtr, clipRect, isBuffered );
-        }
-
-    #if wxPG_DOUBLE_BUFFER
-        if ( bufferDC )
-        {
-            dc.Blit( clipRect->x, clipRect->y, clipRect->width, clipRect->height,
-                bufferDC, 0, 0, wxCOPY );
-            dc.DestroyClippingRegion(); // Is this really necessary?
-            delete bufferDC;
-        }
-    #endif
-    }
-
-    // Clear area beyond bottomY?
-    if ( paintFinishY < (clipRect->y+clipRect->height) )
-    {
-        dc.SetPen(m_colEmptySpace);
-        dc.SetBrush(m_colEmptySpace);
-        dc.DrawRectangle( 0, paintFinishY, m_width, (clipRect->y+clipRect->height) );
-    }
-}
-
-// -----------------------------------------------------------------------
-
-int wxPropertyGrid::DoDrawItems( wxDC& dc,
-                                 const wxRect* clipRect,
-                                 bool isBuffered ) const
-{
-    const wxPGProperty* firstItem;
-    const wxPGProperty* lastItem;
-
-    firstItem = DoGetItemAtY(clipRect->y);
-    lastItem = DoGetItemAtY(clipRect->y+clipRect->height-1);
-
-    if ( !lastItem )
-        lastItem = GetLastItem( wxPG_ITERATE_VISIBLE );
-
-    if ( m_frozen || m_height < 1 || firstItem == NULL )
-        return clipRect->y;
-
-    wxCHECK_MSG( !m_pState->m_itemsAdded, clipRect->y, wxT("no items added") );
-    wxASSERT( m_pState->m_properties->GetChildCount() );
-
-    int lh = m_lineHeight;
-
-    int firstItemTopY;
-    int lastItemBottomY;
-
-    firstItemTopY = clipRect->y;
-    lastItemBottomY = clipRect->y + clipRect->height;
-
-    // Align y coordinates to item boundaries
-    firstItemTopY -= firstItemTopY % lh;
-    lastItemBottomY += lh - (lastItemBottomY % lh);
-    lastItemBottomY -= 1;
-
-    // Entire range outside scrolled, visible area?
-    if ( firstItemTopY >= (int)m_pState->GetVirtualHeight() || lastItemBottomY <= 0 )
-        return clipRect->y;
-
-    wxCHECK_MSG( firstItemTopY < lastItemBottomY, clipRect->y, wxT("invalid y values") );
-
-
-    /*
-    wxLogDebug(wxT("  -> DoDrawItems ( \"%s\" -> \"%s\", height=%i (ch=%i), clipRect = 0x%lX )"),
-        firstItem->GetLabel().c_str(),
-        lastItem->GetLabel().c_str(),
-        (int)(lastItemBottomY - firstItemTopY),
-        (int)m_height,
-        (unsigned long)clipRect );
-    */
-
-    wxRect r;
-
-    long windowStyle = m_windowStyle;
-
-    int xRelMod = 0;
-    int yRelMod = 0;
-
-    //
-    // With wxPG_DOUBLE_BUFFER, do double buffering
-    // - buffer's y = 0, so align cliprect and coordinates to that
-    //
-#if wxPG_DOUBLE_BUFFER
-
-    wxRect cr2;
-
-    if ( isBuffered )
-    {
-        xRelMod = clipRect->x;
-        yRelMod = clipRect->y;
-
-        //
-        // clipRect conversion
-        cr2 = *clipRect;
-        cr2.x -= xRelMod;
-        cr2.y -= yRelMod;
-        clipRect = &cr2;
-        firstItemTopY -= yRelMod;
-        lastItemBottomY -= yRelMod;
-    }
-#else
-    wxUnusedVar(isBuffered);
-#endif
-
-    int x = m_marginWidth - xRelMod;
-
-    wxFont normalFont = GetFont();
-
-    bool reallyFocused = (m_iFlags & wxPG_FL_FOCUSED) != 0;
-
-    bool isEnabled = IsEnabled();
-
-    //
-    // Prepare some pens and brushes that are often changed to.
-    //
-
-    wxBrush marginBrush(m_colMargin);
-    wxPen marginPen(m_colMargin);
-    wxBrush capbgbrush(m_colCapBack,wxSOLID);
-    wxPen linepen(m_colLine,1,wxSOLID);
-
-    // pen that has same colour as text
-    wxPen outlinepen(m_colPropFore,1,wxSOLID);
-
-    //
-    // Clear margin with background colour
-    //
-    dc.SetBrush( marginBrush );
-    if ( !(windowStyle & wxPG_HIDE_MARGIN) )
-    {
-        dc.SetPen( *wxTRANSPARENT_PEN );
-        dc.DrawRectangle(-1-xRelMod,firstItemTopY-1,x+2,lastItemBottomY-firstItemTopY+2);
-    }
-
-    const wxPGProperty* selected = m_selected;
-    const wxPropertyGridPageState* state = m_pState;
-
-#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-    bool wasSelectedPainted = false;
-#endif
-
-    // TODO: Only render columns that are within clipping region.
-
-    dc.SetFont(normalFont);
-
-    wxPropertyGridConstIterator it( state, wxPG_ITERATE_VISIBLE, firstItem );
-    int endScanBottomY = lastItemBottomY + lh;
-    int y = firstItemTopY;
-
-    //
-    // Pregenerate list of visible properties.
-    wxArrayPGProperty visPropArray;
-    visPropArray.reserve((m_height/m_lineHeight)+6);
-
-    for ( ; !it.AtEnd(); it.Next() )
-    {
-        const wxPGProperty* p = *it;
-
-        if ( !p->HasFlag(wxPG_PROP_HIDDEN) )
-        {
-            visPropArray.push_back((wxPGProperty*)p);
-
-            if ( y > endScanBottomY )
-                break;
-
-            y += lh;
-        }
-    }
-
-    visPropArray.push_back(NULL);
-
-    wxPGProperty* nextP = visPropArray[0];
-
-    int gridWidth = state->m_width;
-
-    y = firstItemTopY;
-    for ( unsigned int arrInd=1;
-          nextP && y <= lastItemBottomY;
-          arrInd++ )
-    {
-        wxPGProperty* p = nextP;
-        nextP = visPropArray[arrInd];
-
-        int rowHeight = m_fontHeight+(m_spacingy*2)+1;
-        int textMarginHere = x;
-        int renderFlags = 0;
-
-        int greyDepth = m_marginWidth;
-        if ( !(windowStyle & wxPG_HIDE_CATEGORIES) )
-            greyDepth = (((int)p->m_depthBgCol)-1) * m_subgroup_extramargin + m_marginWidth;
-
-        int greyDepthX = greyDepth - xRelMod;
-
-        // Use basic depth if in non-categoric mode and parent is base array.
-        if ( !(windowStyle & wxPG_HIDE_CATEGORIES) || p->GetParent() != m_pState->m_properties )
-        {
-            textMarginHere += ((unsigned int)((p->m_depth-1)*m_subgroup_extramargin));
-        }
-
-        // Paint margin area
-        dc.SetBrush(marginBrush);
-        dc.SetPen(marginPen);
-        dc.DrawRectangle( -xRelMod, y, greyDepth, lh );
-
-        dc.SetPen( linepen );
-
-        int y2 = y + lh;
-
-        // Margin Edge
-        dc.DrawLine( greyDepthX, y, greyDepthX, y2 );
-
-        // Splitters
-        unsigned int si;
-        int sx = x;
-
-        for ( si=0; si<state->m_colWidths.size(); si++ )
-        {
-            sx += state->m_colWidths[si];
-            dc.DrawLine( sx, y, sx, y2 );
-        }
-
-        // Horizontal Line, below
-        //   (not if both this and next is category caption)
-        if ( p->IsCategory() &&
-             nextP && nextP->IsCategory() )
-            dc.SetPen(m_colCapBack);
-
-        dc.DrawLine( greyDepthX, y2-1, gridWidth-xRelMod, y2-1 );
-
-        //
-        // Need to override row colours?
-        wxColour rowFgCol;
-        wxColour rowBgCol;
-
-        if ( p != selected )
-        {
-            // Disabled may get different colour.
-            if ( !p->IsEnabled() )
-            {
-                renderFlags |= wxPGCellRenderer::Disabled |
-                               wxPGCellRenderer::DontUseCellFgCol;
-                rowFgCol = m_colDisPropFore;
-            }
-        }
-        else
-        {
-            renderFlags |= wxPGCellRenderer::Selected;
-
-            if ( !p->IsCategory() )
-            {
-                renderFlags |= wxPGCellRenderer::DontUseCellFgCol |
-                               wxPGCellRenderer::DontUseCellBgCol;
-
-#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-                wasSelectedPainted = true;
-#endif
-
-                // Selected gets different colour.
-                if ( reallyFocused )
-                {
-                    rowFgCol = m_colSelFore;
-                    rowBgCol = m_colSelBack;
-                }
-                else if ( isEnabled )
-                {
-                    rowFgCol = m_colPropFore;
-                    rowBgCol = m_colMargin;
-                }
-                else
-                {
-                    rowFgCol = m_colDisPropFore;
-                    rowBgCol = m_colSelBack;
-                }
-            }
-        }
-
-        wxBrush rowBgBrush;
-
-        if ( rowBgCol.IsOk() )
-            rowBgBrush = wxBrush(rowBgCol);
-
-        if ( HasInternalFlag(wxPG_FL_CELL_OVERRIDES_SEL) )
-            renderFlags = renderFlags & ~wxPGCellRenderer::DontUseCellColours;
-
-        //
-        // Fill additional margin area with background colour of first cell
-        if ( greyDepthX < textMarginHere )
-        {
-            if ( !(renderFlags & wxPGCellRenderer::DontUseCellBgCol) )
-            {
-                wxPGCell& cell = p->GetCell(0);
-                rowBgCol = cell.GetBgCol();
-                rowBgBrush = wxBrush(rowBgCol);
-            }
-            dc.SetBrush(rowBgBrush);
-            dc.SetPen(rowBgCol);
-            dc.DrawRectangle(greyDepthX+1, y,
-                             textMarginHere-greyDepthX, lh-1);
-        }
-
-        bool fontChanged = false;
-
-        // Expander button rectangle
-        wxRect butRect( ((p->m_depth - 1) * m_subgroup_extramargin) - xRelMod,
-                        y,
-                        m_marginWidth,
-                        lh );
-
-        if ( p->IsCategory() )
-        {
-            // Captions have their cell areas merged as one
-            dc.SetFont(m_captionFont);
-            fontChanged = true;
-            wxRect cellRect(greyDepthX, y, gridWidth - greyDepth + 2, rowHeight-1 );
-
-            if ( renderFlags & wxPGCellRenderer::DontUseCellBgCol )
-            {
-                dc.SetBrush(rowBgBrush);
-                dc.SetPen(rowBgCol);
-            }
-
-            if ( renderFlags & wxPGCellRenderer::DontUseCellFgCol )
-            {
-                dc.SetTextForeground(rowFgCol);
-            }
-
-            wxPGCellRenderer* renderer = p->GetCellRenderer(0);
-            renderer->Render( dc, cellRect, this, p, 0, -1, renderFlags );
-
-            // Tree Item Button
-            if ( !HasFlag(wxPG_HIDE_MARGIN) && p->HasVisibleChildren() )
-                DrawExpanderButton( dc, butRect, p );
-        }
-        else
-        {
-            if ( p->m_flags & wxPG_PROP_MODIFIED && (windowStyle & wxPG_BOLD_MODIFIED) )
-            {
-                dc.SetFont(m_captionFont);
-                fontChanged = true;
-            }
-
-            unsigned int ci;
-            int cellX = x + 1;
-            int nextCellWidth = state->m_colWidths[0] -
-                                (greyDepthX - m_marginWidth);
-            wxRect cellRect(greyDepthX+1, y, 0, rowHeight-1);
-            int textXAdd = textMarginHere - greyDepthX;
-
-            for ( ci=0; ci<state->m_colWidths.size(); ci++ )
-            {
-                cellRect.width = nextCellWidth - 1;
-
-                bool ctrlCell = false;
-                int cellRenderFlags = renderFlags;
-
-                // Tree Item Button
-                if ( ci == 0 && !HasFlag(wxPG_HIDE_MARGIN) && p->HasVisibleChildren() )
-                    DrawExpanderButton( dc, butRect, p );
-
-                // Background
-                if ( p == selected && m_wndEditor && ci == 1 )
-                {
-                    wxColour editorBgCol = GetEditorControl()->GetBackgroundColour();
-                    dc.SetBrush(editorBgCol);
-                    dc.SetPen(editorBgCol);
-                    dc.SetTextForeground(m_colPropFore);
-                    dc.DrawRectangle(cellRect);
-
-                    if ( m_dragStatus == 0 && !(m_iFlags & wxPG_FL_CUR_USES_CUSTOM_IMAGE) )
-                        ctrlCell = true;
-                }
-                else
-                {
-                    if ( renderFlags & wxPGCellRenderer::DontUseCellBgCol )
-                    {
-                        dc.SetBrush(rowBgBrush);
-                        dc.SetPen(rowBgCol);
-                    }
-
-                    if ( renderFlags & wxPGCellRenderer::DontUseCellFgCol )
-                    {
-                        dc.SetTextForeground(rowFgCol);
-                    }
-                }
-
-                dc.SetClippingRegion(cellRect);
-
-                cellRect.x += textXAdd;
-                cellRect.width -= textXAdd;
-
-                // Foreground
-                if ( !ctrlCell )
-                {
-                    wxPGCellRenderer* renderer;
-                    int cmnVal = p->GetCommonValue();
-                    if ( cmnVal == -1 || ci != 1 )
-                    {
-                        renderer = p->GetCellRenderer(ci);
-                        renderer->Render( dc, cellRect, this, p, ci, -1,
-                                          cellRenderFlags );
-                    }
-                    else
-                    {
-                        renderer = GetCommonValue(cmnVal)->GetRenderer();
-                        renderer->Render( dc, cellRect, this, p, ci, -1,
-                                          cellRenderFlags );
-                    }
-                }
-
-                cellX += state->m_colWidths[ci];
-                if ( ci < (state->m_colWidths.size()-1) )
-                    nextCellWidth = state->m_colWidths[ci+1];
-                cellRect.x = cellX;
-                dc.DestroyClippingRegion(); // Is this really necessary?
-                textXAdd = 0;
-            }
-        }
-
-        if ( fontChanged )
-            dc.SetFont(normalFont);
-
-        y += rowHeight;
-    }
-
-    // Refresh editor controls (seems not needed on msw)
-    // NOTE: This code is mandatory for GTK!
-#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-    if ( wasSelectedPainted )
-    {
-        if ( m_wndEditor )
-            m_wndEditor->Refresh();
-        if ( m_wndEditor2 )
-            m_wndEditor2->Refresh();
-    }
-#endif
-
-    return y + yRelMod;
-}
-
-// -----------------------------------------------------------------------
-
-wxRect wxPropertyGrid::GetPropertyRect( const wxPGProperty* p1, const wxPGProperty* p2 ) const
-{
-    wxRect r;
-
-    if ( m_width < 10 || m_height < 10 ||
-         !m_pState->m_properties->GetChildCount() ||
-         p1 == NULL )
-        return wxRect(0,0,0,0);
-
-    int vy = 0;
-
-    //
-    // Return rect which encloses the given property range
-
-    int visTop = p1->GetY();
-    int visBottom;
-    if ( p2 )
-        visBottom = p2->GetY() + m_lineHeight;
-    else
-        visBottom = m_height + visTop;
-
-    // If seleced property is inside the range, we'll extend the range to include
-    // control's size.
-    wxPGProperty* selected = m_selected;
-    if ( selected )
-    {
-        int selectedY = selected->GetY();
-        if ( selectedY >= visTop && selectedY < visBottom )
-        {
-            wxWindow* editor = GetEditorControl();
-            if ( editor )
-            {
-                int visBottom2 = selectedY + editor->GetSize().y;
-                if ( visBottom2 > visBottom )
-                    visBottom = visBottom2;
-            }
-        }
-    }
-
-    return wxRect(0,visTop-vy,m_pState->m_width,visBottom-visTop);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::DrawItems( const wxPGProperty* p1, const wxPGProperty* p2 )
-{
-    if ( m_frozen )
-        return;
-
-    if ( m_pState->m_itemsAdded )
-        PrepareAfterItemsAdded();
-
-    wxRect r = GetPropertyRect(p1, p2);
-    if ( r.width > 0 )
-    {
-        m_canvas->RefreshRect(r);
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::RefreshProperty( wxPGProperty* p )
-{
-    if ( p == m_selected )
-        DoSelectProperty(p, wxPG_SEL_FORCE);
-
-    DrawItemAndChildren(p);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::DrawItemAndValueRelated( wxPGProperty* p )
-{
-    if ( m_frozen )
-        return;
-
-    // Draw item, children, and parent too, if it is not category
-    wxPGProperty* parent = p->GetParent();
-
-    while ( parent &&
-            !parent->IsCategory() &&
-            parent->GetParent() )
-    {
-         DrawItem(parent);
-         parent = parent->GetParent();
-    }
-
-    DrawItemAndChildren(p);
-}
-
-void wxPropertyGrid::DrawItemAndChildren( wxPGProperty* p )
-{
-    wxCHECK_RET( p, wxT("invalid property id") );
-
-    // Do not draw if in non-visible page
-    if ( p->GetParentState() != m_pState )
-        return;
-
-    // do not draw a single item if multiple pending
-    if ( m_pState->m_itemsAdded || m_frozen )
-        return;
-
-    // Update child control.
-    if ( m_selected && m_selected->GetParent() == p )
-        RefreshEditor();
-
-    const wxPGProperty* lastDrawn = p->GetLastVisibleSubItem();
-
-    DrawItems(p, lastDrawn);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::Refresh( bool WXUNUSED(eraseBackground),
-                              const wxRect *rect )
-{
-    PrepareAfterItemsAdded();
-
-    wxWindow::Refresh(false);
-    if ( m_canvas )
-        // TODO: Coordinate translation
-        m_canvas->Refresh(false, rect);
-
-#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-    // I think this really helps only GTK+1.2
-    if ( m_wndEditor ) m_wndEditor->Refresh();
-    if ( m_wndEditor2 ) m_wndEditor2->Refresh();
-#endif
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid global operations
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::Clear()
-{
-    m_pState->DoClear();
-
-    m_propHover = NULL;
-
-    m_prevVY = 0;
-
-    RecalculateVirtualSize();
-
-    // Need to clear some area at the end
-    if ( !m_frozen )
-        RefreshRect(wxRect(0, 0, m_width, m_height));
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::EnableCategories( bool enable )
-{
-    ClearSelection(false);
-
-    if ( enable )
-    {
-        //
-        // Enable categories
-        //
-
-        m_windowStyle &= ~(wxPG_HIDE_CATEGORIES);
-    }
-    else
-    {
-        //
-        // Disable categories
-        //
-        m_windowStyle |= wxPG_HIDE_CATEGORIES;
-    }
-
-    if ( !m_pState->EnableCategories(enable) )
-        return false;
-
-    if ( !m_frozen )
-    {
-        if ( m_windowStyle & wxPG_AUTO_SORT )
-        {
-            m_pState->m_itemsAdded = 1; // force
-            PrepareAfterItemsAdded();
-        }
-    }
-    else
-        m_pState->m_itemsAdded = 1;
-
-    // No need for RecalculateVirtualSize() here - it is already called in
-    // wxPropertyGridPageState method above.
-
-    Refresh();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SwitchState( wxPropertyGridPageState* pNewState )
-{
-    wxASSERT( pNewState );
-    wxASSERT( pNewState->GetGrid() );
-
-    if ( pNewState == m_pState )
-        return;
-
-    wxPGProperty* oldSelection = m_selected;
-
-    ClearSelection(false);
-
-    m_pState->m_selected = oldSelection;
-
-    bool orig_mode = m_pState->IsInNonCatMode();
-    bool new_state_mode = pNewState->IsInNonCatMode();
-
-    m_pState = pNewState;
-
-    // Validate width
-    int pgWidth = GetClientSize().x;
-    if ( HasVirtualWidth() )
-    {
-        int minWidth = pgWidth;
-        if ( pNewState->m_width < minWidth )
-        {
-            pNewState->m_width = minWidth;
-            pNewState->CheckColumnWidths();
-        }
-    }
-    else
-    {
-        //
-        // Just in case, fully re-center splitter
-        if ( HasFlag( wxPG_SPLITTER_AUTO_CENTER ) )
-            pNewState->m_fSplitterX = -1.0;
-
-        pNewState->OnClientWidthChange( pgWidth, pgWidth - pNewState->m_width );
-    }
-
-    m_propHover = NULL;
-
-    // If necessary, convert state to correct mode.
-    if ( orig_mode != new_state_mode )
-    {
-        // This should refresh as well.
-        EnableCategories( orig_mode?false:true );
-    }
-    else if ( !m_frozen )
-    {
-        // Refresh, if not frozen.
-        m_pState->PrepareAfterItemsAdded();
-
-        // Reselect
-        if ( m_pState->m_selected )
-            DoSelectProperty( m_pState->m_selected );
-
-        RecalculateVirtualSize(0);
-        Refresh();
-    }
-    else
-        m_pState->m_itemsAdded = 1;
-}
-
-// -----------------------------------------------------------------------
-
-// Call to SetSplitterPosition will always disable splitter auto-centering
-// if parent window is shown.
-void wxPropertyGrid::DoSetSplitterPosition_( int newxpos, bool refresh, int splitterIndex, bool allPages )
-{
-    if ( ( newxpos < wxPG_DRAG_MARGIN ) )
-        return;
-
-    wxPropertyGridPageState* state = m_pState;
-
-    state->DoSetSplitterPosition( newxpos, splitterIndex, allPages );
-
-    if ( refresh )
-    {
-        if ( m_selected )
-            CorrectEditorWidgetSizeX();
-
-        Refresh();
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::CenterSplitter( bool enableAutoCentering )
-{
-    SetSplitterPosition( m_width/2, true );
-    if ( enableAutoCentering && ( m_windowStyle & wxPG_SPLITTER_AUTO_CENTER ) )
-        m_iFlags &= ~(wxPG_FL_DONT_CENTER_SPLITTER);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid item iteration (GetNextProperty etc.) methods
-// -----------------------------------------------------------------------
-
-// Returns nearest paint visible property (such that will be painted unless
-// window is scrolled or resized). If given property is paint visible, then
-// it itself will be returned
-wxPGProperty* wxPropertyGrid::GetNearestPaintVisible( wxPGProperty* p ) const
-{
-    int vx,vy1;// Top left corner of client
-    GetViewStart(&vx,&vy1);
-    vy1 *= wxPG_PIXELS_PER_UNIT;
-
-    int vy2 = vy1 + m_height;
-    int propY = p->GetY2(m_lineHeight);
-
-    if ( (propY + m_lineHeight) < vy1 )
-    {
-    // Too high
-        return DoGetItemAtY( vy1 );
-    }
-    else if ( propY > vy2 )
-    {
-    // Too low
-        return DoGetItemAtY( vy2 );
-    }
-
-    // Itself paint visible
-    return p;
-
-}
-
-// -----------------------------------------------------------------------
-// Methods related to change in value, value modification and sending events
-// -----------------------------------------------------------------------
-
-// commits any changes in editor of selected property
-// return true if validation did not fail
-// flags are same as with DoSelectProperty
-bool wxPropertyGrid::CommitChangesFromEditor( wxUint32 flags )
-{
-    // Committing already?
-    if ( m_inCommitChangesFromEditor )
-        return true;
-
-    // Don't do this if already processing editor event. It might
-    // induce recursive dialogs and crap like that.
-    if ( m_iFlags & wxPG_FL_IN_HANDLECUSTOMEDITOREVENT )
-    {
-        if ( m_inDoPropertyChanged )
-            return true;
-
-        return false;
-    }
-
-    if ( m_wndEditor &&
-         IsEditorsValueModified() &&
-         (m_iFlags & wxPG_FL_INITIALIZED) &&
-         m_selected )
-    {
-        m_inCommitChangesFromEditor = 1;
-
-        wxVariant variant(m_selected->GetValueRef());
-        bool valueIsPending = false;
-
-        // JACS - necessary to avoid new focus being found spuriously within OnIdle
-        // due to another window getting focus
-        wxWindow* oldFocus = m_curFocused;
-
-        bool validationFailure = false;
-        bool forceSuccess = (flags & (wxPG_SEL_NOVALIDATE|wxPG_SEL_FORCE)) ? true : false;
-
-        m_chgInfo_changedProperty = NULL;
-
-        // If truly modified, schedule value as pending.
-        if ( m_selected->GetEditorClass()->GetValueFromControl( variant, m_selected, GetEditorControl() ) )
-        {
-            if ( DoEditorValidate() &&
-                 PerformValidation(m_selected, variant) )
-            {
-                valueIsPending = true;
-            }
-            else
-            {
-                validationFailure = true;
-            }
-        }
-        else
-        {
-            EditorsValueWasNotModified();
-        }
-
-        bool res = true;
-
-        m_inCommitChangesFromEditor = 0;
-
-        if ( validationFailure && !forceSuccess )
-        {
-            if (oldFocus)
-            {
-                oldFocus->SetFocus();
-                m_curFocused = oldFocus;
-            }
-
-            res = OnValidationFailure(m_selected, variant);
-
-            // Now prevent further validation failure messages
-            if ( res )
-            {
-                EditorsValueWasNotModified();
-                OnValidationFailureReset(m_selected);
-            }
-        }
-        else if ( valueIsPending )
-        {
-            DoPropertyChanged( m_selected, flags );
-            EditorsValueWasNotModified();
-        }
-
-        return res;
-    }
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::PerformValidation( wxPGProperty* p, wxVariant& pendingValue,
-                                        int flags )
-{
-    //
-    // Runs all validation functionality.
-    // Returns true if value passes all tests.
-    //
-
-    m_validationInfo.m_failureBehavior = m_permanentValidationFailureBehavior;
-
-    if ( pendingValue.GetType() == wxPG_VARIANT_TYPE_LIST )
-    {
-        if ( !p->ValidateValue(pendingValue, m_validationInfo) )
-            return false;
-    }
-
-    //
-    // Adapt list to child values, if necessary
-    wxVariant listValue = pendingValue;
-    wxVariant* pPendingValue = &pendingValue;
-    wxVariant* pList = NULL;
-
-    // If parent has wxPG_PROP_AGGREGATE flag, or uses composite
-    // string value, then we need treat as it was changed instead
-    // (or, in addition, as is the case with composite string parent).
-    // This includes creating list variant for child values.
-
-    wxPGProperty* pwc = p->GetParent();
-    wxPGProperty* changedProperty = p;
-    wxPGProperty* baseChangedProperty = changedProperty;
-    wxVariant bcpPendingList;
-
-    listValue = pendingValue;
-    listValue.SetName(p->GetBaseName());
-
-    while ( pwc &&
-            (pwc->HasFlag(wxPG_PROP_AGGREGATE) || pwc->HasFlag(wxPG_PROP_COMPOSED_VALUE)) )
-    {
-        wxVariantList tempList;
-        wxVariant lv(tempList, pwc->GetBaseName());
-        lv.Append(listValue);
-        listValue = lv;
-        pPendingValue = &listValue;
-
-        if ( pwc->HasFlag(wxPG_PROP_AGGREGATE) )
-        {
-            baseChangedProperty = pwc;
-            bcpPendingList = lv;
-        }
-
-        changedProperty = pwc;
-        pwc = pwc->GetParent();
-    }
-
-    wxVariant value;
-    wxPGProperty* evtChangingProperty = changedProperty;
-
-    if ( pPendingValue->GetType() != wxPG_VARIANT_TYPE_LIST )
-    {
-        value = *pPendingValue;
-    }
-    else
-    {
-        // Convert list to child values
-        pList = pPendingValue;
-        changedProperty->AdaptListToValue( *pPendingValue, &value );
-    }
-
-    wxVariant evtChangingValue = value;
-
-    if ( flags & SendEvtChanging )
-    {
-        // FIXME: After proper ValueToString()s added, remove
-        // this. It is just a temporary fix, as evt_changing
-        // will simply not work for wxPG_PROP_COMPOSED_VALUE
-        // (unless it is selected, and textctrl editor is open).
-        if ( changedProperty->HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-        {
-            evtChangingProperty = baseChangedProperty;
-            if ( evtChangingProperty != p )
-            {
-                evtChangingProperty->AdaptListToValue( bcpPendingList, &evtChangingValue );
-            }
-            else
-            {
-                evtChangingValue = pendingValue;
-            }
-        }
-
-        if ( evtChangingProperty->HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-        {
-            if ( changedProperty == m_selected )
-            {
-                wxWindow* editor = GetEditorControl();
-                wxASSERT( editor->IsKindOf(CLASSINFO(wxTextCtrl)) );
-                evtChangingValue = wxStaticCast(editor, wxTextCtrl)->GetValue();
-            }
-            else
-            {
-                wxLogDebug(wxT("WARNING: wxEVT_PG_CHANGING is about to happen with old value."));
-            }
-        }
-    }
-
-    wxASSERT( m_chgInfo_changedProperty == NULL );
-    m_chgInfo_changedProperty = changedProperty;
-    m_chgInfo_baseChangedProperty = baseChangedProperty;
-    m_chgInfo_pendingValue = value;
-
-    if ( pList )
-        m_chgInfo_valueList = *pList;
-    else
-        m_chgInfo_valueList.MakeNull();
-
-    // If changedProperty is not property which value was edited,
-    // then call wxPGProperty::ValidateValue() for that as well.
-    if ( p != changedProperty && value.GetType() != wxPG_VARIANT_TYPE_LIST )
-    {
-        if ( !changedProperty->ValidateValue(value, m_validationInfo) )
-            return false;
-    }
-
-    if ( flags & SendEvtChanging )
-    {
-        // SendEvent returns true if event was vetoed
-        if ( SendEvent( wxEVT_PG_CHANGING, evtChangingProperty, &evtChangingValue, 0 ) )
-            return false;
-    }
-
-    if ( flags & IsStandaloneValidation )
-    {
-        // If called in 'generic' context, we need to reset
-        // m_chgInfo_changedProperty and write back translated value.
-        m_chgInfo_changedProperty = NULL;
-        pendingValue = value;
-    }
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::DoShowPropertyError( wxPGProperty* WXUNUSED(property), const wxString& msg )
-{
-    if ( !msg.length() )
-        return;
-
-#if wxUSE_STATUSBAR
-    if ( !wxPGGlobalVars->m_offline )
-    {
-        wxWindow* topWnd = ::wxGetTopLevelParent(this);
-        if ( topWnd )
-        {
-            wxFrame* pFrame = wxDynamicCast(topWnd, wxFrame);
-            if ( pFrame )
-            {
-                wxStatusBar* pStatusBar = pFrame->GetStatusBar();
-                if ( pStatusBar )
-                {
-                    pStatusBar->SetStatusText(msg);
-                    return;
-                }
-            }
-        }
-    }
-#endif
-
-    ::wxMessageBox(msg, _T("Property Error"));
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::OnValidationFailure( wxPGProperty* property,
-                                          wxVariant& invalidValue )
-{
-    wxWindow* editor = GetEditorControl();
-
-    // First call property's handler
-    property->OnValidationFailure(invalidValue);
-
-    bool res = DoOnValidationFailure(property, invalidValue);
-
-    //
-    // For non-wxTextCtrl editors, we do need to revert the value
-    if ( !editor->IsKindOf(CLASSINFO(wxTextCtrl)) &&
-         property == m_selected )
-    {
-        property->GetEditorClass()->UpdateControl(property, editor);
-    }
-
-    property->SetFlag(wxPG_PROP_INVALID_VALUE);
-
-    return res;
-}
-
-bool wxPropertyGrid::DoOnValidationFailure( wxPGProperty* property, wxVariant& WXUNUSED(invalidValue) )
-{
-    int vfb = m_validationInfo.m_failureBehavior;
-
-    if ( vfb & wxPG_VFB_BEEP )
-        ::wxBell();
-
-    if ( (vfb & wxPG_VFB_MARK_CELL) &&
-         !property->HasFlag(wxPG_PROP_INVALID_VALUE) )
-    {
-        unsigned int colCount = m_pState->GetColumnCount();
-
-        // We need backup marked property's cells
-        m_propCellsBackup = property->m_cells;
-
-        wxColour vfbFg = *wxWHITE;
-        wxColour vfbBg = *wxRED;
-
-        property->EnsureCells(colCount);
-
-        for ( unsigned int i=0; i<colCount; i++ )
-        {
-            wxPGCell& cell = property->m_cells[i];
-            cell.SetFgCol(vfbFg);
-            cell.SetBgCol(vfbBg);
-        }
-
-        DrawItemAndChildren(property);
-
-        if ( property == m_selected )
-        {
-            SetInternalFlag(wxPG_FL_CELL_OVERRIDES_SEL);
-
-            wxWindow* editor = GetEditorControl();
-            if ( editor )
-            {
-                editor->SetForegroundColour(vfbFg);
-                editor->SetBackgroundColour(vfbBg);
-            }
-        }
-    }
-
-    if ( vfb & wxPG_VFB_SHOW_MESSAGE )
-    {
-        wxString msg = m_validationInfo.m_failureMessage;
-
-        if ( !msg.length() )
-            msg = _T("You have entered invalid value. Press ESC to cancel editing.");
-
-        DoShowPropertyError(property, msg);
-    }
-
-    return (vfb & wxPG_VFB_STAY_IN_PROPERTY) ? false : true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::DoOnValidationFailureReset( wxPGProperty* property )
-{
-    int vfb = m_validationInfo.m_failureBehavior;
-
-    if ( vfb & wxPG_VFB_MARK_CELL )
-    {
-        // Revert cells
-        property->m_cells = m_propCellsBackup;
-
-        ClearInternalFlag(wxPG_FL_CELL_OVERRIDES_SEL);
-
-        if ( property == m_selected && GetEditorControl() )
-        {
-            // Calling this will recreate the control, thus resetting its colour
-            RefreshProperty(property);
-        }
-        else
-        {
-            DrawItemAndChildren(property);
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-// flags are same as with DoSelectProperty
-bool wxPropertyGrid::DoPropertyChanged( wxPGProperty* p, unsigned int selFlags )
-{
-    if ( m_inDoPropertyChanged )
-        return true;
-
-    wxWindow* editor = GetEditorControl();
-
-    m_pState->m_anyModified = 1;
-
-    m_inDoPropertyChanged = 1;
-
-    // Maybe need to update control
-    wxASSERT( m_chgInfo_changedProperty != NULL );
-
-    // These values were calculated in PerformValidation()
-    wxPGProperty* changedProperty = m_chgInfo_changedProperty;
-    wxVariant value = m_chgInfo_pendingValue;
-
-    wxPGProperty* topPaintedProperty = changedProperty;
-
-    while ( !topPaintedProperty->IsCategory() &&
-            !topPaintedProperty->IsRoot() )
-    {
-        topPaintedProperty = topPaintedProperty->GetParent();
-    }
-
-    changedProperty->SetValue(value, &m_chgInfo_valueList, wxPG_SETVAL_BY_USER);
-
-    // Set as Modified (not if dragging just began)
-    if ( !(p->m_flags & wxPG_PROP_MODIFIED) )
-    {
-        p->m_flags |= wxPG_PROP_MODIFIED;
-        if ( p == m_selected && (m_windowStyle & wxPG_BOLD_MODIFIED) )
-        {
-            if ( editor )
-                SetCurControlBoldFont();
-        }
-    }
-
-    wxPGProperty* pwc;
-
-    // Propagate updates to parent(s)
-    pwc = p;
-    wxPGProperty* prevPwc = NULL;
-
-    while ( prevPwc != topPaintedProperty )
-    {
-        pwc->m_flags |= wxPG_PROP_MODIFIED;
-
-        if ( pwc == m_selected && (m_windowStyle & wxPG_BOLD_MODIFIED) )
-        {
-            if ( editor )
-                SetCurControlBoldFont();
-        }
-
-        prevPwc = pwc;
-        pwc = pwc->GetParent();
-    }
-
-    // Draw the actual property
-    DrawItemAndChildren( topPaintedProperty );
-
-    //
-    // If value was set by wxPGProperty::OnEvent, then update the editor
-    // control.
-    if ( selFlags & wxPG_SEL_DIALOGVAL )
-    {
-        RefreshEditor();
-    }
-    else
-    {
-#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-        if ( m_wndEditor ) m_wndEditor->Refresh();
-        if ( m_wndEditor2 ) m_wndEditor2->Refresh();
-#endif
-    }
-
-    // Sanity check
-    wxASSERT( !changedProperty->GetParent()->HasFlag(wxPG_PROP_AGGREGATE) );
-
-    // If top parent has composite string value, then send to child parents,
-    // starting from baseChangedProperty.
-    if ( changedProperty->HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-    {
-        pwc = m_chgInfo_baseChangedProperty;
-
-        while ( pwc != changedProperty )
-        {
-            SendEvent( wxEVT_PG_CHANGED, pwc, NULL, selFlags );
-            pwc = pwc->GetParent();
-        }
-    }
-
-    SendEvent( wxEVT_PG_CHANGED, changedProperty, NULL, selFlags );
-
-    m_inDoPropertyChanged = 0;
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::ChangePropertyValue( wxPGPropArg id, wxVariant newValue )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-
-    m_chgInfo_changedProperty = NULL;
-
-    if ( PerformValidation(p, newValue) )
-    {
-        DoPropertyChanged(p);
-        return true;
-    }
-    else
-    {
-        OnValidationFailure(p, newValue);
-    }
-
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-wxVariant wxPropertyGrid::GetUncommittedPropertyValue()
-{
-    wxPGProperty* prop = GetSelectedProperty();
-
-    if ( !prop )
-        return wxNullVariant;
-
-    wxTextCtrl* tc = GetEditorTextCtrl();
-    wxVariant value = prop->GetValue();
-
-    if ( !tc || !IsEditorsValueModified() )
-        return value;
-
-    if ( !prop->StringToValue(value, tc->GetValue()) )
-        return value;
-
-    if ( !PerformValidation(prop, value, IsStandaloneValidation) )
-        return prop->GetValue();
-
-    return value;
-}
-
-// -----------------------------------------------------------------------
-
-// Runs wxValidator for the selected property
-bool wxPropertyGrid::DoEditorValidate()
-{
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::HandleCustomEditorEvent( wxEvent &event )
-{
-    wxPGProperty* selected = m_selected;
-
-    // Somehow, event is handled after property has been deselected.
-    // Possibly, but very rare.
-    if ( !selected )
-        return;
-
-    if ( m_iFlags & wxPG_FL_IN_HANDLECUSTOMEDITOREVENT )
-        return;
-
-    wxVariant pendingValue(selected->GetValueRef());
-    wxWindow* wnd = GetEditorControl();
-    wxWindow* editorWnd = wxDynamicCast(event.GetEventObject(), wxWindow);
-    int selFlags = 0;
-    bool wasUnspecified = selected->IsValueUnspecified();
-    int usesAutoUnspecified = selected->UsesAutoUnspecified();
-    bool valueIsPending = false;
-
-    m_chgInfo_changedProperty = NULL;
-
-    m_iFlags &= ~(wxPG_FL_VALIDATION_FAILED|wxPG_FL_VALUE_CHANGE_IN_EVENT);
-
-    //
-    // Filter out excess wxTextCtrl modified events
-    if ( event.GetEventType() == wxEVT_COMMAND_TEXT_UPDATED &&
-         wnd &&
-         wnd->IsKindOf(CLASSINFO(wxTextCtrl)) )
-    {
-        wxTextCtrl* tc = (wxTextCtrl*) wnd;
-
-        wxString newTcValue = tc->GetValue();
-        if ( m_prevTcValue == newTcValue )
-            return;
-
-        m_prevTcValue = newTcValue;
-    }
-
-    SetInternalFlag(wxPG_FL_IN_HANDLECUSTOMEDITOREVENT);
-
-    bool validationFailure = false;
-    bool buttonWasHandled = false;
-
-    //
-    // Try common button handling
-    if ( m_wndEditor2 && event.GetEventType() == wxEVT_COMMAND_BUTTON_CLICKED )
-    {
-        wxPGEditorDialogAdapter* adapter = selected->GetEditorDialog();
-
-        if ( adapter )
-        {
-            buttonWasHandled = true;
-            // Store as res2, as previously (and still currently alternatively)
-            // dialogs can be shown by handling wxEVT_COMMAND_BUTTON_CLICKED
-            // in wxPGProperty::OnEvent().
-            adapter->ShowDialog( this, selected );
-            delete adapter;
-        }
-    }
-
-    if ( !buttonWasHandled )
-    {
-        if ( wnd || m_wndEditor2 )
-        {
-            // First call editor class' event handler.
-            const wxPGEditor* editor = selected->GetEditorClass();
-
-            if ( editor->OnEvent( this, selected, editorWnd, event ) )
-            {
-                // If changes, validate them
-                if ( DoEditorValidate() )
-                {
-                    if ( editor->GetValueFromControl( pendingValue,
-                                                      m_selected,
-                                                      wnd ) )
-                        valueIsPending = true;
-                }
-                else
-                {
-                    validationFailure = true;
-                }
-            }
-        }
-
-        // Then the property's custom handler (must be always called, unless
-        // validation failed).
-        if ( !validationFailure )
-            buttonWasHandled = selected->OnEvent( this, editorWnd, event );
-    }
-
-    // SetValueInEvent(), as called in one of the functions referred above
-    // overrides editor's value.
-    if ( m_iFlags & wxPG_FL_VALUE_CHANGE_IN_EVENT )
-    {
-        valueIsPending = true;
-        pendingValue = m_changeInEventValue;
-        selFlags |= wxPG_SEL_DIALOGVAL;
-    }
-
-    if ( !validationFailure && valueIsPending )
-        if ( !PerformValidation(m_selected, pendingValue) )
-            validationFailure = true;
-
-    if ( validationFailure)
-    {
-        OnValidationFailure(selected, pendingValue);
-    }
-    else if ( valueIsPending )
-    {
-        selFlags |= ( !wasUnspecified && selected->IsValueUnspecified() && usesAutoUnspecified ) ? wxPG_SEL_SETUNSPEC : 0;
-
-        DoPropertyChanged(selected, selFlags);
-        EditorsValueWasNotModified();
-
-        // Regardless of editor type, unfocus editor on
-        // text-editing related enter press.
-        if ( event.GetEventType() == wxEVT_COMMAND_TEXT_ENTER )
-        {
-            SetFocusOnCanvas();
-        }
-    }
-    else
-    {
-        // No value after all
-
-        // Regardless of editor type, unfocus editor on
-        // text-editing related enter press.
-        if ( event.GetEventType() == wxEVT_COMMAND_TEXT_ENTER )
-        {
-            SetFocusOnCanvas();
-        }
-
-        // Let unhandled button click events go to the parent
-        if ( !buttonWasHandled && event.GetEventType() == wxEVT_COMMAND_BUTTON_CLICKED )
-        {
-            wxCommandEvent evt(wxEVT_COMMAND_BUTTON_CLICKED,GetId());
-            GetEventHandler()->AddPendingEvent(evt);
-        }
-    }
-
-    ClearInternalFlag(wxPG_FL_IN_HANDLECUSTOMEDITOREVENT);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid editor control helper methods
-// -----------------------------------------------------------------------
-
-wxRect wxPropertyGrid::GetEditorWidgetRect( wxPGProperty* p, int column ) const
-{
-    int itemy = p->GetY2(m_lineHeight);
-    int vy = 0;
-    int splitterX = m_pState->DoGetSplitterPosition(column-1);
-    int colEnd = splitterX + m_pState->m_colWidths[column];
-    int imageOffset = 0;
-
-    // TODO: If custom image detection changes from current, change this.
-    if ( m_iFlags & wxPG_FL_CUR_USES_CUSTOM_IMAGE )
-    {
-        //m_iFlags |= wxPG_FL_CUR_USES_CUSTOM_IMAGE;
-        int iw = p->OnMeasureImage().x;
-        if ( iw < 1 )
-            iw = wxPG_CUSTOM_IMAGE_WIDTH;
-        imageOffset = p->GetImageOffset(iw);
-    }
-
-    return wxRect
-      (
-        splitterX+imageOffset+wxPG_XBEFOREWIDGET+wxPG_CONTROL_MARGIN+1,
-        itemy-vy,
-        colEnd-splitterX-wxPG_XBEFOREWIDGET-wxPG_CONTROL_MARGIN-imageOffset-1,
-        m_lineHeight-1
-      );
-}
-
-// -----------------------------------------------------------------------
-
-wxRect wxPropertyGrid::GetImageRect( wxPGProperty* p, int item ) const
-{
-    wxSize sz = GetImageSize(p, item);
-    return wxRect(wxPG_CONTROL_MARGIN + wxCC_CUSTOM_IMAGE_MARGIN1,
-                  wxPG_CUSTOM_IMAGE_SPACINGY,
-                  sz.x,
-                  sz.y);
-}
-
-// return size of custom paint image
-wxSize wxPropertyGrid::GetImageSize( wxPGProperty* p, int item ) const
-{
-    // If called with NULL property, then return default image
-    // size for properties that use image.
-    if ( !p )
-        return wxSize(wxPG_CUSTOM_IMAGE_WIDTH,wxPG_STD_CUST_IMAGE_HEIGHT(m_lineHeight));
-
-    wxSize cis = p->OnMeasureImage(item);
-
-    int choiceCount = p->m_choices.GetCount();
-    int comVals = p->GetDisplayedCommonValueCount();
-    if ( item >= choiceCount && comVals > 0 )
-    {
-        unsigned int cvi = item-choiceCount;
-        cis = GetCommonValue(cvi)->GetRenderer()->GetImageSize(NULL, 1, cvi);
-    }
-    else if ( item >= 0 && choiceCount == 0 )
-        return wxSize(0, 0);
-
-    if ( cis.x < 0 )
-    {
-        if ( cis.x <= -1 )
-            cis.x = wxPG_CUSTOM_IMAGE_WIDTH;
-    }
-    if ( cis.y <= 0 )
-    {
-        if ( cis.y >= -1 )
-            cis.y = wxPG_STD_CUST_IMAGE_HEIGHT(m_lineHeight);
-        else
-            cis.y = -cis.y;
-    }
-    return cis;
-}
-
-// -----------------------------------------------------------------------
-
-// takes scrolling into account
-void wxPropertyGrid::ImprovedClientToScreen( int* px, int* py )
-{
-    int vx, vy;
-    GetViewStart(&vx,&vy);
-    vy*=wxPG_PIXELS_PER_UNIT;
-    vx*=wxPG_PIXELS_PER_UNIT;
-    *px -= vx;
-    *py -= vy;
-    ClientToScreen( px, py );
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridHitTestResult wxPropertyGrid::HitTest( const wxPoint& pt ) const
-{
-    wxPoint pt2;
-    GetViewStart(&pt2.x,&pt2.y);
-    pt2.x *= wxPG_PIXELS_PER_UNIT;
-    pt2.y *= wxPG_PIXELS_PER_UNIT;
-    pt2.x += pt.x;
-    pt2.y += pt.y;
-
-    return m_pState->HitTest(pt2);
-}
-
-// -----------------------------------------------------------------------
-
-// custom set cursor
-void wxPropertyGrid::CustomSetCursor( int type, bool override )
-{
-    if ( type == m_curcursor && !override ) return;
-
-    wxCursor* cursor = &wxPG_DEFAULT_CURSOR;
-
-    if ( type == wxCURSOR_SIZEWE )
-        cursor = m_cursorSizeWE;
-
-    m_canvas->SetCursor( *cursor );
-
-    m_curcursor = type;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid property selection, editor creation
-// -----------------------------------------------------------------------
-
-//
-// This class forwards events from property editor controls to wxPropertyGrid.
-class wxPropertyGridEditorEventForwarder : public wxEvtHandler
-{
-public:
-    wxPropertyGridEditorEventForwarder( wxPropertyGrid* propGrid )
-        : wxEvtHandler(), m_propGrid(propGrid)
-    {
-    }
-
-    virtual ~wxPropertyGridEditorEventForwarder()
-    {
-    }
-
-private:
-    bool ProcessEvent( wxEvent& event )
-    {
-        // Always skip
-        event.Skip();
-
-        m_propGrid->HandleCustomEditorEvent(event);
-
-        return wxEvtHandler::ProcessEvent(event);
-    }
-
-    wxPropertyGrid*         m_propGrid;
-};
-
-// Setups event handling for child control
-void wxPropertyGrid::SetupChildEventHandling( wxWindow* argWnd )
-{
-    wxWindowID id = argWnd->GetId();
-
-    if ( argWnd == m_wndEditor )
-    {
-        argWnd->Connect(id, wxEVT_MOTION,
-            wxMouseEventHandler(wxPropertyGrid::OnMouseMoveChild),
-            NULL, this);
-        argWnd->Connect(id, wxEVT_LEFT_UP,
-            wxMouseEventHandler(wxPropertyGrid::OnMouseUpChild),
-            NULL, this);
-        argWnd->Connect(id, wxEVT_LEFT_DOWN,
-            wxMouseEventHandler(wxPropertyGrid::OnMouseClickChild),
-            NULL, this);
-        argWnd->Connect(id, wxEVT_RIGHT_UP,
-            wxMouseEventHandler(wxPropertyGrid::OnMouseRightClickChild),
-            NULL, this);
-        argWnd->Connect(id, wxEVT_ENTER_WINDOW,
-            wxMouseEventHandler(wxPropertyGrid::OnMouseEntry),
-            NULL, this);
-        argWnd->Connect(id, wxEVT_LEAVE_WINDOW,
-            wxMouseEventHandler(wxPropertyGrid::OnMouseEntry),
-            NULL, this);
-    }
-
-    wxPropertyGridEditorEventForwarder* forwarder;
-    forwarder = new wxPropertyGridEditorEventForwarder(this);
-    argWnd->PushEventHandler(forwarder);
-
-    argWnd->Connect(id, wxEVT_KEY_DOWN,
-        wxCharEventHandler(wxPropertyGrid::OnChildKeyDown),
-        NULL, this);
-}
-
-void wxPropertyGrid::FreeEditors()
-{
-    //
-    // Return focus back to canvas from children (this is required at least for
-    // GTK+, which, unlike Windows, clears focus when control is destroyed
-    // instead of moving it to closest parent).
-    wxWindow* focus = wxWindow::FindFocus();
-    if ( focus )
-    {
-        wxWindow* parent = focus->GetParent();
-        while ( parent )
-        {
-            if ( parent == m_canvas )
-            {
-                SetFocusOnCanvas();
-                break;
-            }
-            parent = parent->GetParent();
-        }
-    }
-
-    // Do not free editors immediately if processing events
-    if ( m_wndEditor2 )
-    {
-        wxEvtHandler* handler = m_wndEditor2->PopEventHandler(false);
-        m_wndEditor2->Hide();
-        wxPendingDelete.Append( handler );
-        wxPendingDelete.Append( m_wndEditor2 );
-        m_wndEditor2 = NULL;
-    }
-
-    if ( m_wndEditor )
-    {
-        wxEvtHandler* handler = m_wndEditor->PopEventHandler(false);
-        m_wndEditor->Hide();
-        wxPendingDelete.Append( handler );
-        wxPendingDelete.Append( m_wndEditor );
-        m_wndEditor = NULL;
-    }
-}
-
-// Call with NULL to de-select property
-bool wxPropertyGrid::DoSelectProperty( wxPGProperty* p, unsigned int flags )
-{
-    /*
-    if (p)
-        wxLogDebug(wxT("SelectProperty( %s (%s[%i]) )"),p->m_label.c_str(),
-            p->m_parent->m_label.c_str(),p->GetIndexInParent());
-    else
-        wxLogDebug(wxT("SelectProperty( NULL, -1 )"));
-    */
-
-    if ( m_inDoSelectProperty )
-        return true;
-
-    m_inDoSelectProperty = 1;
-
-    wxPGProperty* prev = m_selected;
-
-    if ( !m_pState )
-    {
-        m_inDoSelectProperty = 0;
-        return false;
-    }
-
-/*
-    if (m_selected)
-        wxPrintf( "Selected %s\n", m_selected->GetClassInfo()->GetClassName() );
-    else
-        wxPrintf( "None selected\n" );
-
-    if (p)
-        wxPrintf( "P =  %s\n", p->GetClassInfo()->GetClassName() );
-    else
-        wxPrintf( "P = NULL\n" );
-*/
-
-    // If we are frozen, then just set the values.
-    if ( m_frozen )
-    {
-        m_iFlags &= ~(wxPG_FL_ABNORMAL_EDITOR);
-        m_editorFocused = 0;
-        m_selected = p;
-        m_selColumn = 1;
-        m_pState->m_selected = p;
-
-        // If frozen, always free controls. But don't worry, as Thaw will
-        // recall SelectProperty to recreate them.
-        FreeEditors();
-
-        // Prevent any further selection measures in this call
-        p = NULL;
-    }
-    else
-    {
-        // Is it the same?
-        if ( m_selected == p && !(flags & wxPG_SEL_FORCE) )
-        {
-            // Only set focus if not deselecting
-            if ( p )
-            {
-                if ( flags & wxPG_SEL_FOCUS )
-                {
-                    if ( m_wndEditor )
-                    {
-                        m_wndEditor->SetFocus();
-                        m_editorFocused = 1;
-                    }
-                }
-                else
-                {
-                    SetFocusOnCanvas();
-                }
-            }
-
-            m_inDoSelectProperty = 0;
-            return true;
-        }
-
-        //
-        // First, deactivate previous
-        if ( m_selected )
-        {
-
-            OnValidationFailureReset(m_selected);
-
-            // Must double-check if this is an selected in case of forceswitch
-            if ( p != prev )
-            {
-                if ( !CommitChangesFromEditor(flags) )
-                {
-                    // Validation has failed, so we can't exit the previous editor
-                    //::wxMessageBox(_("Please correct the value or press ESC to cancel the edit."),
-                    //               _("Invalid Value"),wxOK|wxICON_ERROR);
-                    m_inDoSelectProperty = 0;
-                    return false;
-                }
-            }
-
-            FreeEditors();
-            m_selColumn = -1;
-
-            m_selected = NULL;
-            m_pState->m_selected = NULL;
-
-            // We need to always fully refresh the grid here
-            Refresh(false);
-
-            m_iFlags &= ~(wxPG_FL_ABNORMAL_EDITOR);
-            EditorsValueWasNotModified();
-        }
-
-        SetInternalFlag(wxPG_FL_IN_SELECT_PROPERTY);
-
-        //
-        // Then, activate the one given.
-        if ( p )
-        {
-            int propY = p->GetY2(m_lineHeight);
-
-            int splitterX = GetSplitterPosition();
-            m_editorFocused = 0;
-            m_selected = p;
-            m_pState->m_selected = p;
-            m_iFlags |= wxPG_FL_PRIMARY_FILLS_ENTIRE;
-            if ( p != prev )
-                m_iFlags &= ~(wxPG_FL_VALIDATION_FAILED);
-
-            wxASSERT( m_wndEditor == NULL );
-
-            //
-            // Only create editor for non-disabled non-caption
-            if ( !p->IsCategory() && !(p->m_flags & wxPG_PROP_DISABLED) )
-            {
-            // do this for non-caption items
-
-                m_selColumn = 1;
-
-                // Do we need to paint the custom image, if any?
-                m_iFlags &= ~(wxPG_FL_CUR_USES_CUSTOM_IMAGE);
-                if ( (p->m_flags & wxPG_PROP_CUSTOMIMAGE) &&
-                     !p->GetEditorClass()->CanContainCustomImage()
-                   )
-                    m_iFlags |= wxPG_FL_CUR_USES_CUSTOM_IMAGE;
-
-                wxRect grect = GetEditorWidgetRect(p, m_selColumn);
-                wxPoint goodPos = grect.GetPosition();
-            #if wxPG_CREATE_CONTROLS_HIDDEN
-                int coord_adjust = m_height - goodPos.y;
-                goodPos.y += coord_adjust;
-            #endif
-
-                const wxPGEditor* editor = p->GetEditorClass();
-                wxCHECK_MSG(editor, false,
-                    wxT("NULL editor class not allowed"));
-
-                m_iFlags &= ~wxPG_FL_FIXED_WIDTH_EDITOR;
-
-                wxPGWindowList wndList = editor->CreateControls(this,
-                                                                p,
-                                                                goodPos,
-                                                                grect.GetSize());
-
-                m_wndEditor = wndList.m_primary;
-                m_wndEditor2 = wndList.m_secondary;
-                wxWindow* primaryCtrl = GetEditorControl();
-
-                //
-                // Essentially, primaryCtrl == m_wndEditor
-                //
-
-                // NOTE: It is allowed for m_wndEditor to be NULL - in this case
-                //       value is drawn as normal, and m_wndEditor2 is assumed
-                //       to be a right-aligned button that triggers a separate editorCtrl
-                //       window.
-
-                if ( m_wndEditor )
-                {
-                    wxASSERT_MSG( m_wndEditor->GetParent() == GetPanel(),
-                                  wxT("CreateControls must use result of wxPropertyGrid::GetPanel() as parent of controls.") );
-
-                    // Set validator, if any
-                #if wxUSE_VALIDATORS
-                    wxValidator* validator = p->GetValidator();
-                    if ( validator )
-                        primaryCtrl->SetValidator(*validator);
-                #endif
-
-                    if ( m_wndEditor->GetSize().y > (m_lineHeight+6) )
-                        m_iFlags |= wxPG_FL_ABNORMAL_EDITOR;
-
-                    // If it has modified status, use bold font
-                    // (must be done before capturing m_ctrlXAdjust)
-                    if ( (p->m_flags & wxPG_PROP_MODIFIED) && (m_windowStyle & wxPG_BOLD_MODIFIED) )
-                        SetCurControlBoldFont();
-
-                    //
-                    // Fix TextCtrl indentation
-                #if defined(__WXMSW__) && !defined(__WXWINCE__)
-                    wxTextCtrl* tc = NULL;
-                    if ( primaryCtrl->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)) )
-                        tc = ((wxOwnerDrawnComboBox*)primaryCtrl)->GetTextCtrl();
-                    else
-                        tc = wxDynamicCast(primaryCtrl, wxTextCtrl);
-                    if ( tc )
-                        ::SendMessage(GetHwndOf(tc), EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELONG(0, 0));
-                #endif
-
-                    // Store x relative to splitter (we'll need it).
-                    m_ctrlXAdjust = m_wndEditor->GetPosition().x - splitterX;
-
-                    // Check if background clear is not necessary
-                    wxPoint pos = m_wndEditor->GetPosition();
-                    if ( pos.x > (splitterX+1) || pos.y > propY )
-                    {
-                        m_iFlags &= ~(wxPG_FL_PRIMARY_FILLS_ENTIRE);
-                    }
-
-                    m_wndEditor->SetSizeHints(3, 3);
-
-                #if wxPG_CREATE_CONTROLS_HIDDEN
-                    m_wndEditor->Show(false);
-                    m_wndEditor->Freeze();
-
-                    goodPos = m_wndEditor->GetPosition();
-                    goodPos.y -= coord_adjust;
-                    m_wndEditor->Move( goodPos );
-                #endif
-
-                    SetupChildEventHandling(primaryCtrl);
-
-                    // Focus and select all (wxTextCtrl, wxComboBox etc)
-                    if ( flags & wxPG_SEL_FOCUS )
-                    {
-                        primaryCtrl->SetFocus();
-
-                        p->GetEditorClass()->OnFocus(p, primaryCtrl);
-                    }
-                }
-
-                if ( m_wndEditor2 )
-                {
-                    wxASSERT_MSG( m_wndEditor2->GetParent() == GetPanel(),
-                                  wxT("CreateControls must use result of wxPropertyGrid::GetPanel() as parent of controls.") );
-
-                    // Get proper id for wndSecondary
-                    m_wndSecId = m_wndEditor2->GetId();
-                    wxWindowList children = m_wndEditor2->GetChildren();
-                    wxWindowList::iterator node = children.begin();
-                    if ( node != children.end() )
-                        m_wndSecId = ((wxWindow*)*node)->GetId();
-
-                    m_wndEditor2->SetSizeHints(3,3);
-
-                #if wxPG_CREATE_CONTROLS_HIDDEN
-                    wxRect sec_rect = m_wndEditor2->GetRect();
-                    sec_rect.y -= coord_adjust;
-
-                    // Fine tuning required to fix "oversized"
-                    // button disappearance bug.
-                    if ( sec_rect.y < 0 )
-                    {
-                        sec_rect.height += sec_rect.y;
-                        sec_rect.y = 0;
-                    }
-                    m_wndEditor2->SetSize( sec_rect );
-                #endif
-                    m_wndEditor2->Show();
-
-                    SetupChildEventHandling(m_wndEditor2);
-
-                    // If no primary editor, focus to button to allow
-                    // it to interprete ENTER etc.
-                    // NOTE: Due to problems focusing away from it, this
-                    //       has been disabled.
-                    /*
-                    if ( (flags & wxPG_SEL_FOCUS) && !m_wndEditor )
-                        m_wndEditor2->SetFocus();
-                    */
-                }
-
-                if ( flags & wxPG_SEL_FOCUS )
-                    m_editorFocused = 1;
-
-            }
-            else
-            {
-                // Make sure focus is in grid canvas (important for wxGTK, at least)
-                SetFocusOnCanvas();
-            }
-
-            EditorsValueWasNotModified();
-
-            // If it's inside collapsed section, expand parent, scroll, etc.
-            // Also, if it was partially visible, scroll it into view.
-            if ( !(flags & wxPG_SEL_NONVISIBLE) )
-                EnsureVisible( p );
-
-            if ( m_wndEditor )
-            {
-            #if wxPG_CREATE_CONTROLS_HIDDEN
-                m_wndEditor->Thaw();
-            #endif
-                m_wndEditor->Show(true);
-            }
-
-            DrawItems(p, p);
-        }
-        else
-        {
-            // Make sure focus is in grid canvas
-            SetFocusOnCanvas();
-        }
-
-        ClearInternalFlag(wxPG_FL_IN_SELECT_PROPERTY);
-    }
-
-#if wxUSE_STATUSBAR
-
-    //
-    // Show help text in status bar.
-    //   (if found and grid not embedded in manager with help box and
-    //    style wxPG_EX_HELP_AS_TOOLTIPS is not used).
-    //
-
-    if ( !(GetExtraStyle() & wxPG_EX_HELP_AS_TOOLTIPS) )
-    {
-        wxStatusBar* statusbar = NULL;
-        if ( !(m_iFlags & wxPG_FL_NOSTATUSBARHELP) )
-        {
-            wxFrame* frame = wxDynamicCast(::wxGetTopLevelParent(this),wxFrame);
-            if ( frame )
-                statusbar = frame->GetStatusBar();
-        }
-
-        if ( statusbar )
-        {
-            const wxString* pHelpString = (const wxString*) NULL;
-
-            if ( p )
-            {
-                pHelpString = &p->GetHelpString();
-                if ( pHelpString->length() )
-                {
-                    // Set help box text.
-                    statusbar->SetStatusText( *pHelpString );
-                    m_iFlags |= wxPG_FL_STRING_IN_STATUSBAR;
-                }
-            }
-
-            if ( (!pHelpString || !pHelpString->length()) &&
-                 (m_iFlags & wxPG_FL_STRING_IN_STATUSBAR) )
-            {
-                // Clear help box - but only if it was written
-                // by us at previous time.
-                statusbar->SetStatusText( m_emptyString );
-                m_iFlags &= ~(wxPG_FL_STRING_IN_STATUSBAR);
-            }
-        }
-    }
-#endif
-
-    m_inDoSelectProperty = 0;
-
-    // call wx event handler (here so that it also occurs on deselection)
-    SendEvent( wxEVT_PG_SELECTED, m_selected, NULL, flags );
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::UnfocusEditor()
-{
-    if ( !m_selected || !m_wndEditor || m_frozen )
-        return true;
-
-    if ( !CommitChangesFromEditor(0) )
-        return false;
-
-    SetFocusOnCanvas();
-    DrawItem(m_selected);
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::RefreshEditor()
-{
-    wxPGProperty* p = m_selected;
-    if ( !p ) 
-        return;
-
-    wxWindow* wnd = GetEditorControl();
-    if ( !wnd )
-        return;
-
-    // Set editor font boldness - must do this before
-    // calling UpdateControl().
-    if ( HasFlag(wxPG_BOLD_MODIFIED) )
-    {
-        if ( p->HasFlag(wxPG_PROP_MODIFIED) )
-            wnd->SetFont(GetCaptionFont());
-        else
-            wnd->SetFont(GetFont());
-    }
-
-    const wxPGEditor* editorClass = p->GetEditorClass();
-
-    editorClass->UpdateControl(p, wnd);
-
-    if ( p->IsValueUnspecified() )
-        editorClass ->SetValueToUnspecified(p, wnd);
-}
-
-// -----------------------------------------------------------------------
-
-// This method is not inline because it called dozens of times
-// (i.e. two-arg function calls create smaller code size).
-bool wxPropertyGrid::DoClearSelection()
-{
-    return DoSelectProperty(NULL);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid expand/collapse state
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::DoCollapse( wxPGProperty* p, bool sendEvents )
-{
-    wxPGProperty* pwc = wxStaticCast(p, wxPGProperty);
-
-    // If active editor was inside collapsed section, then disable it
-    if ( m_selected && m_selected->IsSomeParent(p) )
-    {
-        ClearSelection(false);
-    }
-
-    // Store dont-center-splitter flag 'cause we need to temporarily set it
-    wxUint32 old_flag = m_iFlags & wxPG_FL_DONT_CENTER_SPLITTER;
-    m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
-
-    bool res = m_pState->DoCollapse(pwc);
-
-    if ( res )
-    {
-        if ( sendEvents )
-            SendEvent( wxEVT_PG_ITEM_COLLAPSED, p );
-
-        RecalculateVirtualSize();
-
-        // Redraw etc. only if collapsed was visible.
-        if (pwc->IsVisible() &&
-            !m_frozen &&
-            ( !pwc->IsCategory() || !(m_windowStyle & wxPG_HIDE_CATEGORIES) ) )
-        {
-            // When item is collapsed so that scrollbar would move,
-            // graphics mess is about (unless we redraw everything).
-            Refresh();
-        }
-    }
-
-    // Clear dont-center-splitter flag if it wasn't set
-    m_iFlags = (m_iFlags & ~wxPG_FL_DONT_CENTER_SPLITTER) | old_flag;
-
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::DoExpand( wxPGProperty* p, bool sendEvents )
-{
-    wxCHECK_MSG( p, false, wxT("invalid property id") );
-
-    wxPGProperty* pwc = (wxPGProperty*)p;
-
-    // Store dont-center-splitter flag 'cause we need to temporarily set it
-    wxUint32 old_flag = m_iFlags & wxPG_FL_DONT_CENTER_SPLITTER;
-    m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
-
-    bool res = m_pState->DoExpand(pwc);
-
-    if ( res )
-    {
-        if ( sendEvents )
-            SendEvent( wxEVT_PG_ITEM_EXPANDED, p );
-
-        RecalculateVirtualSize();
-
-        // Redraw etc. only if expanded was visible.
-        if ( pwc->IsVisible() && !m_frozen &&
-             ( !pwc->IsCategory() || !(m_windowStyle & wxPG_HIDE_CATEGORIES) )
-           )
-        {
-            // Redraw
-        #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-            Refresh();
-        #else
-            DrawItems(pwc, NULL);
-        #endif
-        }
-    }
-
-    // Clear dont-center-splitter flag if it wasn't set
-    m_iFlags = (m_iFlags & ~wxPG_FL_DONT_CENTER_SPLITTER) | old_flag;
-
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::DoHideProperty( wxPGProperty* p, bool hide, int flags )
-{
-    if ( m_frozen )
-        return m_pState->DoHideProperty(p, hide, flags);
-
-    if ( m_selected &&
-         ( m_selected == p || m_selected->IsSomeParent(p) )
-       )
-        {
-            ClearSelection(false);
-        }
-
-    m_pState->DoHideProperty(p, hide, flags);
-
-    RecalculateVirtualSize();
-    Refresh();
-
-    return true;
-}
-
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid size related methods
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::RecalculateVirtualSize( int forceXPos )
-{
-    if ( (m_iFlags & wxPG_FL_RECALCULATING_VIRTUAL_SIZE) || m_frozen )
-        return;
-
-    //
-    // If virtual height was changed, then recalculate editor control position(s)
-    if ( m_pState->m_vhCalcPending )
-        CorrectEditorWidgetPosY();
-
-    m_pState->EnsureVirtualHeight();
-
-    wxASSERT_LEVEL_2_MSG(
-        m_pState->GetVirtualHeight() == m_pState->GetActualVirtualHeight(),
-        "VirtualHeight and ActualVirtualHeight should match"
-    );
-
-    m_iFlags |= wxPG_FL_RECALCULATING_VIRTUAL_SIZE;
-
-    int x = m_pState->m_width;
-    int y = m_pState->m_virtualHeight;
-
-    int width, height;
-    GetClientSize(&width,&height);
-
-    // Now adjust virtual size.
-    SetVirtualSize(x, y);
-
-    int xAmount = 0;
-    int xPos = 0;
-
-    //
-    // Adjust scrollbars
-    if ( HasVirtualWidth() )
-    {
-        xAmount = x/wxPG_PIXELS_PER_UNIT;
-        xPos = GetScrollPos( wxHORIZONTAL );
-    }
-
-    if ( forceXPos != -1 )
-        xPos = forceXPos;
-    // xPos too high?
-    else if ( xPos > (xAmount-(width/wxPG_PIXELS_PER_UNIT)) )
-        xPos = 0;
-
-    int yAmount = y / wxPG_PIXELS_PER_UNIT;
-    int yPos = GetScrollPos( wxVERTICAL );
-
-    SetScrollbars( wxPG_PIXELS_PER_UNIT, wxPG_PIXELS_PER_UNIT,
-                   xAmount, yAmount, xPos, yPos, true );
-
-    // Must re-get size now
-    GetClientSize(&width,&height);
-
-    if ( !HasVirtualWidth() )
-    {
-        m_pState->SetVirtualWidth(width);
-        x = width;
-    }
-
-    m_width = width;
-    m_height = height;
-
-    m_canvas->SetSize( x, y );
-
-    m_pState->CheckColumnWidths();
-
-    if ( m_selected )
-        CorrectEditorWidgetSizeX();
-
-    m_iFlags &= ~wxPG_FL_RECALCULATING_VIRTUAL_SIZE;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnResize( wxSizeEvent& event )
-{
-    if ( !(m_iFlags & wxPG_FL_INITIALIZED) )
-        return;
-
-    int width, height;
-    GetClientSize(&width,&height);
-
-    m_width = width;
-    m_height = height;
-
-#if wxPG_DOUBLE_BUFFER
-    if ( !(GetExtraStyle() & wxPG_EX_NATIVE_DOUBLE_BUFFERING) )
-    {
-        int dblh = (m_lineHeight*2);
-        if ( !m_doubleBuffer )
-        {
-            // Create double buffer bitmap to draw on, if none
-            int w = (width>250)?width:250;
-            int h = height + dblh;
-            h = (h>400)?h:400;
-            m_doubleBuffer = new wxBitmap( w, h );
-        }
-        else
-        {
-            int w = m_doubleBuffer->GetWidth();
-            int h = m_doubleBuffer->GetHeight();
-
-            // Double buffer must be large enough
-            if ( w < width || h < (height+dblh) )
-            {
-                if ( w < width ) w = width;
-                if ( h < (height+dblh) ) h = height + dblh;
-                delete m_doubleBuffer;
-                m_doubleBuffer = new wxBitmap( w, h );
-            }
-        }
-    }
-
-#endif
-
-    m_pState->OnClientWidthChange( width, event.GetSize().x - m_ncWidth, true );
-    m_ncWidth = event.GetSize().x;
-
-    if ( !m_frozen )
-    {
-        if ( m_pState->m_itemsAdded )
-            PrepareAfterItemsAdded();
-        else
-            // Without this, virtual size (atleast under wxGTK) will be skewed
-            RecalculateVirtualSize();
-
-        Refresh();
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::SetVirtualWidth( int width )
-{
-    if ( width == -1 )
-    {
-        // Disable virtual width
-        width = GetClientSize().x;
-        ClearInternalFlag(wxPG_FL_HAS_VIRTUAL_WIDTH);
-    }
-    else
-    {
-        // Enable virtual width
-        SetInternalFlag(wxPG_FL_HAS_VIRTUAL_WIDTH);
-    }
-    m_pState->SetVirtualWidth( width );
-}
-
-void wxPropertyGrid::SetFocusOnCanvas()
-{
-    m_canvas->SetFocusIgnoringChildren();
-    m_editorFocused = 0;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid mouse event handling
-// -----------------------------------------------------------------------
-
-// selFlags uses same values DoSelectProperty's flags
-// Returns true if event was vetoed.
-bool wxPropertyGrid::SendEvent( int eventType, wxPGProperty* p, wxVariant* pValue, unsigned int WXUNUSED(selFlags) )
-{
-    // Send property grid event of specific type and with specific property
-    wxPropertyGridEvent evt( eventType, m_eventObject->GetId() );
-    evt.SetPropertyGrid(this);
-    evt.SetEventObject(m_eventObject);
-    evt.SetProperty(p);
-    if ( pValue )
-    {
-        evt.SetCanVeto(true);
-        evt.SetupValidationInfo();
-        m_validationInfo.m_pValue = pValue;
-    }
-    wxEvtHandler* evtHandler = m_eventObject->GetEventHandler();
-
-    evtHandler->ProcessEvent(evt);
-
-    return evt.WasVetoed();
-}
-
-// -----------------------------------------------------------------------
-
-// Return false if should be skipped
-bool wxPropertyGrid::HandleMouseClick( int x, unsigned int y, wxMouseEvent &event )
-{
-    bool res = true;
-
-    // Need to set focus?
-    if ( !(m_iFlags & wxPG_FL_FOCUSED) )
-    {
-        SetFocusOnCanvas();
-    }
-
-    wxPropertyGridPageState* state = m_pState;
-    int splitterHit;
-    int splitterHitOffset;
-    int columnHit = state->HitTestH( x, &splitterHit, &splitterHitOffset );
-
-    wxPGProperty* p = DoGetItemAtY(y);
-
-    if ( p )
-    {
-        int depth = (int)p->GetDepth() - 1;
-
-        int marginEnds = m_marginWidth + ( depth * m_subgroup_extramargin );
-
-        if ( x >= marginEnds )
-        {
-            // Outside margin.
-
-            if ( p->IsCategory() )
-            {
-                // This is category.
-                wxPropertyCategory* pwc = (wxPropertyCategory*)p;
-
-                int textX = m_marginWidth + ((unsigned int)((pwc->m_depth-1)*m_subgroup_extramargin));
-
-                // Expand, collapse, activate etc. if click on text or left of splitter.
-                if ( x >= textX
-                     &&
-                     ( x < (textX+pwc->GetTextExtent(this, m_captionFont)+(wxPG_CAPRECTXMARGIN*2)) ||
-                       columnHit == 0
-                     )
-                    )
-                {
-                    if ( !DoSelectProperty( p ) )
-                        return res;
-
-                    // On double-click, expand/collapse.
-                    if ( event.ButtonDClick() && !(m_windowStyle & wxPG_HIDE_MARGIN) )
-                    {
-                        if ( pwc->IsExpanded() ) DoCollapse( p, true );
-                        else DoExpand( p, true );
-                    }
-                }
-            }
-            else if ( splitterHit == -1 )
-            {
-            // Click on value.
-                unsigned int selFlag = 0;
-                if ( columnHit == 1 )
-                {
-                    m_iFlags |= wxPG_FL_ACTIVATION_BY_CLICK;
-                    selFlag = wxPG_SEL_FOCUS;
-                }
-                if ( !DoSelectProperty( p, selFlag ) )
-                    return res;
-
-                m_iFlags &= ~(wxPG_FL_ACTIVATION_BY_CLICK);
-
-                if ( p->GetChildCount() && !p->IsCategory() )
-                    // On double-click, expand/collapse.
-                    if ( event.ButtonDClick() && !(m_windowStyle & wxPG_HIDE_MARGIN) )
-                    {
-                        wxPGProperty* pwc = (wxPGProperty*)p;
-                        if ( pwc->IsExpanded() ) DoCollapse( p, true );
-                        else DoExpand( p, true );
-                    }
-
-                res = false;
-            }
-            else
-            {
-            // click on splitter
-                if ( !(m_windowStyle & wxPG_STATIC_SPLITTER) )
-                {
-                    if ( event.GetEventType() == wxEVT_LEFT_DCLICK )
-                    {
-                        // Double-clicking the splitter causes auto-centering
-                        CenterSplitter( true );
-                    }
-                    else if ( m_dragStatus == 0 )
-                    {
-                    //
-                    // Begin draggin the splitter
-                    //
-                        if ( m_wndEditor )
-                        {
-                            // Changes must be committed here or the
-                            // value won't be drawn correctly
-                            if ( !CommitChangesFromEditor() )
-                                return res;
-
-                            m_wndEditor->Show ( false );
-                        }
-
-                        if ( !(m_iFlags & wxPG_FL_MOUSE_CAPTURED) )
-                        {
-                            m_canvas->CaptureMouse();
-                            m_iFlags |= wxPG_FL_MOUSE_CAPTURED;
-                        }
-
-                        m_dragStatus = 1;
-                        m_draggedSplitter = splitterHit;
-                        m_dragOffset = splitterHitOffset;
-
-                        wxClientDC dc(m_canvas);
-
-                    #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-                        // Fixes button disappearance bug
-                        if ( m_wndEditor2 )
-                            m_wndEditor2->Show ( false );
-                    #endif
-
-                        m_startingSplitterX = x - splitterHitOffset;
-                    }
-                }
-            }
-        }
-        else
-        {
-        // Click on margin.
-            if ( p->GetChildCount() )
-            {
-                int nx = x + m_marginWidth - marginEnds; // Normalize x.
-
-                if ( (nx >= m_gutterWidth && nx < (m_gutterWidth+m_iconWidth)) )
-                {
-                    int y2 = y % m_lineHeight;
-                    if ( (y2 >= m_buttonSpacingY && y2 < (m_buttonSpacingY+m_iconHeight)) )
-                    {
-                        // On click on expander button, expand/collapse
-                        if ( ((wxPGProperty*)p)->IsExpanded() )
-                            DoCollapse( p, true );
-                        else
-                            DoExpand( p, true );
-                    }
-                }
-            }
-        }
-    }
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::HandleMouseRightClick( int WXUNUSED(x), unsigned int WXUNUSED(y),
-                                            wxMouseEvent& WXUNUSED(event) )
-{
-    if ( m_propHover )
-    {
-        // Select property here as well
-        wxPGProperty* p = m_propHover;
-        if ( p != m_selected )
-            DoSelectProperty( p );
-
-        // Send right click event.
-        SendEvent( wxEVT_PG_RIGHT_CLICK, p );
-
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::HandleMouseDoubleClick( int WXUNUSED(x), unsigned int WXUNUSED(y),
-                                             wxMouseEvent& WXUNUSED(event) )
-{
-    if ( m_propHover )
-    {
-        // Select property here as well
-        wxPGProperty* p = m_propHover;
-
-        if ( p != m_selected )
-            DoSelectProperty( p );
-
-        // Send double-click event.
-        SendEvent( wxEVT_PG_DOUBLE_CLICK, m_propHover );
-
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-#if wxPG_SUPPORT_TOOLTIPS
-
-void wxPropertyGrid::SetToolTip( const wxString& tipString )
-{
-    if ( tipString.length() )
-    {
-        m_canvas->SetToolTip(tipString);
-    }
-    else
-    {
-    #if wxPG_ALLOW_EMPTY_TOOLTIPS
-        m_canvas->SetToolTip( m_emptyString );
-    #else
-        m_canvas->SetToolTip( NULL );
-    #endif
-    }
-}
-
-#endif // #if wxPG_SUPPORT_TOOLTIPS
-
-// -----------------------------------------------------------------------
-
-// Return false if should be skipped
-bool wxPropertyGrid::HandleMouseMove( int x, unsigned int y, wxMouseEvent &event )
-{
-    // Safety check (needed because mouse capturing may
-    // otherwise freeze the control)
-    if ( m_dragStatus > 0 && !event.Dragging() )
-    {
-        HandleMouseUp(x,y,event);
-    }
-
-    wxPropertyGridPageState* state = m_pState;
-    int splitterHit;
-    int splitterHitOffset;
-    int columnHit = state->HitTestH( x, &splitterHit, &splitterHitOffset );
-    int splitterX = x - splitterHitOffset;
-
-    if ( m_dragStatus > 0 )
-    {
-        if ( x > (m_marginWidth + wxPG_DRAG_MARGIN) &&
-             x < (m_pState->m_width - wxPG_DRAG_MARGIN) )
-        {
-
-            int newSplitterX = x - m_dragOffset;
-            int splitterX = x - splitterHitOffset;
-
-            // Splitter redraw required?
-            if ( newSplitterX != splitterX )
-            {
-                // Move everything
-                SetInternalFlag(wxPG_FL_DONT_CENTER_SPLITTER);
-                state->DoSetSplitterPosition( newSplitterX, m_draggedSplitter, false );
-                state->m_fSplitterX = (float) newSplitterX;
-
-                if ( m_selected )
-                    CorrectEditorWidgetSizeX();
-
-                Update();
-                Refresh();
-            }
-
-            m_dragStatus = 2;
-        }
-
-        return false;
-    }
-    else
-    {
-
-        int ih = m_lineHeight;
-        int sy = y;
-
-    #if wxPG_SUPPORT_TOOLTIPS
-        wxPGProperty* prevHover = m_propHover;
-        unsigned char prevSide = m_mouseSide;
-    #endif
-        int curPropHoverY = y - (y % ih);
-
-        // On which item it hovers
-        if ( !m_propHover
-             ||
-             ( sy < m_propHoverY || sy >= (m_propHoverY+ih) )
-           )
-        {
-            // Mouse moves on another property
-
-            m_propHover = DoGetItemAtY(y);
-            m_propHoverY = curPropHoverY;
-
-            // Send hover event
-            SendEvent( wxEVT_PG_HIGHLIGHTED, m_propHover );
-        }
-
-    #if wxPG_SUPPORT_TOOLTIPS
-        // Store which side we are on
-        m_mouseSide = 0;
-        if ( columnHit == 1 )
-            m_mouseSide = 2;
-        else if ( columnHit == 0 )
-            m_mouseSide = 1;
-
-        //
-        // If tooltips are enabled, show label or value as a tip
-        // in case it doesn't otherwise show in full length.
-        //
-        if ( m_windowStyle & wxPG_TOOLTIPS )
-        {
-            wxToolTip* tooltip = m_canvas->GetToolTip();
-
-            if ( m_propHover != prevHover || prevSide != m_mouseSide )
-            {
-                if ( m_propHover && !m_propHover->IsCategory() )
-                {
-
-                    if ( GetExtraStyle() & wxPG_EX_HELP_AS_TOOLTIPS )
-                    {
-                        // Show help string as a tooltip
-                        wxString tipString = m_propHover->GetHelpString();
-
-                        SetToolTip(tipString);
-                    }
-                    else
-                    {
-                        // Show cropped value string as a tooltip
-                        wxString tipString;
-                        int space = 0;
-
-                        if ( m_mouseSide == 1 )
-                        {
-                            tipString = m_propHover->m_label;
-                            space = splitterX-m_marginWidth-3;
-                        }
-                        else if ( m_mouseSide == 2 )
-                        {
-                            tipString = m_propHover->GetDisplayedString();
-
-                            space = m_width - splitterX;
-                            if ( m_propHover->m_flags & wxPG_PROP_CUSTOMIMAGE )
-                                space -= wxPG_CUSTOM_IMAGE_WIDTH + wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2;
-                        }
-
-                        if ( space )
-                        {
-                            int tw, th;
-                            GetTextExtent( tipString, &tw, &th, 0, 0 );
-                            if ( tw > space )
-                            {
-                                SetToolTip( tipString );
-                            }
-                        }
-                        else
-                        {
-                            if ( tooltip )
-                            {
-                            #if wxPG_ALLOW_EMPTY_TOOLTIPS
-                                m_canvas->SetToolTip( m_emptyString );
-                            #else
-                                m_canvas->SetToolTip( NULL );
-                            #endif
-                            }
-                        }
-
-                    }
-                }
-                else
-                {
-                    if ( tooltip )
-                    {
-                    #if wxPG_ALLOW_EMPTY_TOOLTIPS
-                        m_canvas->SetToolTip( m_emptyString );
-                    #else
-                        m_canvas->SetToolTip( NULL );
-                    #endif
-                    }
-                }
-            }
-        }
-    #endif
-
-        if ( splitterHit == -1 ||
-             !m_propHover ||
-             HasFlag(wxPG_STATIC_SPLITTER) )
-        {
-            // hovering on something else
-            if ( m_curcursor != wxCURSOR_ARROW )
-                CustomSetCursor( wxCURSOR_ARROW );
-        }
-        else
-        {
-            // Do not allow splitter cursor on caption items.
-            // (also not if we were dragging and its started
-            // outside the splitter region)
-
-            if ( !m_propHover->IsCategory() &&
-                 !event.Dragging() )
-            {
-
-                // hovering on splitter
-
-                // NB: Condition disabled since MouseLeave event (from the editor control) cannot be
-                //     reliably detected.
-                //if ( m_curcursor != wxCURSOR_SIZEWE )
-                CustomSetCursor( wxCURSOR_SIZEWE, true );
-
-                return false;
-            }
-            else
-            {
-                // hovering on something else
-                if ( m_curcursor != wxCURSOR_ARROW )
-                    CustomSetCursor( wxCURSOR_ARROW );
-            }
-        }
-    }
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-// Also handles Leaving event
-bool wxPropertyGrid::HandleMouseUp( int x, unsigned int WXUNUSED(y),
-                                    wxMouseEvent &WXUNUSED(event) )
-{
-    wxPropertyGridPageState* state = m_pState;
-    bool res = false;
-
-    int splitterHit;
-    int splitterHitOffset;
-    state->HitTestH( x, &splitterHit, &splitterHitOffset );
-
-    // No event type check - basicly calling this method should
-    // just stop dragging.
-    // Left up after dragged?
-    if ( m_dragStatus >= 1 )
-    {
-    //
-    // End Splitter Dragging
-    //
-        // DO NOT ENABLE FOLLOWING LINE!
-        // (it is only here as a reminder to not to do it)
-        //splitterX = x;
-
-        // Disable splitter auto-centering
-        m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
-
-        // This is necessary to return cursor
-        if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
-        {
-            m_canvas->ReleaseMouse();
-            m_iFlags &= ~(wxPG_FL_MOUSE_CAPTURED);
-        }
-
-        // Set back the default cursor, if necessary
-        if ( splitterHit == -1 ||
-             !m_propHover )
-        {
-            CustomSetCursor( wxCURSOR_ARROW );
-        }
-
-        m_dragStatus = 0;
-
-        // Control background needs to be cleared
-        if ( !(m_iFlags & wxPG_FL_PRIMARY_FILLS_ENTIRE) && m_selected )
-            DrawItem( m_selected );
-
-        if ( m_wndEditor )
-        {
-            m_wndEditor->Show ( true );
-        }
-
-    #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
-        // Fixes button disappearance bug
-        if ( m_wndEditor2 )
-            m_wndEditor2->Show ( true );
-    #endif
-
-        // This clears the focus.
-        m_editorFocused = 0;
-
-    }
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::OnMouseCommon( wxMouseEvent& event, int* px, int* py )
-{
-    int splitterX = GetSplitterPosition();
-
-    //int ux, uy;
-    //CalcUnscrolledPosition( event.m_x, event.m_y, &ux, &uy );
-    int ux = event.m_x;
-    int uy = event.m_y;
-
-    wxWindow* wnd = GetEditorControl();
-
-    // Hide popup on clicks
-    if ( event.GetEventType() != wxEVT_MOTION )
-        if ( wnd && wnd->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)) )
-        {
-            ((wxOwnerDrawnComboBox*)wnd)->HidePopup();
-        }
-
-    wxRect r;
-    if ( wnd )
-        r = wnd->GetRect();
-    if ( wnd == NULL || m_dragStatus ||
-         (
-           ux <= (splitterX + wxPG_SPLITTERX_DETECTMARGIN2) ||
-           ux >= (r.x+r.width) ||
-           event.m_y < r.y ||
-           event.m_y >= (r.y+r.height)
-         )
-       )
-    {
-        *px = ux;
-        *py = uy;
-        return true;
-    }
-    else
-    {
-        if ( m_curcursor != wxCURSOR_ARROW ) CustomSetCursor ( wxCURSOR_ARROW );
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseClick( wxMouseEvent &event )
-{
-    int x, y;
-    if ( OnMouseCommon( event, &x, &y ) )
-    {
-        HandleMouseClick(x,y,event);
-    }
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseRightClick( wxMouseEvent &event )
-{
-    int x, y;
-    CalcUnscrolledPosition( event.m_x, event.m_y, &x, &y );
-    HandleMouseRightClick(x,y,event);
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseDoubleClick( wxMouseEvent &event )
-{
-    // Always run standard mouse-down handler as well
-    OnMouseClick(event);
-
-    int x, y;
-    CalcUnscrolledPosition( event.m_x, event.m_y, &x, &y );
-    HandleMouseDoubleClick(x,y,event);
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseMove( wxMouseEvent &event )
-{
-    int x, y;
-    if ( OnMouseCommon( event, &x, &y ) )
-    {
-        HandleMouseMove(x,y,event);
-    }
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseMoveBottom( wxMouseEvent& WXUNUSED(event) )
-{
-    // Called when mouse moves in the empty space below the properties.
-    CustomSetCursor( wxCURSOR_ARROW );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseUp( wxMouseEvent &event )
-{
-    int x, y;
-    if ( OnMouseCommon( event, &x, &y ) )
-    {
-        HandleMouseUp(x,y,event);
-    }
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnMouseEntry( wxMouseEvent &event )
-{
-    // This may get called from child control as well, so event's
-    // mouse position cannot be relied on.
-
-    if ( event.Entering() )
-    {
-        if ( !(m_iFlags & wxPG_FL_MOUSE_INSIDE) )
-        {
-            // TODO: Fix this (detect parent and only do
-            //   cursor trick if it is a manager).
-            wxASSERT( GetParent() );
-            GetParent()->SetCursor(wxNullCursor);
-
-            m_iFlags |= wxPG_FL_MOUSE_INSIDE;
-        }
-        else
-            GetParent()->SetCursor(wxNullCursor);
-    }
-    else if ( event.Leaving() )
-    {
-        // Without this, wxSpinCtrl editor will sometimes have wrong cursor
-        m_canvas->SetCursor( wxNullCursor );
-
-        // Get real cursor position
-        wxPoint pt = ScreenToClient(::wxGetMousePosition());
-
-        if ( ( pt.x <= 0 || pt.y <= 0 || pt.x >= m_width || pt.y >= m_height ) )
-        {
-            {
-                if ( (m_iFlags & wxPG_FL_MOUSE_INSIDE) )
-                {
-                    m_iFlags &= ~(wxPG_FL_MOUSE_INSIDE);
-                }
-
-                if ( m_dragStatus )
-                    wxPropertyGrid::HandleMouseUp ( -1, 10000, event );
-            }
-        }
-    }
-
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-// Common code used by various OnMouseXXXChild methods.
-bool wxPropertyGrid::OnMouseChildCommon( wxMouseEvent &event, int* px, int *py )
-{
-    wxWindow* topCtrlWnd = (wxWindow*)event.GetEventObject();
-    wxASSERT( topCtrlWnd );
-    int x, y;
-    event.GetPosition(&x,&y);
-
-    int splitterX = GetSplitterPosition();
-
-    wxRect r = topCtrlWnd->GetRect();
-    if ( !m_dragStatus &&
-         x > (splitterX-r.x+wxPG_SPLITTERX_DETECTMARGIN2) &&
-         y >= 0 && y < r.height \
-       )
-    {
-        if ( m_curcursor != wxCURSOR_ARROW ) CustomSetCursor ( wxCURSOR_ARROW );
-        event.Skip();
-    }
-    else
-    {
-        CalcUnscrolledPosition( event.m_x + r.x, event.m_y + r.y, \
-            px, py );
-        return true;
-    }
-    return false;
-}
-
-void wxPropertyGrid::OnMouseClickChild( wxMouseEvent &event )
-{
-    int x,y;
-    if ( OnMouseChildCommon(event,&x,&y) )
-    {
-        bool res = HandleMouseClick(x,y,event);
-        if ( !res ) event.Skip();
-    }
-}
-
-void wxPropertyGrid::OnMouseRightClickChild( wxMouseEvent &event )
-{
-    int x,y;
-    wxASSERT( m_wndEditor );
-    // These coords may not be exact (about +-2),
-    // but that should not matter (right click is about item, not position).
-    wxPoint pt = m_wndEditor->GetPosition();
-    CalcUnscrolledPosition( event.m_x + pt.x, event.m_y + pt.y, &x, &y );
-    wxASSERT( m_selected );
-    m_propHover = m_selected;
-    bool res = HandleMouseRightClick(x,y,event);
-    if ( !res ) event.Skip();
-}
-
-void wxPropertyGrid::OnMouseMoveChild( wxMouseEvent &event )
-{
-    int x,y;
-    if ( OnMouseChildCommon(event,&x,&y) )
-    {
-        bool res = HandleMouseMove(x,y,event);
-        if ( !res ) event.Skip();
-    }
-}
-
-void wxPropertyGrid::OnMouseUpChild( wxMouseEvent &event )
-{
-    int x,y;
-    if ( OnMouseChildCommon(event,&x,&y) )
-    {
-        bool res = HandleMouseUp(x,y,event);
-        if ( !res ) event.Skip();
-    }
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid keyboard event handling
-// -----------------------------------------------------------------------
-
-int wxPropertyGrid::KeyEventToActions(wxKeyEvent &event, int* pSecond) const
-{
-    // Translates wxKeyEvent to wxPG_ACTION_XXX
-
-    int keycode = event.GetKeyCode();
-    int modifiers = event.GetModifiers();
-
-    wxASSERT( !(modifiers&~(0xFFFF)) );
-
-    int hashMapKey = (keycode & 0xFFFF) | ((modifiers & 0xFFFF) << 16);
-
-    wxPGHashMapI2I::const_iterator it = m_actionTriggers.find(hashMapKey);
-
-    if ( it == m_actionTriggers.end() )
-        return 0;
-
-    if ( pSecond )
-    {
-        int second = (it->second>>16) & 0xFFFF;
-        *pSecond = second;
-    }
-
-    return (it->second & 0xFFFF);
-}
-
-void wxPropertyGrid::AddActionTrigger( int action, int keycode, int modifiers )
-{
-    wxASSERT( !(modifiers&~(0xFFFF)) );
-
-    int hashMapKey = (keycode & 0xFFFF) | ((modifiers & 0xFFFF) << 16);
-
-    wxPGHashMapI2I::iterator it = m_actionTriggers.find(hashMapKey);
-
-    if ( it != m_actionTriggers.end() )
-    {
-        // This key combination is already used
-
-        // Can add secondary?
-        wxASSERT_MSG( !(it->second&~(0xFFFF)),
-                      wxT("You can only add up to two separate actions per key combination.") );
-
-        action = it->second | (action<<16);
-    }
-
-    m_actionTriggers[hashMapKey] = action;
-}
-
-void wxPropertyGrid::ClearActionTriggers( int action )
-{
-    wxPGHashMapI2I::iterator it;
-
-    for ( it = m_actionTriggers.begin(); it != m_actionTriggers.end(); ++it )
-    {
-        if ( it->second == action )
-        {
-            m_actionTriggers.erase(it);
-        }
-    }
-}
-
-void wxPropertyGrid::HandleKeyEvent( wxKeyEvent &event, bool fromChild )
-{
-    //
-    // Handles key event when editor control is not focused.
-    //
-
-    wxCHECK2(!m_frozen, return);
-
-    // Travelsal between items, collapsing/expanding, etc.
-    int keycode = event.GetKeyCode();
-    bool editorFocused = IsEditorFocused();
-
-    if ( keycode == WXK_TAB )
-    {
-        wxWindow* mainControl;
-
-        if ( HasInternalFlag(wxPG_FL_IN_MANAGER) )
-            mainControl = GetParent();
-        else
-            mainControl = this;
-
-        if ( !event.ShiftDown() )
-        {
-            if ( !editorFocused && m_wndEditor )
-            {
-                DoSelectProperty( m_selected, wxPG_SEL_FOCUS );
-            }
-            else
-            {
-                // Tab traversal workaround for platforms on which
-                // wxWindow::Navigate() may navigate into first child
-                // instead of next sibling. Does not work perfectly
-                // in every scenario (for instance, when property grid
-                // is either first or last control).
-            #if defined(__WXGTK__)
-                wxWindow* sibling = mainControl->GetNextSibling();
-                if ( sibling )
-                    sibling->SetFocusFromKbd();
-            #else
-                Navigate(wxNavigationKeyEvent::IsForward);
-            #endif
-            }
-        }
-        else
-        {
-            if ( editorFocused )
-            {
-                UnfocusEditor();
-            }
-            else
-            {
-            #if defined(__WXGTK__)
-                wxWindow* sibling = mainControl->GetPrevSibling();
-                if ( sibling )
-                    sibling->SetFocusFromKbd();
-            #else
-                Navigate(wxNavigationKeyEvent::IsBackward);
-            #endif
-            }
-        }
-
-        return;
-    }
-
-    // Ignore Alt and Control when they are down alone
-    if ( keycode == WXK_ALT ||
-         keycode == WXK_CONTROL )
-    {
-        event.Skip();
-        return;
-    }
-
-    int secondAction;
-    int action = KeyEventToActions(event, &secondAction);
-
-    if ( editorFocused && action == wxPG_ACTION_CANCEL_EDIT )
-    {
-        //
-        // Esc cancels any changes
-        if ( IsEditorsValueModified() )
-        {
-            EditorsValueWasNotModified();
-
-            // Update the control as well
-            m_selected->GetEditorClass()->SetControlStringValue( m_selected,
-                                                                 GetEditorControl(),
-                                                                 m_selected->GetDisplayedString() );
-        }
-
-        OnValidationFailureReset(m_selected);
-
-        UnfocusEditor();
-        return;
-    }
-
-    // Except for TAB and ESC, handle child control events in child control
-    if ( fromChild )
-    {
-        // Only propagate event if it had modifiers
-        if ( !event.HasModifiers() )
-        {
-            event.StopPropagation();
-        }
-        event.Skip();
-        return;
-    }
-
-    bool wasHandled = false;
-
-    if ( m_selected )
-    {
-        // Show dialog?
-        if ( ButtonTriggerKeyTest(action, event) )
-            return;
-
-        wxPGProperty* p = m_selected;
-
-        // Travel and expand/collapse
-        int selectDir = -2;
-
-        if ( p->GetChildCount() )
-        {
-            if ( action == wxPG_ACTION_COLLAPSE_PROPERTY || secondAction == wxPG_ACTION_COLLAPSE_PROPERTY )
-            {
-                if ( (m_windowStyle & wxPG_HIDE_MARGIN) || Collapse(p) )
-                    wasHandled = true;
-            }
-            else if ( action == wxPG_ACTION_EXPAND_PROPERTY || secondAction == wxPG_ACTION_EXPAND_PROPERTY )
-            {
-                if ( (m_windowStyle & wxPG_HIDE_MARGIN) || Expand(p) )
-                    wasHandled = true;
-            }
-        }
-
-        if ( !wasHandled )
-        {
-            if ( action == wxPG_ACTION_PREV_PROPERTY || secondAction == wxPG_ACTION_PREV_PROPERTY )
-            {
-                selectDir = -1;
-            }
-            else if ( action == wxPG_ACTION_NEXT_PROPERTY || secondAction == wxPG_ACTION_NEXT_PROPERTY )
-            {
-                selectDir = 1;
-            }
-        }
-
-        if ( selectDir >= -1 )
-        {
-            p = wxPropertyGridIterator::OneStep( m_pState, wxPG_ITERATE_VISIBLE, p, selectDir );
-            if ( p )
-                DoSelectProperty(p);
-            wasHandled = true;
-        }
-    }
-    else
-    {
-        // If nothing was selected, select the first item now
-        // (or navigate out of tab).
-        if ( action != wxPG_ACTION_CANCEL_EDIT && secondAction != wxPG_ACTION_CANCEL_EDIT )
-        {
-            wxPGProperty* p = wxPropertyGridInterface::GetFirst();
-            if ( p ) DoSelectProperty(p);
-            wasHandled = true;
-        }
-    }
-
-    if ( !wasHandled )
-        event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnKey( wxKeyEvent &event )
-{
-    // If there was editor open and focused, then this event should not
-    // really be processed here.
-    if ( IsEditorFocused() )
-    {
-        // However, if event had modifiers, it is probably still best
-        // to skip it.
-        if ( event.HasModifiers() )
-            event.Skip();
-        else
-            event.StopPropagation();
-        return;
-    }
-
-    HandleKeyEvent(event, false);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGrid::ButtonTriggerKeyTest( int action, wxKeyEvent& event )
-{
-    if ( action == -1 )
-    {
-        int secondAction;
-        action = KeyEventToActions(event, &secondAction);
-    }
-
-    // Does the keycode trigger button?
-    if ( action == wxPG_ACTION_PRESS_BUTTON &&
-         m_wndEditor2 )
-    {
-        wxCommandEvent evt(wxEVT_COMMAND_BUTTON_CLICKED, m_wndEditor2->GetId());
-        GetEventHandler()->AddPendingEvent(evt);
-        return true;
-    }
-
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnChildKeyDown( wxKeyEvent &event )
-{
-    HandleKeyEvent(event, true);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGrid miscellaneous event handling
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnIdle( wxIdleEvent& WXUNUSED(event) )
-{
-    //
-    // Check if the focus is in this control or one of its children
-    wxWindow* newFocused = wxWindow::FindFocus();
-
-    if ( newFocused != m_curFocused )
-        HandleFocusChange( newFocused );
-}
-
-bool wxPropertyGrid::IsEditorFocused() const
-{
-    wxWindow* focus = wxWindow::FindFocus();
-
-    if ( focus == m_wndEditor || focus == m_wndEditor2 ||
-         focus == GetEditorControl() )
-         return true;
-
-    return false;
-}
-
-// Called by focus event handlers. newFocused is the window that becomes focused.
-void wxPropertyGrid::HandleFocusChange( wxWindow* newFocused )
-{
-    unsigned int oldFlags = m_iFlags;
-
-    m_iFlags &= ~(wxPG_FL_FOCUSED);
-
-    wxWindow* parent = newFocused;
-
-    // This must be one of nextFocus' parents.
-    while ( parent )
-    {
-        // Use m_eventObject, which is either wxPropertyGrid or
-        // wxPropertyGridManager, as appropriate.
-        if ( parent == m_eventObject )
-        {
-            m_iFlags |= wxPG_FL_FOCUSED;
-            break;
-        }
-        parent = parent->GetParent();
-    }
-
-    m_curFocused = newFocused;
-
-    if ( (m_iFlags & wxPG_FL_FOCUSED) !=
-         (oldFlags & wxPG_FL_FOCUSED) )
-    {
-        if ( !(m_iFlags & wxPG_FL_FOCUSED) )
-        {
-            // Need to store changed value
-            CommitChangesFromEditor();
-        }
-        else
-        {
-            /*
-            //
-            // Preliminary code for tab-order respecting
-            // tab-traversal (but should be moved to
-            // OnNav handler)
-            //
-            wxWindow* prevFocus = event.GetWindow();
-            wxWindow* useThis = this;
-            if ( m_iFlags & wxPG_FL_IN_MANAGER )
-                useThis = GetParent();
-
-            if ( prevFocus &&
-                 prevFocus->GetParent() == useThis->GetParent() )
-            {
-                wxList& children = useThis->GetParent()->GetChildren();
-
-                wxNode* node = children.Find(prevFocus);
-
-                if ( node->GetNext() &&
-                     useThis == node->GetNext()->GetData() )
-                    DoSelectProperty(GetFirst());
-                else if ( node->GetPrevious () &&
-                          useThis == node->GetPrevious()->GetData() )
-                    DoSelectProperty(GetLastProperty());
-
-            }
-            */
-        }
-
-        // Redraw selected
-        if ( m_selected && (m_iFlags & wxPG_FL_INITIALIZED) )
-            DrawItem( m_selected );
-    }
-}
-
-void wxPropertyGrid::OnFocusEvent( wxFocusEvent& event )
-{
-    if ( event.GetEventType() == wxEVT_SET_FOCUS )
-        HandleFocusChange((wxWindow*)event.GetEventObject());
-    // Line changed to "else" when applying wxPropertyGrid patch #1675902
-    //else if ( event.GetWindow() )
-    else
-        HandleFocusChange(event.GetWindow());
-
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnChildFocusEvent( wxChildFocusEvent& event )
-{
-    HandleFocusChange((wxWindow*)event.GetEventObject());
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnScrollEvent( wxScrollWinEvent &event )
-{
-    m_iFlags |= wxPG_FL_SCROLLED;
-
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGrid::OnCaptureChange( wxMouseCaptureChangedEvent& WXUNUSED(event) )
-{
-    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
-    {
-        m_iFlags &= ~(wxPG_FL_MOUSE_CAPTURED);
-    }
-}
-
-// -----------------------------------------------------------------------
-// Property editor related functions
-// -----------------------------------------------------------------------
-
-// noDefCheck = true prevents infinite recursion.
-wxPGEditor* wxPropertyGrid::DoRegisterEditorClass( wxPGEditor* editorClass,
-                                                   const wxString& editorName,
-                                                   bool noDefCheck )
-{
-    wxASSERT( editorClass );
-
-    if ( !noDefCheck && wxPGGlobalVars->m_mapEditorClasses.empty() )
-        RegisterDefaultEditors();
-
-    wxString name = editorName;
-    if ( name.length() == 0 )
-        name = editorClass->GetName();
-
-    // Existing editor under this name?
-    wxPGHashMapS2P::iterator vt_it = wxPGGlobalVars->m_mapEditorClasses.find(name);
-
-    if ( vt_it != wxPGGlobalVars->m_mapEditorClasses.end() )
-    {
-        // If this name was already used, try class name.
-        name = editorClass->GetClassInfo()->GetClassName();
-        vt_it = wxPGGlobalVars->m_mapEditorClasses.find(name);
-    }
-
-    wxCHECK_MSG( vt_it == wxPGGlobalVars->m_mapEditorClasses.end(),
-                 (wxPGEditor*) vt_it->second,
-                 "Editor with given name was already registered" );
-
-    wxPGGlobalVars->m_mapEditorClasses[name] = (void*)editorClass;
-
-    return editorClass;
-}
-
-// Use this in RegisterDefaultEditors.
-#define wxPGRegisterDefaultEditorClass(EDITOR) \
-    if ( wxPGEditor_##EDITOR == NULL ) \
-    { \
-        wxPGEditor_##EDITOR = wxPropertyGrid::RegisterEditorClass( \
-            new wxPG##EDITOR##Editor, true ); \
-    }
-
-// Registers all default editor classes
-void wxPropertyGrid::RegisterDefaultEditors()
-{
-    wxPGRegisterDefaultEditorClass( TextCtrl );
-    wxPGRegisterDefaultEditorClass( Choice );
-    wxPGRegisterDefaultEditorClass( ComboBox );
-    wxPGRegisterDefaultEditorClass( TextCtrlAndButton );
-#if wxPG_INCLUDE_CHECKBOX
-    wxPGRegisterDefaultEditorClass( CheckBox );
-#endif
-    wxPGRegisterDefaultEditorClass( ChoiceAndButton );
-
-    // Register SpinCtrl etc. editors before use
-    RegisterAdditionalEditors();
-}
-
-// -----------------------------------------------------------------------
-// wxPGStringTokenizer
-//   Needed to handle C-style string lists (e.g. "str1" "str2")
-// -----------------------------------------------------------------------
-
-wxPGStringTokenizer::wxPGStringTokenizer( const wxString& str, wxChar delimeter )
-    : m_str(&str), m_curPos(str.begin()), m_delimeter(delimeter)
-{
-}
-
-wxPGStringTokenizer::~wxPGStringTokenizer()
-{
-}
-
-bool wxPGStringTokenizer::HasMoreTokens()
-{
-    const wxString& str = *m_str;
-
-    wxString::const_iterator i = m_curPos;
-
-    wxUniChar delim = m_delimeter;
-    wxUniChar a;
-    wxUniChar prev_a = wxT('\0');
-
-    bool inToken = false;
-
-    while ( i != str.end() )
-    {
-        a = *i;
-
-        if ( !inToken )
-        {
-            if ( a == delim )
-            {
-                inToken = true;
-                m_readyToken.clear();
-            }
-        }
-        else
-        {
-            if ( prev_a != wxT('\\') )
-            {
-                if ( a != delim )
-                {
-                    if ( a != wxT('\\') )
-                        m_readyToken << a;
-                }
-                else
-                {
-                    ++i;
-                    m_curPos = i;
-                    return true;
-                }
-                prev_a = a;
-            }
-            else
-            {
-                m_readyToken << a;
-                prev_a = wxT('\0');
-            }
-        }
-        ++i;
-    }
-
-    m_curPos = str.end();
-
-    if ( inToken )
-        return true;
-
-    return false;
-}
-
-wxString wxPGStringTokenizer::GetNextToken()
-{
-    return m_readyToken;
-}
-
-// -----------------------------------------------------------------------
-// wxPGChoiceEntry
-// -----------------------------------------------------------------------
-
-wxPGChoiceEntry::wxPGChoiceEntry()
-    : wxPGCell(), m_value(wxPG_INVALID_VALUE)
-{
-}
-
-// -----------------------------------------------------------------------
-// wxPGChoicesData
-// -----------------------------------------------------------------------
-
-wxPGChoicesData::wxPGChoicesData()
-{
-    m_refCount = 1;
-}
-
-wxPGChoicesData::~wxPGChoicesData()
-{
-    Clear();
-}
-
-void wxPGChoicesData::Clear()
-{
-    m_items.clear();
-}
-
-void wxPGChoicesData::CopyDataFrom( wxPGChoicesData* data )
-{
-    wxASSERT( m_items.size() == 0 );
-
-    m_items = data->m_items;
-}
-
-wxPGChoiceEntry& wxPGChoicesData::Insert( int index,
-                                          const wxPGChoiceEntry& item )
-{
-    wxVector<wxPGChoiceEntry>::iterator it;
-    if ( index == -1 )
-    {
-        it = m_items.end();
-        index = (int) m_items.size();
-    }
-    else
-    {
-        it = m_items.begin() + index;
-    }
-
-    m_items.insert(it, item);
-
-    wxPGChoiceEntry& ownEntry = m_items[index];
-
-    // Need to fix value?
-    if ( ownEntry.GetValue() == wxPG_INVALID_VALUE )
-        ownEntry.SetValue(index);
-
-    return ownEntry;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridEvent
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxPropertyGridEvent, wxCommandEvent)
-
-
-wxDEFINE_EVENT( wxEVT_PG_SELECTED, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_CHANGING, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_CHANGED, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_HIGHLIGHTED, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_RIGHT_CLICK, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_PAGE_CHANGED, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_ITEM_EXPANDED, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_ITEM_COLLAPSED, wxPropertyGridEvent );
-wxDEFINE_EVENT( wxEVT_PG_DOUBLE_CLICK, wxPropertyGridEvent );
-
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridEvent::Init()
-{
-    m_validationInfo = NULL;
-    m_canVeto = false;
-    m_wasVetoed = false;
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridEvent::wxPropertyGridEvent(wxEventType commandType, int id)
-    : wxCommandEvent(commandType,id)
-{
-    m_property = NULL;
-    Init();
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridEvent::wxPropertyGridEvent(const wxPropertyGridEvent& event)
-    : wxCommandEvent(event)
-{
-    m_eventType = event.GetEventType();
-    m_eventObject = event.m_eventObject;
-    m_pg = event.m_pg;
-    m_property = event.m_property;
-    m_validationInfo = event.m_validationInfo;
-    m_canVeto = event.m_canVeto;
-    m_wasVetoed = event.m_wasVetoed;
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridEvent::~wxPropertyGridEvent()
-{
-}
-
-// -----------------------------------------------------------------------
-
-wxEvent* wxPropertyGridEvent::Clone() const
-{
-    return new wxPropertyGridEvent( *this );
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPopulator
-// -----------------------------------------------------------------------
-
-wxPropertyGridPopulator::wxPropertyGridPopulator()
-{
-    m_state = NULL;
-    m_pg = NULL;
-    wxPGGlobalVars->m_offline++;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPopulator::SetState( wxPropertyGridPageState* state )
-{
-    m_state = state;
-    m_propHierarchy.clear();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPopulator::SetGrid( wxPropertyGrid* pg )
-{
-    m_pg = pg;
-    pg->Freeze();
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridPopulator::~wxPropertyGridPopulator()
-{
-    //
-    // Free unused sets of choices
-    wxPGHashMapS2P::iterator it;
-
-    for( it = m_dictIdChoices.begin(); it != m_dictIdChoices.end(); ++it )
-    {
-        wxPGChoicesData* data = (wxPGChoicesData*) it->second;
-        data->DecRef();
-    }
-
-    if ( m_pg )
-    {
-        m_pg->Thaw();
-        m_pg->GetPanel()->Refresh();
-    }
-    wxPGGlobalVars->m_offline--;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPopulator::Add( const wxString& propClass,
-                                            const wxString& propLabel,
-                                            const wxString& propName,
-                                            const wxString* propValue,
-                                            wxPGChoices* pChoices )
-{
-    wxClassInfo* classInfo = wxClassInfo::FindClass(propClass);
-    wxPGProperty* parent = GetCurParent();
-
-    if ( parent->HasFlag(wxPG_PROP_AGGREGATE) )
-    {
-        ProcessError(wxString::Format(wxT("new children cannot be added to '%s'"),parent->GetName().c_str()));
-        return NULL;
-    }
-
-    if ( !classInfo || !classInfo->IsKindOf(CLASSINFO(wxPGProperty)) )
-    {
-        ProcessError(wxString::Format(wxT("'%s' is not valid property class"),propClass.c_str()));
-        return NULL;
-    }
-
-    wxPGProperty* property = (wxPGProperty*) classInfo->CreateObject();
-
-    property->SetLabel(propLabel);
-    property->DoSetName(propName);
-
-    if ( pChoices && pChoices->IsOk() )
-        property->SetChoices(*pChoices);
-
-    m_state->DoInsert(parent, -1, property);
-
-    if ( propValue )
-        property->SetValueFromString( *propValue, wxPG_FULL_VALUE|
-                                                  wxPG_PROGRAMMATIC_VALUE );
-
-    return property;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPopulator::AddChildren( wxPGProperty* property )
-{
-    m_propHierarchy.push_back(property);
-    DoScanForChildren();
-    m_propHierarchy.pop_back();
-}
-
-// -----------------------------------------------------------------------
-
-wxPGChoices wxPropertyGridPopulator::ParseChoices( const wxString& choicesString,
-                                                   const wxString& idString )
-{
-    wxPGChoices choices;
-
-    // Using id?
-    if ( choicesString[0] == wxT('@') )
-    {
-        wxString ids = choicesString.substr(1);
-        wxPGHashMapS2P::iterator it = m_dictIdChoices.find(ids);
-        if ( it == m_dictIdChoices.end() )
-            ProcessError(wxString::Format(wxT("No choices defined for id '%s'"),ids.c_str()));
-        else
-            choices.AssignData((wxPGChoicesData*)it->second);
-    }
-    else
-    {
-        bool found = false;
-        if ( idString.length() )
-        {
-            wxPGHashMapS2P::iterator it = m_dictIdChoices.find(idString);
-            if ( it != m_dictIdChoices.end() )
-            {
-                choices.AssignData((wxPGChoicesData*)it->second);
-                found = true;
-            }
-        }
-
-        if ( !found )
-        {
-            // Parse choices string
-            wxString::const_iterator it = choicesString.begin();
-            wxString label;
-            wxString value;
-            int state = 0;
-            bool labelValid = false;
-
-            for ( ; it != choicesString.end(); ++it )
-            {
-                wxChar c = *it;
-
-                if ( state != 1 )
-                {
-                    if ( c == wxT('"') )
-                    {
-                        if ( labelValid )
-                        {
-                            long l;
-                            if ( !value.ToLong(&l, 0) ) l = wxPG_INVALID_VALUE;
-                            choices.Add(label, l);
-                        }
-                        labelValid = false;
-                        //wxLogDebug(wxT("%s, %s"),label.c_str(),value.c_str());
-                        value.clear();
-                        label.clear();
-                        state = 1;
-                    }
-                    else if ( c == wxT('=') )
-                    {
-                        if ( labelValid )
-                        {
-                            state = 2;
-                        }
-                    }
-                    else if ( state == 2 && (wxIsalnum(c) || c == wxT('x')) )
-                    {
-                        value << c;
-                    }
-                }
-                else
-                {
-                    if ( c == wxT('"') )
-                    {
-                        state = 0;
-                        labelValid = true;
-                    }
-                    else
-                        label << c;
-                }
-            }
-
-            if ( labelValid )
-            {
-                long l;
-                if ( !value.ToLong(&l, 0) ) l = wxPG_INVALID_VALUE;
-                choices.Add(label, l);
-            }
-
-            if ( !choices.IsOk() )
-            {
-                choices.EnsureData();
-            }
-
-            // Assign to id
-            if ( idString.length() )
-                m_dictIdChoices[idString] = choices.GetData();
-        }
-    }
-
-    return choices;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPopulator::ToLongPCT( const wxString& s, long* pval, long max )
-{
-    if ( s.Last() == wxT('%') )
-    {
-        wxString s2 = s.substr(0,s.length()-1);
-        long val;
-        if ( s2.ToLong(&val, 10) )
-        {
-            *pval = (val*max)/100;
-            return true;
-        }
-        return false;
-    }
-
-    return s.ToLong(pval, 10);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPopulator::AddAttribute( const wxString& name,
-                                            const wxString& type,
-                                            const wxString& value )
-{
-    int l = m_propHierarchy.size();
-    if ( !l )
-        return false;
-
-    wxPGProperty* p = m_propHierarchy[l-1];
-    wxString valuel = value.Lower();
-    wxVariant variant;
-
-    if ( type.length() == 0 )
-    {
-        long v;
-
-        // Auto-detect type
-        if ( valuel == wxT("true") || valuel == wxT("yes") || valuel == wxT("1") )
-            variant = true;
-        else if ( valuel == wxT("false") || valuel == wxT("no") || valuel == wxT("0") )
-            variant = false;
-        else if ( value.ToLong(&v, 0) )
-            variant = v;
-        else
-            variant = value;
-    }
-    else
-    {
-        if ( type == wxT("string") )
-        {
-            variant = value;
-        }
-        else if ( type == wxT("int") )
-        {
-            long v = 0;
-            value.ToLong(&v, 0);
-            variant = v;
-        }
-        else if ( type == wxT("bool") )
-        {
-            if ( valuel == wxT("true") || valuel == wxT("yes") || valuel == wxT("1") )
-                variant = true;
-            else
-                variant = false;
-        }
-        else
-        {
-            ProcessError(wxString::Format(wxT("Invalid attribute type '%s'"),type.c_str()));
-            return false;
-        }
-    }
-
-    p->SetAttribute( name, variant );
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPopulator::ProcessError( const wxString& msg )
-{
-    wxLogError(_("Error in resource: %s"),msg.c_str());
-}
-
-// -----------------------------------------------------------------------
-
-#endif  // wxUSE_PROPGRID
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/propgrid.cpp
+// Purpose:     wxPropertyGrid
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2004-09-25
+// RCS-ID:      $Id: propgrid.cpp 61014 2009-06-12 13:39:36Z JMS $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcmemory.h"
+    #include "wx/button.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/cursor.h"
+    #include "wx/dialog.h"
+    #include "wx/settings.h"
+    #include "wx/msgdlg.h"
+    #include "wx/choice.h"
+    #include "wx/stattext.h"
+    #include "wx/scrolwin.h"
+    #include "wx/dirdlg.h"
+    #include "wx/sizer.h"
+    #include "wx/textdlg.h"
+    #include "wx/filedlg.h"
+    #include "wx/statusbr.h"
+    #include "wx/intl.h"
+    #include "wx/frame.h"
+#endif
+
+
+// This define is necessary to prevent macro clearing
+#define __wxPG_SOURCE_FILE__
+
+#include "wx/propgrid/propgrid.h"
+#include "wx/propgrid/editors.h"
+
+#if wxPG_USE_RENDERER_NATIVE
+    #include "wx/renderer.h"
+#endif
+
+#include "wx/odcombo.h"
+
+#include "wx/timer.h"
+#include "wx/dcbuffer.h"
+#include "wx/clipbrd.h"
+#include "wx/dataobj.h"
+
+#ifdef __WXMSW__
+    #include "wx/msw/private.h"
+#endif
+
+// Two pics for the expand / collapse buttons.
+// Files are not supplied with this project (since it is
+// recommended to use either custom or native rendering).
+// If you want them, get wxTreeMultiCtrl by Jorgen Bodde,
+// and copy xpm files from archive to wxPropertyGrid src directory
+// (and also comment/undef wxPG_ICON_WIDTH in propGrid.h
+// and set wxPG_USE_RENDERER_NATIVE to 0).
+#ifndef wxPG_ICON_WIDTH
+  #if defined(__WXMAC__)
+    #include "mac_collapse.xpm"
+    #include "mac_expand.xpm"
+  #elif defined(__WXGTK__)
+    #include "linux_collapse.xpm"
+    #include "linux_expand.xpm"
+  #else
+    #include "default_collapse.xpm"
+    #include "default_expand.xpm"
+  #endif
+#endif
+
+
+//#define wxPG_TEXT_INDENT                4 // For the wxComboControl
+//#define wxPG_ALLOW_CLIPPING             1 // If 1, GetUpdateRegion() in OnPaint event handler is not ignored
+#define wxPG_GUTTER_DIV                 3 // gutter is max(iconwidth/gutter_div,gutter_min)
+#define wxPG_GUTTER_MIN                 3 // gutter before and after image of [+] or [-]
+#define wxPG_YSPACING_MIN               1
+#define wxPG_DEFAULT_VSPACING           2 // This matches .NET propertygrid's value,
+                                          // but causes normal combobox to spill out under MSW
+
+//#define wxPG_OPTIMAL_WIDTH              200 // Arbitrary
+
+//#define wxPG_MIN_SCROLLBAR_WIDTH        10 // Smallest scrollbar width on any platform
+                                           // Must be larger than largest control border
+                                           // width * 2.
+
+
+#define wxPG_DEFAULT_CURSOR             wxNullCursor
+
+
+//#define wxPG_NAT_CHOICE_BORDER_ANY   0
+
+//#define wxPG_HIDER_BUTTON_HEIGHT        25
+
+#define wxPG_PIXELS_PER_UNIT            m_lineHeight
+
+#ifdef wxPG_ICON_WIDTH
+  #define m_iconHeight m_iconWidth
+#endif
+
+//#define wxPG_TOOLTIP_DELAY              1000
+
+// -----------------------------------------------------------------------
+
+#if wxUSE_INTL
+void wxPropertyGrid::AutoGetTranslation ( bool enable )
+{
+    wxPGGlobalVars->m_autoGetTranslation = enable;
+}
+#else
+void wxPropertyGrid::AutoGetTranslation ( bool ) { }
+#endif
+
+// -----------------------------------------------------------------------
+
+const char wxPropertyGridNameStr[] = "wxPropertyGrid";
+
+// -----------------------------------------------------------------------
+// Statics in one class for easy destruction.
+// -----------------------------------------------------------------------
+
+#include "wx/module.h"
+
+class wxPGGlobalVarsClassManager : public wxModule
+{
+    DECLARE_DYNAMIC_CLASS(wxPGGlobalVarsClassManager)
+public:
+    wxPGGlobalVarsClassManager() {}
+    virtual bool OnInit() { wxPGGlobalVars = new wxPGGlobalVarsClass(); return true; }
+    virtual void OnExit() { delete wxPGGlobalVars; wxPGGlobalVars = NULL; }
+};
+
+IMPLEMENT_DYNAMIC_CLASS(wxPGGlobalVarsClassManager, wxModule)
+
+
+// When wxPG is loaded dynamically after the application is already running
+// then the built-in module system won't pick this one up.  Add it manually.
+void wxPGInitResourceModule()
+{
+    wxModule* module = new wxPGGlobalVarsClassManager;
+    module->Init();
+    wxModule::RegisterModule(module);
+}
+
+wxPGGlobalVarsClass* wxPGGlobalVars = NULL;
+
+
+wxPGGlobalVarsClass::wxPGGlobalVarsClass()
+{
+    wxPGProperty::sm_wxPG_LABEL = new wxString(wxPG_LABEL_STRING);
+
+    m_boolChoices.Add(_("False"));
+    m_boolChoices.Add(_("True"));
+
+    m_fontFamilyChoices = NULL;
+
+    m_defaultRenderer = new wxPGDefaultRenderer();
+
+    m_autoGetTranslation = false;
+
+    m_offline = 0;
+
+    m_extraStyle = 0;
+
+    wxVariant v;
+
+    // Prepare some shared variants
+    m_vEmptyString = wxString();
+    m_vZero = (long) 0;
+    m_vMinusOne = (long) -1;
+    m_vTrue = true;
+    m_vFalse = false;
+
+    // Prepare cached string constants
+    m_strstring = wxS("string");
+    m_strlong = wxS("long");
+    m_strbool = wxS("bool");
+    m_strlist = wxS("list");
+    m_strMin = wxS("Min");
+    m_strMax = wxS("Max");
+    m_strUnits = wxS("Units");
+    m_strInlineHelp = wxS("InlineHelp");
+
+    m_warnings = 0;
+}
+
+
+wxPGGlobalVarsClass::~wxPGGlobalVarsClass()
+{
+    size_t i;
+
+    delete m_defaultRenderer;
+
+    // This will always have one ref
+    delete m_fontFamilyChoices;
+
+#if wxUSE_VALIDATORS
+    for ( i=0; i<m_arrValidators.size(); i++ )
+        delete ((wxValidator*)m_arrValidators[i]);
+#endif
+
+    //
+    // Destroy value type class instances.
+    wxPGHashMapS2P::iterator vt_it;
+
+    // Destroy editor class instances.
+    // iterate over all the elements in the class
+    for( vt_it = m_mapEditorClasses.begin(); vt_it != m_mapEditorClasses.end(); ++vt_it )
+    {
+        delete ((wxPGEditor*)vt_it->second);
+    }
+
+    delete wxPGProperty::sm_wxPG_LABEL;
+}
+
+void wxPropertyGridInitGlobalsIfNeeded()
+{
+}
+
+// -----------------------------------------------------------------------
+// wxPGTLWHandler
+//   Intercepts Close-events sent to wxPropertyGrid's top-level parent,
+//   and tries to commit property value.
+// -----------------------------------------------------------------------
+
+class wxPGTLWHandler : public wxEvtHandler
+{
+public:
+
+    wxPGTLWHandler( wxPropertyGrid* pg )
+        : wxEvtHandler()
+    {
+        m_pg = pg;
+    }
+
+protected:
+
+    void OnClose( wxCloseEvent& event )
+    {
+        // ClearSelection forces value validation/commit.
+        if ( event.CanVeto() && !m_pg->ClearSelection() )
+        {
+            event.Veto();
+            return;
+        }
+
+        event.Skip();
+    }
+
+private:
+    wxPropertyGrid*     m_pg;
+
+    DECLARE_EVENT_TABLE()
+};
+
+BEGIN_EVENT_TABLE(wxPGTLWHandler, wxEvtHandler)
+    EVT_CLOSE(wxPGTLWHandler::OnClose)
+END_EVENT_TABLE()
+
+// -----------------------------------------------------------------------
+// wxPGCanvas
+// -----------------------------------------------------------------------
+
+//
+// wxPGCanvas acts as a graphics sub-window of the
+// wxScrolledWindow that wxPropertyGrid is.
+//
+class wxPGCanvas : public wxPanel
+{
+public:
+    wxPGCanvas() : wxPanel()
+    {
+    }
+    virtual ~wxPGCanvas() { }
+
+protected:
+    void OnMouseMove( wxMouseEvent &event )
+    {
+        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+        pg->OnMouseMove( event );
+    }
+
+    void OnMouseClick( wxMouseEvent &event )
+    {
+        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+        pg->OnMouseClick( event );
+    }
+
+    void OnMouseUp( wxMouseEvent &event )
+    {
+        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+        pg->OnMouseUp( event );
+    }
+
+    void OnMouseRightClick( wxMouseEvent &event )
+    {
+        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+        pg->OnMouseRightClick( event );
+    }
+
+    void OnMouseDoubleClick( wxMouseEvent &event )
+    {
+        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+        pg->OnMouseDoubleClick( event );
+    }
+
+    void OnKey( wxKeyEvent& event )
+    {
+        wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+        pg->OnKey( event );
+    }
+
+    void OnPaint( wxPaintEvent& event );
+
+    // Always be focussable, even with child windows
+    virtual void SetCanFocus(bool WXUNUSED(canFocus))
+    {  wxPanel::SetCanFocus(true); }
+
+
+private:
+    DECLARE_EVENT_TABLE()
+    DECLARE_ABSTRACT_CLASS(wxPGCanvas)
+};
+
+
+IMPLEMENT_ABSTRACT_CLASS(wxPGCanvas,wxPanel)
+
+BEGIN_EVENT_TABLE(wxPGCanvas, wxPanel)
+    EVT_MOTION(wxPGCanvas::OnMouseMove)
+    EVT_PAINT(wxPGCanvas::OnPaint)
+    EVT_LEFT_DOWN(wxPGCanvas::OnMouseClick)
+    EVT_LEFT_UP(wxPGCanvas::OnMouseUp)
+    EVT_RIGHT_UP(wxPGCanvas::OnMouseRightClick)
+    EVT_LEFT_DCLICK(wxPGCanvas::OnMouseDoubleClick)
+    EVT_KEY_DOWN(wxPGCanvas::OnKey)
+END_EVENT_TABLE()
+
+
+void wxPGCanvas::OnPaint( wxPaintEvent& WXUNUSED(event) )
+{
+    wxPropertyGrid* pg = wxStaticCast(GetParent(), wxPropertyGrid);
+    wxASSERT( pg->IsKindOf(CLASSINFO(wxPropertyGrid)) );
+
+    wxPaintDC dc(this);
+
+    // Don't paint after destruction has begun
+    if ( !(pg->GetInternalFlags() & wxPG_FL_INITIALIZED) )
+        return;
+
+    // Update everything inside the box
+    wxRect r = GetUpdateRegion().GetBox();
+
+    // FIXME: This is just a workaround for a bug that causes splitters not
+    //        to paint when other windows are being dragged over the grid.
+    wxRect fullRect = GetRect();
+    r.x = fullRect.x;
+    r.width = fullRect.width;
+
+    // Repaint this rectangle
+    pg->DrawItems( dc, r.y, r.y + r.height, &r );
+
+    // We assume that the size set when grid is shown
+    // is what is desired.
+    pg->SetInternalFlag(wxPG_FL_GOOD_SIZE_SET);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxPropertyGrid, wxScrolledWindow)
+
+BEGIN_EVENT_TABLE(wxPropertyGrid, wxScrolledWindow)
+  EVT_IDLE(wxPropertyGrid::OnIdle)
+  EVT_MOTION(wxPropertyGrid::OnMouseMoveBottom)
+  EVT_PAINT(wxPropertyGrid::OnPaint)
+  EVT_SIZE(wxPropertyGrid::OnResize)
+  EVT_ENTER_WINDOW(wxPropertyGrid::OnMouseEntry)
+  EVT_LEAVE_WINDOW(wxPropertyGrid::OnMouseEntry)
+  EVT_MOUSE_CAPTURE_CHANGED(wxPropertyGrid::OnCaptureChange)
+  EVT_SCROLLWIN(wxPropertyGrid::OnScrollEvent)
+  EVT_CHILD_FOCUS(wxPropertyGrid::OnChildFocusEvent)
+  EVT_SET_FOCUS(wxPropertyGrid::OnFocusEvent)
+  EVT_KILL_FOCUS(wxPropertyGrid::OnFocusEvent)
+  EVT_SYS_COLOUR_CHANGED(wxPropertyGrid::OnSysColourChanged)
+END_EVENT_TABLE()
+
+
+// -----------------------------------------------------------------------
+
+wxPropertyGrid::wxPropertyGrid()
+    : wxScrolledWindow()
+{
+    Init1();
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGrid::wxPropertyGrid( wxWindow *parent,
+                                wxWindowID id,
+                                const wxPoint& pos,
+                                const wxSize& size,
+                                long style,
+                                const wxString& name )
+    : wxScrolledWindow()
+{
+    Init1();
+    Create(parent,id,pos,size,style,name);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::Create( wxWindow *parent,
+                             wxWindowID id,
+                             const wxPoint& pos,
+                             const wxSize& size,
+                             long style,
+                             const wxString& name )
+{
+
+    //if ( !(style&wxBORDER_MASK) )
+        //style |= wxBORDER_THEME;
+
+    style |= wxVSCROLL;
+
+    // Filter out wxTAB_TRAVERSAL - we will handle TABs manually
+    style &= ~(wxTAB_TRAVERSAL);
+    style |= wxWANTS_CHARS;
+
+    wxScrolledWindow::Create(parent,id,pos,size,style,name);
+
+    Init2();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+//
+// Initialize values to defaults
+//
+void wxPropertyGrid::Init1()
+{
+    // Register editor classes, if necessary.
+    if ( wxPGGlobalVars->m_mapEditorClasses.empty() )
+        wxPropertyGrid::RegisterDefaultEditors();
+
+    m_iFlags = 0;
+    m_pState = NULL;
+    m_wndEditor = m_wndEditor2 = NULL;
+    m_selected = NULL;
+    m_selColumn = -1;
+    m_propHover = NULL;
+    m_eventObject = this;
+    m_curFocused = NULL;
+    m_tlwHandler = NULL;
+    m_sortFunction = NULL;
+    m_inDoPropertyChanged = 0;
+    m_inCommitChangesFromEditor = 0;
+    m_inDoSelectProperty = 0;
+    m_permanentValidationFailureBehavior = wxPG_VFB_DEFAULT;
+    m_dragStatus = 0;
+    m_mouseSide = 16;
+    m_editorFocused = 0;
+
+    // Set default keys
+    AddActionTrigger( wxPG_ACTION_NEXT_PROPERTY, WXK_RIGHT );
+    AddActionTrigger( wxPG_ACTION_NEXT_PROPERTY, WXK_DOWN );
+    AddActionTrigger( wxPG_ACTION_PREV_PROPERTY, WXK_LEFT );
+    AddActionTrigger( wxPG_ACTION_PREV_PROPERTY, WXK_UP );
+    AddActionTrigger( wxPG_ACTION_EXPAND_PROPERTY, WXK_RIGHT);
+    AddActionTrigger( wxPG_ACTION_COLLAPSE_PROPERTY, WXK_LEFT);
+    AddActionTrigger( wxPG_ACTION_CANCEL_EDIT, WXK_ESCAPE );
+    AddActionTrigger( wxPG_ACTION_PRESS_BUTTON, WXK_DOWN, wxMOD_ALT );
+    AddActionTrigger( wxPG_ACTION_PRESS_BUTTON, WXK_F4 );
+
+    m_coloursCustomized = 0;
+    m_frozen = 0;
+
+    m_canvas = NULL;
+
+#if wxPG_DOUBLE_BUFFER
+    m_doubleBuffer = NULL;
+#endif
+
+#ifndef wxPG_ICON_WIDTH
+    m_expandbmp = NULL;
+    m_collbmp = NULL;
+    m_iconWidth = 11;
+    m_iconHeight = 11;
+#else
+    m_iconWidth = wxPG_ICON_WIDTH;
+#endif
+
+    m_prevVY = -1;
+
+    m_gutterWidth = wxPG_GUTTER_MIN;
+    m_subgroup_extramargin = 10;
+
+    m_lineHeight = 0;
+
+    m_width = m_height = 0;
+
+    m_commonValues.push_back(new wxPGCommonValue(_("Unspecified"), wxPGGlobalVars->m_defaultRenderer) );
+    m_cvUnspecified = 0;
+
+    m_chgInfo_changedProperty = NULL;
+}
+
+// -----------------------------------------------------------------------
+
+//
+// Initialize after parent etc. set
+//
+void wxPropertyGrid::Init2()
+{
+    wxASSERT( !(m_iFlags & wxPG_FL_INITIALIZED ) );
+
+#ifdef __WXMAC__
+   // Smaller controls on Mac
+   SetWindowVariant(wxWINDOW_VARIANT_SMALL);
+#endif
+
+    // Now create state, if one didn't exist already
+    // (wxPropertyGridManager might have created it for us).
+    if ( !m_pState )
+    {
+        m_pState = CreateState();
+        m_pState->m_pPropGrid = this;
+        m_iFlags |= wxPG_FL_CREATEDSTATE;
+    }
+
+    if ( !(m_windowStyle & wxPG_SPLITTER_AUTO_CENTER) )
+        m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
+
+    if ( m_windowStyle & wxPG_HIDE_CATEGORIES )
+    {
+        m_pState->InitNonCatMode();
+
+        m_pState->m_properties = m_pState->m_abcArray;
+    }
+
+    GetClientSize(&m_width,&m_height);
+
+#ifndef wxPG_ICON_WIDTH
+    // create two bitmap nodes for drawing
+    m_expandbmp = new wxBitmap(expand_xpm);
+    m_collbmp = new wxBitmap(collapse_xpm);
+
+    // calculate average font height for bitmap centering
+
+    m_iconWidth = m_expandbmp->GetWidth();
+    m_iconHeight = m_expandbmp->GetHeight();
+#endif
+
+    m_curcursor = wxCURSOR_ARROW;
+    m_cursorSizeWE = new wxCursor( wxCURSOR_SIZEWE );
+
+    // adjust bitmap icon y position so they are centered
+    m_vspacing = wxPG_DEFAULT_VSPACING;
+
+    CalculateFontAndBitmapStuff( wxPG_DEFAULT_VSPACING );
+
+    // Allocate cell datas indirectly by calling setter
+    m_propertyDefaultCell.SetBgCol(*wxBLACK);
+    m_categoryDefaultCell.SetBgCol(*wxBLACK);
+
+    RegainColours();
+
+    // This helps with flicker
+    SetBackgroundStyle( wxBG_STYLE_CUSTOM );
+
+    // Hook the TLW
+    wxPGTLWHandler* handler = new wxPGTLWHandler(this);
+    m_tlp = ::wxGetTopLevelParent(this);
+    m_tlwHandler = handler;
+    m_tlp->PushEventHandler(handler);
+
+    // set virtual size to this window size
+    wxSize wndsize = GetSize();
+    SetVirtualSize(wndsize.GetWidth(), wndsize.GetWidth());
+
+    m_timeCreated = ::wxGetLocalTimeMillis();
+
+    m_canvas = new wxPGCanvas();
+    m_canvas->Create(this, 1, wxPoint(0, 0), GetClientSize(),
+                     wxWANTS_CHARS | wxCLIP_CHILDREN);
+    m_canvas->SetBackgroundStyle( wxBG_STYLE_CUSTOM );
+
+    m_iFlags |= wxPG_FL_INITIALIZED;
+
+    m_ncWidth = wndsize.GetWidth();
+
+    // Need to call OnResize handler or size given in constructor/Create
+    // will never work.
+    wxSizeEvent sizeEvent(wndsize,0);
+    OnResize(sizeEvent);
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGrid::~wxPropertyGrid()
+{
+    size_t i;
+
+    DoSelectProperty(NULL);
+
+    // This should do prevent things from going too badly wrong
+    m_iFlags &= ~(wxPG_FL_INITIALIZED);
+
+    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
+        m_canvas->ReleaseMouse();
+
+    wxPGTLWHandler* handler = (wxPGTLWHandler*) m_tlwHandler;
+    m_tlp->RemoveEventHandler(handler);
+    delete handler;
+
+    wxASSERT_MSG( !IsEditorsValueModified(),
+                  wxS("Most recent change in property editor was lost!!! ")
+                  wxS("(if you don't want this to happen, close your frames ")
+                  wxS("and dialogs using Close(false).)") );
+
+#if wxPG_DOUBLE_BUFFER
+    if ( m_doubleBuffer )
+        delete m_doubleBuffer;
+#endif
+
+    //m_selected = NULL;
+
+    if ( m_iFlags & wxPG_FL_CREATEDSTATE )
+        delete m_pState;
+
+    delete m_cursorSizeWE;
+
+#ifndef wxPG_ICON_WIDTH
+    delete m_expandbmp;
+    delete m_collbmp;
+#endif
+
+    // Delete common value records
+    for ( i=0; i<m_commonValues.size(); i++ )
+    {
+        delete GetCommonValue(i);
+    }
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::Destroy()
+{
+    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
+        m_canvas->ReleaseMouse();
+
+    return wxScrolledWindow::Destroy();
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridPageState* wxPropertyGrid::CreateState() const
+{
+    return new wxPropertyGridPageState();
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid overridden wxWindow methods
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetWindowStyleFlag( long style )
+{
+    long old_style = m_windowStyle;
+
+    if ( m_iFlags & wxPG_FL_INITIALIZED )
+    {
+        wxASSERT( m_pState );
+
+        if ( !(style & wxPG_HIDE_CATEGORIES) && (old_style & wxPG_HIDE_CATEGORIES) )
+        {
+        // Enable categories
+            EnableCategories( true );
+        }
+        else if ( (style & wxPG_HIDE_CATEGORIES) && !(old_style & wxPG_HIDE_CATEGORIES) )
+        {
+        // Disable categories
+            EnableCategories( false );
+        }
+        if ( !(old_style & wxPG_AUTO_SORT) && (style & wxPG_AUTO_SORT) )
+        {
+            //
+            // Autosort enabled
+            //
+            if ( !m_frozen )
+                PrepareAfterItemsAdded();
+            else
+                m_pState->m_itemsAdded = 1;
+        }
+    #if wxPG_SUPPORT_TOOLTIPS
+        if ( !(old_style & wxPG_TOOLTIPS) && (style & wxPG_TOOLTIPS) )
+        {
+            //
+            // Tooltips enabled
+            //
+            /*
+            wxToolTip* tooltip = new wxToolTip ( wxEmptyString );
+            SetToolTip ( tooltip );
+            tooltip->SetDelay ( wxPG_TOOLTIP_DELAY );
+            */
+        }
+        else if ( (old_style & wxPG_TOOLTIPS) && !(style & wxPG_TOOLTIPS) )
+        {
+            //
+            // Tooltips disabled
+            //
+            m_canvas->SetToolTip( NULL );
+        }
+    #endif
+    }
+
+    wxScrolledWindow::SetWindowStyleFlag ( style );
+
+    if ( m_iFlags & wxPG_FL_INITIALIZED )
+    {
+        if ( (old_style & wxPG_HIDE_MARGIN) != (style & wxPG_HIDE_MARGIN) )
+        {
+            CalculateFontAndBitmapStuff( m_vspacing );
+            Refresh();
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::Freeze()
+{
+    if ( !m_frozen )
+    {
+        wxScrolledWindow::Freeze();
+    }
+    m_frozen++;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::Thaw()
+{
+    m_frozen--;
+
+    if ( !m_frozen )
+    {
+        wxScrolledWindow::Thaw();
+        RecalculateVirtualSize();
+    #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+        m_canvas->Refresh();
+    #endif
+
+        // Force property re-selection
+        if ( m_selected )
+            DoSelectProperty(m_selected, wxPG_SEL_FORCE);
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetExtraStyle( long exStyle )
+{
+    if ( exStyle & wxPG_EX_NATIVE_DOUBLE_BUFFERING )
+    {
+#if defined(__WXMSW__)
+
+        /*
+        // Don't use WS_EX_COMPOSITED just now.
+        HWND hWnd;
+
+        if ( m_iFlags & wxPG_FL_IN_MANAGER )
+            hWnd = (HWND)GetParent()->GetHWND();
+        else
+            hWnd = (HWND)GetHWND();
+
+        ::SetWindowLong( hWnd, GWL_EXSTYLE,
+                         ::GetWindowLong(hWnd, GWL_EXSTYLE) | WS_EX_COMPOSITED );
+        */
+
+//#elif defined(__WXGTK20__)
+#endif
+        // Only apply wxPG_EX_NATIVE_DOUBLE_BUFFERING if the window
+        // truly was double-buffered.
+        if ( !this->IsDoubleBuffered() )
+        {
+            exStyle &= ~(wxPG_EX_NATIVE_DOUBLE_BUFFERING);
+        }
+        else
+        {
+        #if wxPG_DOUBLE_BUFFER
+            delete m_doubleBuffer;
+            m_doubleBuffer = NULL;
+        #endif
+        }
+    }
+
+    wxScrolledWindow::SetExtraStyle( exStyle );
+
+    if ( exStyle & wxPG_EX_INIT_NOCAT )
+        m_pState->InitNonCatMode();
+
+    if ( exStyle & wxPG_EX_HELP_AS_TOOLTIPS )
+        m_windowStyle |= wxPG_TOOLTIPS;
+
+    // Set global style
+    wxPGGlobalVars->m_extraStyle = exStyle;
+}
+
+// -----------------------------------------------------------------------
+
+// returns the best acceptable minimal size
+wxSize wxPropertyGrid::DoGetBestSize() const
+{
+    int hei = 15;
+    if ( m_lineHeight > hei )
+        hei = m_lineHeight;
+    wxSize sz = wxSize( 60, hei+40 );
+
+    CacheBestSize(sz);
+    return sz;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid Font and Colour Methods
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::CalculateFontAndBitmapStuff( int vspacing )
+{
+    int x = 0, y = 0;
+
+    m_captionFont = wxScrolledWindow::GetFont();
+
+    GetTextExtent(wxS("jG"), &x, &y, 0, 0, &m_captionFont);
+    m_subgroup_extramargin = x + (x/2);
+    m_fontHeight = y;
+
+#if wxPG_USE_RENDERER_NATIVE
+    m_iconWidth = wxPG_ICON_WIDTH;
+#elif wxPG_ICON_WIDTH
+    // scale icon
+    m_iconWidth = (m_fontHeight * wxPG_ICON_WIDTH) / 13;
+    if ( m_iconWidth < 5 ) m_iconWidth = 5;
+    else if ( !(m_iconWidth & 0x01) ) m_iconWidth++; // must be odd
+
+#endif
+
+    m_gutterWidth = m_iconWidth / wxPG_GUTTER_DIV;
+    if ( m_gutterWidth < wxPG_GUTTER_MIN )
+        m_gutterWidth = wxPG_GUTTER_MIN;
+
+    int vdiv = 6;
+    if ( vspacing <= 1 ) vdiv = 12;
+    else if ( vspacing >= 3 ) vdiv = 3;
+
+    m_spacingy = m_fontHeight / vdiv;
+    if ( m_spacingy < wxPG_YSPACING_MIN )
+        m_spacingy = wxPG_YSPACING_MIN;
+
+    m_marginWidth = 0;
+    if ( !(m_windowStyle & wxPG_HIDE_MARGIN) )
+        m_marginWidth = m_gutterWidth*2 + m_iconWidth;
+
+    m_captionFont.SetWeight(wxBOLD);
+    GetTextExtent(wxS("jG"), &x, &y, 0, 0, &m_captionFont);
+
+    m_lineHeight = m_fontHeight+(2*m_spacingy)+1;
+
+    // button spacing
+    m_buttonSpacingY = (m_lineHeight - m_iconHeight) / 2;
+    if ( m_buttonSpacingY < 0 ) m_buttonSpacingY = 0;
+
+    if ( m_pState )
+        m_pState->CalculateFontAndBitmapStuff(vspacing);
+
+    if ( m_iFlags & wxPG_FL_INITIALIZED )
+        RecalculateVirtualSize();
+
+    InvalidateBestSize();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnSysColourChanged( wxSysColourChangedEvent &WXUNUSED(event) )
+{
+    RegainColours();
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+static wxColour wxPGAdjustColour(const wxColour& src, int ra,
+                                 int ga = 1000, int ba = 1000,
+                                 bool forceDifferent = false)
+{
+    if ( ga >= 1000 )
+        ga = ra;
+    if ( ba >= 1000 )
+        ba = ra;
+
+    // Recursion guard (allow 2 max)
+    static int isinside = 0;
+    isinside++;
+    wxCHECK_MSG( isinside < 3,
+                 *wxBLACK,
+                 wxT("wxPGAdjustColour should not be recursively called more than once") );
+
+    wxColour dst;
+
+    int r = src.Red();
+    int g = src.Green();
+    int b = src.Blue();
+    int r2 = r + ra;
+    if ( r2>255 ) r2 = 255;
+    else if ( r2<0) r2 = 0;
+    int g2 = g + ga;
+    if ( g2>255 ) g2 = 255;
+    else if ( g2<0) g2 = 0;
+    int b2 = b + ba;
+    if ( b2>255 ) b2 = 255;
+    else if ( b2<0) b2 = 0;
+
+    // Make sure they are somewhat different
+    if ( forceDifferent && (abs((r+g+b)-(r2+g2+b2)) < abs(ra/2)) )
+        dst = wxPGAdjustColour(src,-(ra*2));
+    else
+        dst = wxColour(r2,g2,b2);
+
+    // Recursion guard (allow 2 max)
+    isinside--;
+
+    return dst;
+}
+
+
+static int wxPGGetColAvg( const wxColour& col )
+{
+    return (col.Red() + col.Green() + col.Blue()) / 3;
+}
+
+
+void wxPropertyGrid::RegainColours()
+{
+    if ( !(m_coloursCustomized & 0x0002) )
+    {
+        wxColour col = wxSystemSettings::GetColour( wxSYS_COLOUR_BTNFACE );
+
+        // Make sure colour is dark enough
+    #ifdef __WXGTK__
+        int colDec = wxPGGetColAvg(col) - 230;
+    #else
+        int colDec = wxPGGetColAvg(col) - 200;
+    #endif
+        if ( colDec > 0 )
+            m_colCapBack = wxPGAdjustColour(col,-colDec);
+        else
+            m_colCapBack = col;
+        m_categoryDefaultCell.GetData()->SetBgCol(m_colCapBack);
+    }
+
+    if ( !(m_coloursCustomized & 0x0001) )
+        m_colMargin = m_colCapBack;
+
+    if ( !(m_coloursCustomized & 0x0004) )
+    {
+    #ifdef __WXGTK__
+        int colDec = -90;
+    #else
+        int colDec = -72;
+    #endif
+        wxColour capForeCol = wxPGAdjustColour(m_colCapBack,colDec,5000,5000,true);
+        m_colCapFore = capForeCol;
+        m_categoryDefaultCell.GetData()->SetFgCol(capForeCol);
+    }
+
+    if ( !(m_coloursCustomized & 0x0008) )
+    {
+        wxColour bgCol = wxSystemSettings::GetColour( wxSYS_COLOUR_WINDOW );
+        m_colPropBack = bgCol;
+        m_propertyDefaultCell.GetData()->SetBgCol(bgCol);
+    }
+
+    if ( !(m_coloursCustomized & 0x0010) )
+    {
+        wxColour fgCol = wxSystemSettings::GetColour( wxSYS_COLOUR_WINDOWTEXT );
+        m_colPropFore = fgCol;
+        m_propertyDefaultCell.GetData()->SetFgCol(fgCol);
+    }
+
+    if ( !(m_coloursCustomized & 0x0020) )
+        m_colSelBack = wxSystemSettings::GetColour( wxSYS_COLOUR_HIGHLIGHT );
+
+    if ( !(m_coloursCustomized & 0x0040) )
+        m_colSelFore = wxSystemSettings::GetColour( wxSYS_COLOUR_HIGHLIGHTTEXT );
+
+    if ( !(m_coloursCustomized & 0x0080) )
+        m_colLine = m_colCapBack;
+
+    if ( !(m_coloursCustomized & 0x0100) )
+        m_colDisPropFore = m_colCapFore;
+
+    m_colEmptySpace = wxSystemSettings::GetColour( wxSYS_COLOUR_WINDOW );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::ResetColours()
+{
+    m_coloursCustomized = 0;
+
+    RegainColours();
+
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::SetFont( const wxFont& font )
+{
+    // Must disable active editor.
+    ClearSelection(false);
+
+    bool res = wxScrolledWindow::SetFont( font );
+    if ( res && GetParent()) // may not have been Create()ed yet
+    {
+        CalculateFontAndBitmapStuff( m_vspacing );
+        Refresh();
+    }
+
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetLineColour( const wxColour& col )
+{
+    m_colLine = col;
+    m_coloursCustomized |= 0x80;
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetMarginColour( const wxColour& col )
+{
+    m_colMargin = col;
+    m_coloursCustomized |= 0x01;
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetCellBackgroundColour( const wxColour& col )
+{
+    m_colPropBack = col;
+    m_coloursCustomized |= 0x08;
+
+    m_propertyDefaultCell.GetData()->SetBgCol(col);
+
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetCellTextColour( const wxColour& col )
+{
+    m_colPropFore = col;
+    m_coloursCustomized |= 0x10;
+
+    m_propertyDefaultCell.GetData()->SetFgCol(col);
+
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetEmptySpaceColour( const wxColour& col )
+{
+    m_colEmptySpace = col;
+
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetCellDisabledTextColour( const wxColour& col )
+{
+    m_colDisPropFore = col;
+    m_coloursCustomized |= 0x100;
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetSelectionBackgroundColour( const wxColour& col )
+{
+    m_colSelBack = col;
+    m_coloursCustomized |= 0x20;
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetSelectionTextColour( const wxColour& col )
+{
+    m_colSelFore = col;
+    m_coloursCustomized |= 0x40;
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetCaptionBackgroundColour( const wxColour& col )
+{
+    m_colCapBack = col;
+    m_coloursCustomized |= 0x02;
+
+    m_categoryDefaultCell.GetData()->SetBgCol(col);
+
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetCaptionTextColour( const wxColour& col )
+{
+    m_colCapFore = col;
+    m_coloursCustomized |= 0x04;
+
+    m_categoryDefaultCell.GetData()->SetFgCol(col);
+
+    Refresh();
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid property adding and removal
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::PrepareAfterItemsAdded()
+{
+    if ( !m_pState || !m_pState->m_itemsAdded ) return;
+
+    m_pState->m_itemsAdded = 0;
+
+    if ( m_windowStyle & wxPG_AUTO_SORT )
+        Sort(wxPG_SORT_TOP_LEVEL_ONLY);
+
+    RecalculateVirtualSize();
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid property operations
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::EnsureVisible( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+
+    Update();
+
+    bool changed = false;
+
+    // Is it inside collapsed section?
+    if ( !p->IsVisible() )
+    {
+        // expand parents
+        wxPGProperty* parent = p->GetParent();
+        wxPGProperty* grandparent = parent->GetParent();
+
+        if ( grandparent && grandparent != m_pState->m_properties )
+            Expand( grandparent );
+
+        Expand( parent );
+        changed = true;
+    }
+
+    // Need to scroll?
+    int vx, vy;
+    GetViewStart(&vx,&vy);
+    vy*=wxPG_PIXELS_PER_UNIT;
+
+    int y = p->GetY();
+
+    if ( y < vy )
+    {
+        Scroll(vx, y/wxPG_PIXELS_PER_UNIT );
+        m_iFlags |= wxPG_FL_SCROLLED;
+        changed = true;
+    }
+    else if ( (y+m_lineHeight) > (vy+m_height) )
+    {
+        Scroll(vx, (y-m_height+(m_lineHeight*2))/wxPG_PIXELS_PER_UNIT );
+        m_iFlags |= wxPG_FL_SCROLLED;
+        changed = true;
+    }
+
+    if ( changed )
+        DrawItems( p, p );
+
+    return changed;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid helper methods called by properties
+// -----------------------------------------------------------------------
+
+// Control font changer helper.
+void wxPropertyGrid::SetCurControlBoldFont()
+{
+    wxASSERT( m_wndEditor );
+    m_wndEditor->SetFont( m_captionFont );
+}
+
+// -----------------------------------------------------------------------
+
+wxPoint wxPropertyGrid::GetGoodEditorDialogPosition( wxPGProperty* p,
+                                                     const wxSize& sz )
+{
+#if wxPG_SMALL_SCREEN
+    // On small-screen devices, always show dialogs with default position and size.
+    return wxDefaultPosition;
+#else
+    int splitterX = GetSplitterPosition();
+    int x = splitterX;
+    int y = p->GetY();
+
+    wxCHECK_MSG( y >= 0, wxPoint(-1,-1), wxT("invalid y?") );
+
+    ImprovedClientToScreen( &x, &y );
+
+    int sw = wxSystemSettings::GetMetric( ::wxSYS_SCREEN_X );
+    int sh = wxSystemSettings::GetMetric( ::wxSYS_SCREEN_Y );
+
+    int new_x;
+    int new_y;
+
+    if ( x > (sw/2) )
+        // left
+        new_x = x + (m_width-splitterX) - sz.x;
+    else
+        // right
+        new_x = x;
+
+    if ( y > (sh/2) )
+        // above
+        new_y = y - sz.y;
+    else
+        // below
+        new_y = y + m_lineHeight;
+
+    return wxPoint(new_x,new_y);
+#endif
+}
+
+// -----------------------------------------------------------------------
+
+wxString& wxPropertyGrid::ExpandEscapeSequences( wxString& dst_str, wxString& src_str )
+{
+    if ( src_str.length() == 0 )
+    {
+        dst_str = src_str;
+        return src_str;
+    }
+
+    bool prev_is_slash = false;
+
+    wxString::const_iterator i = src_str.begin();
+
+    dst_str.clear();
+
+    for ( ; i != src_str.end(); ++i )
+    {
+        wxUniChar a = *i;
+
+        if ( a != wxS('\\') )
+        {
+            if ( !prev_is_slash )
+            {
+                dst_str << a;
+            }
+            else
+            {
+                if ( a == wxS('n') )
+                {
+            #ifdef __WXMSW__
+                    dst_str << wxS('\n');
+            #else
+                    dst_str << wxS('\n');
+            #endif
+                }
+                else if ( a == wxS('t') )
+                    dst_str << wxS('\t');
+                else
+                    dst_str << a;
+            }
+            prev_is_slash = false;
+        }
+        else
+        {
+            if ( prev_is_slash )
+            {
+                dst_str << wxS('\\');
+                prev_is_slash = false;
+            }
+            else
+            {
+                prev_is_slash = true;
+            }
+        }
+    }
+    return dst_str;
+}
+
+// -----------------------------------------------------------------------
+
+wxString& wxPropertyGrid::CreateEscapeSequences( wxString& dst_str, wxString& src_str )
+{
+    if ( src_str.length() == 0 )
+    {
+        dst_str = src_str;
+        return src_str;
+    }
+
+    wxString::const_iterator i = src_str.begin();
+    wxUniChar prev_a = wxS('\0');
+
+    dst_str.clear();
+
+    for ( ; i != src_str.end(); ++i )
+    {
+        wxChar a = *i;
+
+        if ( a >= wxS(' ') )
+        {
+            // This surely is not something that requires an escape sequence.
+            dst_str << a;
+        }
+        else
+        {
+            // This might need...
+            if ( a == wxS('\r')  )
+            {
+                // DOS style line end.
+                // Already taken care below
+            }
+            else if ( a == wxS('\n') )
+                // UNIX style line end.
+                dst_str << wxS("\\n");
+            else if ( a == wxS('\t') )
+                // Tab.
+                dst_str << wxS('\t');
+            else
+            {
+                //wxLogDebug(wxT("WARNING: Could not create escape sequence for character #%i"),(int)a);
+                dst_str << a;
+            }
+        }
+
+        prev_a = a;
+    }
+    return dst_str;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGrid::DoGetItemAtY( int y ) const
+{
+    // Outside?
+    if ( y < 0 )
+        return NULL;
+
+    unsigned int a = 0;
+    return m_pState->m_properties->GetItemAtY(y, m_lineHeight, &a);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid graphics related methods
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnPaint( wxPaintEvent& WXUNUSED(event) )
+{
+    wxPaintDC dc(this);
+
+    // Update everything inside the box
+    wxRect r = GetUpdateRegion().GetBox();
+
+    dc.SetPen(m_colEmptySpace);
+    dc.SetBrush(m_colEmptySpace);
+    dc.DrawRectangle(r);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::DrawExpanderButton( wxDC& dc, const wxRect& rect,
+                                         wxPGProperty* property ) const
+{
+    // Prepare rectangle to be used
+    wxRect r(rect);
+    r.x += m_gutterWidth; r.y += m_buttonSpacingY;
+    r.width = m_iconWidth; r.height = m_iconHeight;
+
+#if (wxPG_USE_RENDERER_NATIVE)
+    //
+#elif wxPG_ICON_WIDTH
+    // Drawing expand/collapse button manually
+    dc.SetPen(m_colPropFore);
+    if ( property->IsCategory() )
+        dc.SetBrush(*wxTRANSPARENT_BRUSH);
+    else
+        dc.SetBrush(m_colPropBack);
+
+    dc.DrawRectangle( r );
+    int _y = r.y+(m_iconWidth/2);
+    dc.DrawLine(r.x+2,_y,r.x+m_iconWidth-2,_y);
+#else
+    wxBitmap* bmp;
+#endif
+
+    if ( property->IsExpanded() )
+    {
+    // wxRenderer functions are non-mutating in nature, so it
+    // should be safe to cast "const wxPropertyGrid*" to "wxWindow*".
+    // Hopefully this does not cause problems.
+    #if (wxPG_USE_RENDERER_NATIVE)
+        wxRendererNative::Get().DrawTreeItemButton(
+                (wxWindow*)this,
+                dc,
+                r,
+                wxCONTROL_EXPANDED
+            );
+    #elif wxPG_ICON_WIDTH
+        //
+    #else
+        bmp = m_collbmp;
+    #endif
+
+    }
+    else
+    {
+    #if (wxPG_USE_RENDERER_NATIVE)
+        wxRendererNative::Get().DrawTreeItemButton(
+                (wxWindow*)this,
+                dc,
+                r,
+                0
+            );
+    #elif wxPG_ICON_WIDTH
+        int _x = r.x+(m_iconWidth/2);
+        dc.DrawLine(_x,r.y+2,_x,r.y+m_iconWidth-2);
+    #else
+        bmp = m_expandbmp;
+    #endif
+    }
+
+#if (wxPG_USE_RENDERER_NATIVE)
+    //
+#elif wxPG_ICON_WIDTH
+    //
+#else
+    dc.DrawBitmap( *bmp, r.x, r.y, true );
+#endif
+}
+
+// -----------------------------------------------------------------------
+
+//
+// This is the one called by OnPaint event handler and others.
+// topy and bottomy are already unscrolled (ie. physical)
+//
+void wxPropertyGrid::DrawItems( wxDC& dc,
+                                unsigned int topy,
+                                unsigned int bottomy,
+                                const wxRect* clipRect )
+{
+    if ( m_frozen || m_height < 1 || bottomy < topy || !m_pState ) return;
+
+    m_pState->EnsureVirtualHeight();
+
+    wxRect tempClipRect;
+    if ( !clipRect )
+    {
+        tempClipRect = wxRect(0,topy,m_pState->m_width,bottomy);
+        clipRect = &tempClipRect;
+    }
+
+    // items added check
+    if ( m_pState->m_itemsAdded ) PrepareAfterItemsAdded();
+
+    int paintFinishY = 0;
+
+    if ( m_pState->m_properties->GetChildCount() > 0 )
+    {
+        wxDC* dcPtr = &dc;
+        bool isBuffered = false;
+
+    #if wxPG_DOUBLE_BUFFER
+        wxMemoryDC* bufferDC = NULL;
+
+        if ( !(GetExtraStyle() & wxPG_EX_NATIVE_DOUBLE_BUFFERING) )
+        {
+            if ( !m_doubleBuffer )
+            {
+                paintFinishY = clipRect->y;
+                dcPtr = NULL;
+            }
+            else
+            {
+                bufferDC = new wxMemoryDC();
+
+                // If nothing was changed, then just copy from double-buffer
+                bufferDC->SelectObject( *m_doubleBuffer );
+                dcPtr = bufferDC;
+
+                isBuffered = true;
+            }
+        }
+    #endif
+
+        if ( dcPtr )
+        {
+            dc.SetClippingRegion( *clipRect );
+            paintFinishY = DoDrawItems( *dcPtr, clipRect, isBuffered );
+        }
+
+    #if wxPG_DOUBLE_BUFFER
+        if ( bufferDC )
+        {
+            dc.Blit( clipRect->x, clipRect->y, clipRect->width, clipRect->height,
+                bufferDC, 0, 0, wxCOPY );
+            dc.DestroyClippingRegion(); // Is this really necessary?
+            delete bufferDC;
+        }
+    #endif
+    }
+
+    // Clear area beyond bottomY?
+    if ( paintFinishY < (clipRect->y+clipRect->height) )
+    {
+        dc.SetPen(m_colEmptySpace);
+        dc.SetBrush(m_colEmptySpace);
+        dc.DrawRectangle( 0, paintFinishY, m_width, (clipRect->y+clipRect->height) );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+int wxPropertyGrid::DoDrawItems( wxDC& dc,
+                                 const wxRect* clipRect,
+                                 bool isBuffered ) const
+{
+    const wxPGProperty* firstItem;
+    const wxPGProperty* lastItem;
+
+    firstItem = DoGetItemAtY(clipRect->y);
+    lastItem = DoGetItemAtY(clipRect->y+clipRect->height-1);
+
+    if ( !lastItem )
+        lastItem = GetLastItem( wxPG_ITERATE_VISIBLE );
+
+    if ( m_frozen || m_height < 1 || firstItem == NULL )
+        return clipRect->y;
+
+    wxCHECK_MSG( !m_pState->m_itemsAdded, clipRect->y, wxT("no items added") );
+    wxASSERT( m_pState->m_properties->GetChildCount() );
+
+    int lh = m_lineHeight;
+
+    int firstItemTopY;
+    int lastItemBottomY;
+
+    firstItemTopY = clipRect->y;
+    lastItemBottomY = clipRect->y + clipRect->height;
+
+    // Align y coordinates to item boundaries
+    firstItemTopY -= firstItemTopY % lh;
+    lastItemBottomY += lh - (lastItemBottomY % lh);
+    lastItemBottomY -= 1;
+
+    // Entire range outside scrolled, visible area?
+    if ( firstItemTopY >= (int)m_pState->GetVirtualHeight() || lastItemBottomY <= 0 )
+        return clipRect->y;
+
+    wxCHECK_MSG( firstItemTopY < lastItemBottomY, clipRect->y, wxT("invalid y values") );
+
+
+    /*
+    wxLogDebug(wxT("  -> DoDrawItems ( \"%s\" -> \"%s\", height=%i (ch=%i), clipRect = 0x%lX )"),
+        firstItem->GetLabel().c_str(),
+        lastItem->GetLabel().c_str(),
+        (int)(lastItemBottomY - firstItemTopY),
+        (int)m_height,
+        (unsigned long)clipRect );
+    */
+
+    wxRect r;
+
+    long windowStyle = m_windowStyle;
+
+    int xRelMod = 0;
+    int yRelMod = 0;
+
+    //
+    // With wxPG_DOUBLE_BUFFER, do double buffering
+    // - buffer's y = 0, so align cliprect and coordinates to that
+    //
+#if wxPG_DOUBLE_BUFFER
+
+    wxRect cr2;
+
+    if ( isBuffered )
+    {
+        xRelMod = clipRect->x;
+        yRelMod = clipRect->y;
+
+        //
+        // clipRect conversion
+        cr2 = *clipRect;
+        cr2.x -= xRelMod;
+        cr2.y -= yRelMod;
+        clipRect = &cr2;
+        firstItemTopY -= yRelMod;
+        lastItemBottomY -= yRelMod;
+    }
+#else
+    wxUnusedVar(isBuffered);
+#endif
+
+    int x = m_marginWidth - xRelMod;
+
+    wxFont normalFont = GetFont();
+
+    bool reallyFocused = (m_iFlags & wxPG_FL_FOCUSED) != 0;
+
+    bool isEnabled = IsEnabled();
+
+    //
+    // Prepare some pens and brushes that are often changed to.
+    //
+
+    wxBrush marginBrush(m_colMargin);
+    wxPen marginPen(m_colMargin);
+    wxBrush capbgbrush(m_colCapBack,wxSOLID);
+    wxPen linepen(m_colLine,1,wxSOLID);
+
+    // pen that has same colour as text
+    wxPen outlinepen(m_colPropFore,1,wxSOLID);
+
+    //
+    // Clear margin with background colour
+    //
+    dc.SetBrush( marginBrush );
+    if ( !(windowStyle & wxPG_HIDE_MARGIN) )
+    {
+        dc.SetPen( *wxTRANSPARENT_PEN );
+        dc.DrawRectangle(-1-xRelMod,firstItemTopY-1,x+2,lastItemBottomY-firstItemTopY+2);
+    }
+
+    const wxPGProperty* selected = m_selected;
+    const wxPropertyGridPageState* state = m_pState;
+
+#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+    bool wasSelectedPainted = false;
+#endif
+
+    // TODO: Only render columns that are within clipping region.
+
+    dc.SetFont(normalFont);
+
+    wxPropertyGridConstIterator it( state, wxPG_ITERATE_VISIBLE, firstItem );
+    int endScanBottomY = lastItemBottomY + lh;
+    int y = firstItemTopY;
+
+    //
+    // Pregenerate list of visible properties.
+    wxArrayPGProperty visPropArray;
+    visPropArray.reserve((m_height/m_lineHeight)+6);
+
+    for ( ; !it.AtEnd(); it.Next() )
+    {
+        const wxPGProperty* p = *it;
+
+        if ( !p->HasFlag(wxPG_PROP_HIDDEN) )
+        {
+            visPropArray.push_back((wxPGProperty*)p);
+
+            if ( y > endScanBottomY )
+                break;
+
+            y += lh;
+        }
+    }
+
+    visPropArray.push_back(NULL);
+
+    wxPGProperty* nextP = visPropArray[0];
+
+    int gridWidth = state->m_width;
+
+    y = firstItemTopY;
+    for ( unsigned int arrInd=1;
+          nextP && y <= lastItemBottomY;
+          arrInd++ )
+    {
+        wxPGProperty* p = nextP;
+        nextP = visPropArray[arrInd];
+
+        int rowHeight = m_fontHeight+(m_spacingy*2)+1;
+        int textMarginHere = x;
+        int renderFlags = 0;
+
+        int greyDepth = m_marginWidth;
+        if ( !(windowStyle & wxPG_HIDE_CATEGORIES) )
+            greyDepth = (((int)p->m_depthBgCol)-1) * m_subgroup_extramargin + m_marginWidth;
+
+        int greyDepthX = greyDepth - xRelMod;
+
+        // Use basic depth if in non-categoric mode and parent is base array.
+        if ( !(windowStyle & wxPG_HIDE_CATEGORIES) || p->GetParent() != m_pState->m_properties )
+        {
+            textMarginHere += ((unsigned int)((p->m_depth-1)*m_subgroup_extramargin));
+        }
+
+        // Paint margin area
+        dc.SetBrush(marginBrush);
+        dc.SetPen(marginPen);
+        dc.DrawRectangle( -xRelMod, y, greyDepth, lh );
+
+        dc.SetPen( linepen );
+
+        int y2 = y + lh;
+
+        // Margin Edge
+        dc.DrawLine( greyDepthX, y, greyDepthX, y2 );
+
+        // Splitters
+        unsigned int si;
+        int sx = x;
+
+        for ( si=0; si<state->m_colWidths.size(); si++ )
+        {
+            sx += state->m_colWidths[si];
+            dc.DrawLine( sx, y, sx, y2 );
+        }
+
+        // Horizontal Line, below
+        //   (not if both this and next is category caption)
+        if ( p->IsCategory() &&
+             nextP && nextP->IsCategory() )
+            dc.SetPen(m_colCapBack);
+
+        dc.DrawLine( greyDepthX, y2-1, gridWidth-xRelMod, y2-1 );
+
+        //
+        // Need to override row colours?
+        wxColour rowFgCol;
+        wxColour rowBgCol;
+
+        if ( p != selected )
+        {
+            // Disabled may get different colour.
+            if ( !p->IsEnabled() )
+            {
+                renderFlags |= wxPGCellRenderer::Disabled |
+                               wxPGCellRenderer::DontUseCellFgCol;
+                rowFgCol = m_colDisPropFore;
+            }
+        }
+        else
+        {
+            renderFlags |= wxPGCellRenderer::Selected;
+
+            if ( !p->IsCategory() )
+            {
+                renderFlags |= wxPGCellRenderer::DontUseCellFgCol |
+                               wxPGCellRenderer::DontUseCellBgCol;
+
+#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+                wasSelectedPainted = true;
+#endif
+
+                // Selected gets different colour.
+                if ( reallyFocused )
+                {
+                    rowFgCol = m_colSelFore;
+                    rowBgCol = m_colSelBack;
+                }
+                else if ( isEnabled )
+                {
+                    rowFgCol = m_colPropFore;
+                    rowBgCol = m_colMargin;
+                }
+                else
+                {
+                    rowFgCol = m_colDisPropFore;
+                    rowBgCol = m_colSelBack;
+                }
+            }
+        }
+
+        wxBrush rowBgBrush;
+
+        if ( rowBgCol.IsOk() )
+            rowBgBrush = wxBrush(rowBgCol);
+
+        if ( HasInternalFlag(wxPG_FL_CELL_OVERRIDES_SEL) )
+            renderFlags = renderFlags & ~wxPGCellRenderer::DontUseCellColours;
+
+        //
+        // Fill additional margin area with background colour of first cell
+        if ( greyDepthX < textMarginHere )
+        {
+            if ( !(renderFlags & wxPGCellRenderer::DontUseCellBgCol) )
+            {
+                wxPGCell& cell = p->GetCell(0);
+                rowBgCol = cell.GetBgCol();
+                rowBgBrush = wxBrush(rowBgCol);
+            }
+            dc.SetBrush(rowBgBrush);
+            dc.SetPen(rowBgCol);
+            dc.DrawRectangle(greyDepthX+1, y,
+                             textMarginHere-greyDepthX, lh-1);
+        }
+
+        bool fontChanged = false;
+
+        // Expander button rectangle
+        wxRect butRect( ((p->m_depth - 1) * m_subgroup_extramargin) - xRelMod,
+                        y,
+                        m_marginWidth,
+                        lh );
+
+        if ( p->IsCategory() )
+        {
+            // Captions have their cell areas merged as one
+            dc.SetFont(m_captionFont);
+            fontChanged = true;
+            wxRect cellRect(greyDepthX, y, gridWidth - greyDepth + 2, rowHeight-1 );
+
+            if ( renderFlags & wxPGCellRenderer::DontUseCellBgCol )
+            {
+                dc.SetBrush(rowBgBrush);
+                dc.SetPen(rowBgCol);
+            }
+
+            if ( renderFlags & wxPGCellRenderer::DontUseCellFgCol )
+            {
+                dc.SetTextForeground(rowFgCol);
+            }
+
+            wxPGCellRenderer* renderer = p->GetCellRenderer(0);
+            renderer->Render( dc, cellRect, this, p, 0, -1, renderFlags );
+
+            // Tree Item Button
+            if ( !HasFlag(wxPG_HIDE_MARGIN) && p->HasVisibleChildren() )
+                DrawExpanderButton( dc, butRect, p );
+        }
+        else
+        {
+            if ( p->m_flags & wxPG_PROP_MODIFIED && (windowStyle & wxPG_BOLD_MODIFIED) )
+            {
+                dc.SetFont(m_captionFont);
+                fontChanged = true;
+            }
+
+            unsigned int ci;
+            int cellX = x + 1;
+            int nextCellWidth = state->m_colWidths[0] -
+                                (greyDepthX - m_marginWidth);
+            wxRect cellRect(greyDepthX+1, y, 0, rowHeight-1);
+            int textXAdd = textMarginHere - greyDepthX;
+
+            for ( ci=0; ci<state->m_colWidths.size(); ci++ )
+            {
+                cellRect.width = nextCellWidth - 1;
+
+                bool ctrlCell = false;
+                int cellRenderFlags = renderFlags;
+
+                // Tree Item Button
+                if ( ci == 0 && !HasFlag(wxPG_HIDE_MARGIN) && p->HasVisibleChildren() )
+                    DrawExpanderButton( dc, butRect, p );
+
+                // Background
+                if ( p == selected && m_wndEditor && ci == 1 )
+                {
+                    wxColour editorBgCol = GetEditorControl()->GetBackgroundColour();
+                    dc.SetBrush(editorBgCol);
+                    dc.SetPen(editorBgCol);
+                    dc.SetTextForeground(m_colPropFore);
+                    dc.DrawRectangle(cellRect);
+
+                    if ( m_dragStatus == 0 && !(m_iFlags & wxPG_FL_CUR_USES_CUSTOM_IMAGE) )
+                        ctrlCell = true;
+                }
+                else
+                {
+                    if ( renderFlags & wxPGCellRenderer::DontUseCellBgCol )
+                    {
+                        dc.SetBrush(rowBgBrush);
+                        dc.SetPen(rowBgCol);
+                    }
+
+                    if ( renderFlags & wxPGCellRenderer::DontUseCellFgCol )
+                    {
+                        dc.SetTextForeground(rowFgCol);
+                    }
+                }
+
+                dc.SetClippingRegion(cellRect);
+
+                cellRect.x += textXAdd;
+                cellRect.width -= textXAdd;
+
+                // Foreground
+                if ( !ctrlCell )
+                {
+                    wxPGCellRenderer* renderer;
+                    int cmnVal = p->GetCommonValue();
+                    if ( cmnVal == -1 || ci != 1 )
+                    {
+                        renderer = p->GetCellRenderer(ci);
+                        renderer->Render( dc, cellRect, this, p, ci, -1,
+                                          cellRenderFlags );
+                    }
+                    else
+                    {
+                        renderer = GetCommonValue(cmnVal)->GetRenderer();
+                        renderer->Render( dc, cellRect, this, p, ci, -1,
+                                          cellRenderFlags );
+                    }
+                }
+
+                cellX += state->m_colWidths[ci];
+                if ( ci < (state->m_colWidths.size()-1) )
+                    nextCellWidth = state->m_colWidths[ci+1];
+                cellRect.x = cellX;
+                dc.DestroyClippingRegion(); // Is this really necessary?
+                textXAdd = 0;
+            }
+        }
+
+        if ( fontChanged )
+            dc.SetFont(normalFont);
+
+        y += rowHeight;
+    }
+
+    // Refresh editor controls (seems not needed on msw)
+    // NOTE: This code is mandatory for GTK!
+#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+    if ( wasSelectedPainted )
+    {
+        if ( m_wndEditor )
+            m_wndEditor->Refresh();
+        if ( m_wndEditor2 )
+            m_wndEditor2->Refresh();
+    }
+#endif
+
+    return y + yRelMod;
+}
+
+// -----------------------------------------------------------------------
+
+wxRect wxPropertyGrid::GetPropertyRect( const wxPGProperty* p1, const wxPGProperty* p2 ) const
+{
+    wxRect r;
+
+    if ( m_width < 10 || m_height < 10 ||
+         !m_pState->m_properties->GetChildCount() ||
+         p1 == NULL )
+        return wxRect(0,0,0,0);
+
+    int vy = 0;
+
+    //
+    // Return rect which encloses the given property range
+
+    int visTop = p1->GetY();
+    int visBottom;
+    if ( p2 )
+        visBottom = p2->GetY() + m_lineHeight;
+    else
+        visBottom = m_height + visTop;
+
+    // If seleced property is inside the range, we'll extend the range to include
+    // control's size.
+    wxPGProperty* selected = m_selected;
+    if ( selected )
+    {
+        int selectedY = selected->GetY();
+        if ( selectedY >= visTop && selectedY < visBottom )
+        {
+            wxWindow* editor = GetEditorControl();
+            if ( editor )
+            {
+                int visBottom2 = selectedY + editor->GetSize().y;
+                if ( visBottom2 > visBottom )
+                    visBottom = visBottom2;
+            }
+        }
+    }
+
+    return wxRect(0,visTop-vy,m_pState->m_width,visBottom-visTop);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::DrawItems( const wxPGProperty* p1, const wxPGProperty* p2 )
+{
+    if ( m_frozen )
+        return;
+
+    if ( m_pState->m_itemsAdded )
+        PrepareAfterItemsAdded();
+
+    wxRect r = GetPropertyRect(p1, p2);
+    if ( r.width > 0 )
+    {
+        m_canvas->RefreshRect(r);
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::RefreshProperty( wxPGProperty* p )
+{
+    if ( p == m_selected )
+        DoSelectProperty(p, wxPG_SEL_FORCE);
+
+    DrawItemAndChildren(p);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::DrawItemAndValueRelated( wxPGProperty* p )
+{
+    if ( m_frozen )
+        return;
+
+    // Draw item, children, and parent too, if it is not category
+    wxPGProperty* parent = p->GetParent();
+
+    while ( parent &&
+            !parent->IsCategory() &&
+            parent->GetParent() )
+    {
+         DrawItem(parent);
+         parent = parent->GetParent();
+    }
+
+    DrawItemAndChildren(p);
+}
+
+void wxPropertyGrid::DrawItemAndChildren( wxPGProperty* p )
+{
+    wxCHECK_RET( p, wxT("invalid property id") );
+
+    // Do not draw if in non-visible page
+    if ( p->GetParentState() != m_pState )
+        return;
+
+    // do not draw a single item if multiple pending
+    if ( m_pState->m_itemsAdded || m_frozen )
+        return;
+
+    // Update child control.
+    if ( m_selected && m_selected->GetParent() == p )
+        RefreshEditor();
+
+    const wxPGProperty* lastDrawn = p->GetLastVisibleSubItem();
+
+    DrawItems(p, lastDrawn);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::Refresh( bool WXUNUSED(eraseBackground),
+                              const wxRect *rect )
+{
+    PrepareAfterItemsAdded();
+
+    wxWindow::Refresh(false);
+    if ( m_canvas )
+        // TODO: Coordinate translation
+        m_canvas->Refresh(false, rect);
+
+#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+    // I think this really helps only GTK+1.2
+    if ( m_wndEditor ) m_wndEditor->Refresh();
+    if ( m_wndEditor2 ) m_wndEditor2->Refresh();
+#endif
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid global operations
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::Clear()
+{
+    m_pState->DoClear();
+
+    m_propHover = NULL;
+
+    m_prevVY = 0;
+
+    RecalculateVirtualSize();
+
+    // Need to clear some area at the end
+    if ( !m_frozen )
+        RefreshRect(wxRect(0, 0, m_width, m_height));
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::EnableCategories( bool enable )
+{
+    ClearSelection(false);
+
+    if ( enable )
+    {
+        //
+        // Enable categories
+        //
+
+        m_windowStyle &= ~(wxPG_HIDE_CATEGORIES);
+    }
+    else
+    {
+        //
+        // Disable categories
+        //
+        m_windowStyle |= wxPG_HIDE_CATEGORIES;
+    }
+
+    if ( !m_pState->EnableCategories(enable) )
+        return false;
+
+    if ( !m_frozen )
+    {
+        if ( m_windowStyle & wxPG_AUTO_SORT )
+        {
+            m_pState->m_itemsAdded = 1; // force
+            PrepareAfterItemsAdded();
+        }
+    }
+    else
+        m_pState->m_itemsAdded = 1;
+
+    // No need for RecalculateVirtualSize() here - it is already called in
+    // wxPropertyGridPageState method above.
+
+    Refresh();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SwitchState( wxPropertyGridPageState* pNewState )
+{
+    wxASSERT( pNewState );
+    wxASSERT( pNewState->GetGrid() );
+
+    if ( pNewState == m_pState )
+        return;
+
+    wxPGProperty* oldSelection = m_selected;
+
+    ClearSelection(false);
+
+    m_pState->m_selected = oldSelection;
+
+    bool orig_mode = m_pState->IsInNonCatMode();
+    bool new_state_mode = pNewState->IsInNonCatMode();
+
+    m_pState = pNewState;
+
+    // Validate width
+    int pgWidth = GetClientSize().x;
+    if ( HasVirtualWidth() )
+    {
+        int minWidth = pgWidth;
+        if ( pNewState->m_width < minWidth )
+        {
+            pNewState->m_width = minWidth;
+            pNewState->CheckColumnWidths();
+        }
+    }
+    else
+    {
+        //
+        // Just in case, fully re-center splitter
+        if ( HasFlag( wxPG_SPLITTER_AUTO_CENTER ) )
+            pNewState->m_fSplitterX = -1.0;
+
+        pNewState->OnClientWidthChange( pgWidth, pgWidth - pNewState->m_width );
+    }
+
+    m_propHover = NULL;
+
+    // If necessary, convert state to correct mode.
+    if ( orig_mode != new_state_mode )
+    {
+        // This should refresh as well.
+        EnableCategories( orig_mode?false:true );
+    }
+    else if ( !m_frozen )
+    {
+        // Refresh, if not frozen.
+        m_pState->PrepareAfterItemsAdded();
+
+        // Reselect
+        if ( m_pState->m_selected )
+            DoSelectProperty( m_pState->m_selected );
+
+        RecalculateVirtualSize(0);
+        Refresh();
+    }
+    else
+        m_pState->m_itemsAdded = 1;
+}
+
+// -----------------------------------------------------------------------
+
+// Call to SetSplitterPosition will always disable splitter auto-centering
+// if parent window is shown.
+void wxPropertyGrid::DoSetSplitterPosition_( int newxpos, bool refresh, int splitterIndex, bool allPages )
+{
+    if ( ( newxpos < wxPG_DRAG_MARGIN ) )
+        return;
+
+    wxPropertyGridPageState* state = m_pState;
+
+    state->DoSetSplitterPosition( newxpos, splitterIndex, allPages );
+
+    if ( refresh )
+    {
+        if ( m_selected )
+            CorrectEditorWidgetSizeX();
+
+        Refresh();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::CenterSplitter( bool enableAutoCentering )
+{
+    SetSplitterPosition( m_width/2, true );
+    if ( enableAutoCentering && ( m_windowStyle & wxPG_SPLITTER_AUTO_CENTER ) )
+        m_iFlags &= ~(wxPG_FL_DONT_CENTER_SPLITTER);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid item iteration (GetNextProperty etc.) methods
+// -----------------------------------------------------------------------
+
+// Returns nearest paint visible property (such that will be painted unless
+// window is scrolled or resized). If given property is paint visible, then
+// it itself will be returned
+wxPGProperty* wxPropertyGrid::GetNearestPaintVisible( wxPGProperty* p ) const
+{
+    int vx,vy1;// Top left corner of client
+    GetViewStart(&vx,&vy1);
+    vy1 *= wxPG_PIXELS_PER_UNIT;
+
+    int vy2 = vy1 + m_height;
+    int propY = p->GetY2(m_lineHeight);
+
+    if ( (propY + m_lineHeight) < vy1 )
+    {
+    // Too high
+        return DoGetItemAtY( vy1 );
+    }
+    else if ( propY > vy2 )
+    {
+    // Too low
+        return DoGetItemAtY( vy2 );
+    }
+
+    // Itself paint visible
+    return p;
+
+}
+
+// -----------------------------------------------------------------------
+// Methods related to change in value, value modification and sending events
+// -----------------------------------------------------------------------
+
+// commits any changes in editor of selected property
+// return true if validation did not fail
+// flags are same as with DoSelectProperty
+bool wxPropertyGrid::CommitChangesFromEditor( wxUint32 flags )
+{
+    // Committing already?
+    if ( m_inCommitChangesFromEditor )
+        return true;
+
+    // Don't do this if already processing editor event. It might
+    // induce recursive dialogs and crap like that.
+    if ( m_iFlags & wxPG_FL_IN_HANDLECUSTOMEDITOREVENT )
+    {
+        if ( m_inDoPropertyChanged )
+            return true;
+
+        return false;
+    }
+
+    if ( m_wndEditor &&
+         IsEditorsValueModified() &&
+         (m_iFlags & wxPG_FL_INITIALIZED) &&
+         m_selected )
+    {
+        m_inCommitChangesFromEditor = 1;
+
+        wxVariant variant(m_selected->GetValueRef());
+        bool valueIsPending = false;
+
+        // JACS - necessary to avoid new focus being found spuriously within OnIdle
+        // due to another window getting focus
+        wxWindow* oldFocus = m_curFocused;
+
+        bool validationFailure = false;
+        bool forceSuccess = (flags & (wxPG_SEL_NOVALIDATE|wxPG_SEL_FORCE)) ? true : false;
+
+        m_chgInfo_changedProperty = NULL;
+
+        // If truly modified, schedule value as pending.
+        if ( m_selected->GetEditorClass()->GetValueFromControl( variant, m_selected, GetEditorControl() ) )
+        {
+            if ( DoEditorValidate() &&
+                 PerformValidation(m_selected, variant) )
+            {
+                valueIsPending = true;
+            }
+            else
+            {
+                validationFailure = true;
+            }
+        }
+        else
+        {
+            EditorsValueWasNotModified();
+        }
+
+        bool res = true;
+
+        m_inCommitChangesFromEditor = 0;
+
+        if ( validationFailure && !forceSuccess )
+        {
+            if (oldFocus)
+            {
+                oldFocus->SetFocus();
+                m_curFocused = oldFocus;
+            }
+
+            res = OnValidationFailure(m_selected, variant);
+
+            // Now prevent further validation failure messages
+            if ( res )
+            {
+                EditorsValueWasNotModified();
+                OnValidationFailureReset(m_selected);
+            }
+        }
+        else if ( valueIsPending )
+        {
+            DoPropertyChanged( m_selected, flags );
+            EditorsValueWasNotModified();
+        }
+
+        return res;
+    }
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::PerformValidation( wxPGProperty* p, wxVariant& pendingValue,
+                                        int flags )
+{
+    //
+    // Runs all validation functionality.
+    // Returns true if value passes all tests.
+    //
+
+    m_validationInfo.m_failureBehavior = m_permanentValidationFailureBehavior;
+
+    if ( pendingValue.GetType() == wxPG_VARIANT_TYPE_LIST )
+    {
+        if ( !p->ValidateValue(pendingValue, m_validationInfo) )
+            return false;
+    }
+
+    //
+    // Adapt list to child values, if necessary
+    wxVariant listValue = pendingValue;
+    wxVariant* pPendingValue = &pendingValue;
+    wxVariant* pList = NULL;
+
+    // If parent has wxPG_PROP_AGGREGATE flag, or uses composite
+    // string value, then we need treat as it was changed instead
+    // (or, in addition, as is the case with composite string parent).
+    // This includes creating list variant for child values.
+
+    wxPGProperty* pwc = p->GetParent();
+    wxPGProperty* changedProperty = p;
+    wxPGProperty* baseChangedProperty = changedProperty;
+    wxVariant bcpPendingList;
+
+    listValue = pendingValue;
+    listValue.SetName(p->GetBaseName());
+
+    while ( pwc &&
+            (pwc->HasFlag(wxPG_PROP_AGGREGATE) || pwc->HasFlag(wxPG_PROP_COMPOSED_VALUE)) )
+    {
+        wxVariantList tempList;
+        wxVariant lv(tempList, pwc->GetBaseName());
+        lv.Append(listValue);
+        listValue = lv;
+        pPendingValue = &listValue;
+
+        if ( pwc->HasFlag(wxPG_PROP_AGGREGATE) )
+        {
+            baseChangedProperty = pwc;
+            bcpPendingList = lv;
+        }
+
+        changedProperty = pwc;
+        pwc = pwc->GetParent();
+    }
+
+    wxVariant value;
+    wxPGProperty* evtChangingProperty = changedProperty;
+
+    if ( pPendingValue->GetType() != wxPG_VARIANT_TYPE_LIST )
+    {
+        value = *pPendingValue;
+    }
+    else
+    {
+        // Convert list to child values
+        pList = pPendingValue;
+        changedProperty->AdaptListToValue( *pPendingValue, &value );
+    }
+
+    wxVariant evtChangingValue = value;
+
+    if ( flags & SendEvtChanging )
+    {
+        // FIXME: After proper ValueToString()s added, remove
+        // this. It is just a temporary fix, as evt_changing
+        // will simply not work for wxPG_PROP_COMPOSED_VALUE
+        // (unless it is selected, and textctrl editor is open).
+        if ( changedProperty->HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+        {
+            evtChangingProperty = baseChangedProperty;
+            if ( evtChangingProperty != p )
+            {
+                evtChangingProperty->AdaptListToValue( bcpPendingList, &evtChangingValue );
+            }
+            else
+            {
+                evtChangingValue = pendingValue;
+            }
+        }
+
+        if ( evtChangingProperty->HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+        {
+            if ( changedProperty == m_selected )
+            {
+                wxWindow* editor = GetEditorControl();
+                wxASSERT( editor->IsKindOf(CLASSINFO(wxTextCtrl)) );
+                evtChangingValue = wxStaticCast(editor, wxTextCtrl)->GetValue();
+            }
+            else
+            {
+                wxLogDebug(wxT("WARNING: wxEVT_PG_CHANGING is about to happen with old value."));
+            }
+        }
+    }
+
+    wxASSERT( m_chgInfo_changedProperty == NULL );
+    m_chgInfo_changedProperty = changedProperty;
+    m_chgInfo_baseChangedProperty = baseChangedProperty;
+    m_chgInfo_pendingValue = value;
+
+    if ( pList )
+        m_chgInfo_valueList = *pList;
+    else
+        m_chgInfo_valueList.MakeNull();
+
+    // If changedProperty is not property which value was edited,
+    // then call wxPGProperty::ValidateValue() for that as well.
+    if ( p != changedProperty && value.GetType() != wxPG_VARIANT_TYPE_LIST )
+    {
+        if ( !changedProperty->ValidateValue(value, m_validationInfo) )
+            return false;
+    }
+
+    if ( flags & SendEvtChanging )
+    {
+        // SendEvent returns true if event was vetoed
+        if ( SendEvent( wxEVT_PG_CHANGING, evtChangingProperty, &evtChangingValue, 0 ) )
+            return false;
+    }
+
+    if ( flags & IsStandaloneValidation )
+    {
+        // If called in 'generic' context, we need to reset
+        // m_chgInfo_changedProperty and write back translated value.
+        m_chgInfo_changedProperty = NULL;
+        pendingValue = value;
+    }
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::DoShowPropertyError( wxPGProperty* WXUNUSED(property), const wxString& msg )
+{
+    if ( !msg.length() )
+        return;
+
+#if wxUSE_STATUSBAR
+    if ( !wxPGGlobalVars->m_offline )
+    {
+        wxWindow* topWnd = ::wxGetTopLevelParent(this);
+        if ( topWnd )
+        {
+            wxFrame* pFrame = wxDynamicCast(topWnd, wxFrame);
+            if ( pFrame )
+            {
+                wxStatusBar* pStatusBar = pFrame->GetStatusBar();
+                if ( pStatusBar )
+                {
+                    pStatusBar->SetStatusText(msg);
+                    return;
+                }
+            }
+        }
+    }
+#endif
+
+    ::wxMessageBox(msg, _T("Property Error"));
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::OnValidationFailure( wxPGProperty* property,
+                                          wxVariant& invalidValue )
+{
+    wxWindow* editor = GetEditorControl();
+
+    // First call property's handler
+    property->OnValidationFailure(invalidValue);
+
+    bool res = DoOnValidationFailure(property, invalidValue);
+
+    //
+    // For non-wxTextCtrl editors, we do need to revert the value
+    if ( !editor->IsKindOf(CLASSINFO(wxTextCtrl)) &&
+         property == m_selected )
+    {
+        property->GetEditorClass()->UpdateControl(property, editor);
+    }
+
+    property->SetFlag(wxPG_PROP_INVALID_VALUE);
+
+    return res;
+}
+
+bool wxPropertyGrid::DoOnValidationFailure( wxPGProperty* property, wxVariant& WXUNUSED(invalidValue) )
+{
+    int vfb = m_validationInfo.m_failureBehavior;
+
+    if ( vfb & wxPG_VFB_BEEP )
+        ::wxBell();
+
+    if ( (vfb & wxPG_VFB_MARK_CELL) &&
+         !property->HasFlag(wxPG_PROP_INVALID_VALUE) )
+    {
+        unsigned int colCount = m_pState->GetColumnCount();
+
+        // We need backup marked property's cells
+        m_propCellsBackup = property->m_cells;
+
+        wxColour vfbFg = *wxWHITE;
+        wxColour vfbBg = *wxRED;
+
+        property->EnsureCells(colCount);
+
+        for ( unsigned int i=0; i<colCount; i++ )
+        {
+            wxPGCell& cell = property->m_cells[i];
+            cell.SetFgCol(vfbFg);
+            cell.SetBgCol(vfbBg);
+        }
+
+        DrawItemAndChildren(property);
+
+        if ( property == m_selected )
+        {
+            SetInternalFlag(wxPG_FL_CELL_OVERRIDES_SEL);
+
+            wxWindow* editor = GetEditorControl();
+            if ( editor )
+            {
+                editor->SetForegroundColour(vfbFg);
+                editor->SetBackgroundColour(vfbBg);
+            }
+        }
+    }
+
+    if ( vfb & wxPG_VFB_SHOW_MESSAGE )
+    {
+        wxString msg = m_validationInfo.m_failureMessage;
+
+        if ( !msg.length() )
+            msg = _T("You have entered invalid value. Press ESC to cancel editing.");
+
+        DoShowPropertyError(property, msg);
+    }
+
+    return (vfb & wxPG_VFB_STAY_IN_PROPERTY) ? false : true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::DoOnValidationFailureReset( wxPGProperty* property )
+{
+    int vfb = m_validationInfo.m_failureBehavior;
+
+    if ( vfb & wxPG_VFB_MARK_CELL )
+    {
+        // Revert cells
+        property->m_cells = m_propCellsBackup;
+
+        ClearInternalFlag(wxPG_FL_CELL_OVERRIDES_SEL);
+
+        if ( property == m_selected && GetEditorControl() )
+        {
+            // Calling this will recreate the control, thus resetting its colour
+            RefreshProperty(property);
+        }
+        else
+        {
+            DrawItemAndChildren(property);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+// flags are same as with DoSelectProperty
+bool wxPropertyGrid::DoPropertyChanged( wxPGProperty* p, unsigned int selFlags )
+{
+    if ( m_inDoPropertyChanged )
+        return true;
+
+    wxWindow* editor = GetEditorControl();
+
+    m_pState->m_anyModified = 1;
+
+    m_inDoPropertyChanged = 1;
+
+    // Maybe need to update control
+    wxASSERT( m_chgInfo_changedProperty != NULL );
+
+    // These values were calculated in PerformValidation()
+    wxPGProperty* changedProperty = m_chgInfo_changedProperty;
+    wxVariant value = m_chgInfo_pendingValue;
+
+    wxPGProperty* topPaintedProperty = changedProperty;
+
+    while ( !topPaintedProperty->IsCategory() &&
+            !topPaintedProperty->IsRoot() )
+    {
+        topPaintedProperty = topPaintedProperty->GetParent();
+    }
+
+    changedProperty->SetValue(value, &m_chgInfo_valueList, wxPG_SETVAL_BY_USER);
+
+    // Set as Modified (not if dragging just began)
+    if ( !(p->m_flags & wxPG_PROP_MODIFIED) )
+    {
+        p->m_flags |= wxPG_PROP_MODIFIED;
+        if ( p == m_selected && (m_windowStyle & wxPG_BOLD_MODIFIED) )
+        {
+            if ( editor )
+                SetCurControlBoldFont();
+        }
+    }
+
+    wxPGProperty* pwc;
+
+    // Propagate updates to parent(s)
+    pwc = p;
+    wxPGProperty* prevPwc = NULL;
+
+    while ( prevPwc != topPaintedProperty )
+    {
+        pwc->m_flags |= wxPG_PROP_MODIFIED;
+
+        if ( pwc == m_selected && (m_windowStyle & wxPG_BOLD_MODIFIED) )
+        {
+            if ( editor )
+                SetCurControlBoldFont();
+        }
+
+        prevPwc = pwc;
+        pwc = pwc->GetParent();
+    }
+
+    // Draw the actual property
+    DrawItemAndChildren( topPaintedProperty );
+
+    //
+    // If value was set by wxPGProperty::OnEvent, then update the editor
+    // control.
+    if ( selFlags & wxPG_SEL_DIALOGVAL )
+    {
+        RefreshEditor();
+    }
+    else
+    {
+#if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+        if ( m_wndEditor ) m_wndEditor->Refresh();
+        if ( m_wndEditor2 ) m_wndEditor2->Refresh();
+#endif
+    }
+
+    // Sanity check
+    wxASSERT( !changedProperty->GetParent()->HasFlag(wxPG_PROP_AGGREGATE) );
+
+    // If top parent has composite string value, then send to child parents,
+    // starting from baseChangedProperty.
+    if ( changedProperty->HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+    {
+        pwc = m_chgInfo_baseChangedProperty;
+
+        while ( pwc != changedProperty )
+        {
+            SendEvent( wxEVT_PG_CHANGED, pwc, NULL, selFlags );
+            pwc = pwc->GetParent();
+        }
+    }
+
+    SendEvent( wxEVT_PG_CHANGED, changedProperty, NULL, selFlags );
+
+    m_inDoPropertyChanged = 0;
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::ChangePropertyValue( wxPGPropArg id, wxVariant newValue )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+
+    m_chgInfo_changedProperty = NULL;
+
+    if ( PerformValidation(p, newValue) )
+    {
+        DoPropertyChanged(p);
+        return true;
+    }
+    else
+    {
+        OnValidationFailure(p, newValue);
+    }
+
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+wxVariant wxPropertyGrid::GetUncommittedPropertyValue()
+{
+    wxPGProperty* prop = GetSelectedProperty();
+
+    if ( !prop )
+        return wxNullVariant;
+
+    wxTextCtrl* tc = GetEditorTextCtrl();
+    wxVariant value = prop->GetValue();
+
+    if ( !tc || !IsEditorsValueModified() )
+        return value;
+
+    if ( !prop->StringToValue(value, tc->GetValue()) )
+        return value;
+
+    if ( !PerformValidation(prop, value, IsStandaloneValidation) )
+        return prop->GetValue();
+
+    return value;
+}
+
+// -----------------------------------------------------------------------
+
+// Runs wxValidator for the selected property
+bool wxPropertyGrid::DoEditorValidate()
+{
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::HandleCustomEditorEvent( wxEvent &event )
+{
+    wxPGProperty* selected = m_selected;
+
+    // Somehow, event is handled after property has been deselected.
+    // Possibly, but very rare.
+    if ( !selected )
+        return;
+
+    if ( m_iFlags & wxPG_FL_IN_HANDLECUSTOMEDITOREVENT )
+        return;
+
+    wxVariant pendingValue(selected->GetValueRef());
+    wxWindow* wnd = GetEditorControl();
+    wxWindow* editorWnd = wxDynamicCast(event.GetEventObject(), wxWindow);
+    int selFlags = 0;
+    bool wasUnspecified = selected->IsValueUnspecified();
+    int usesAutoUnspecified = selected->UsesAutoUnspecified();
+    bool valueIsPending = false;
+
+    m_chgInfo_changedProperty = NULL;
+
+    m_iFlags &= ~(wxPG_FL_VALIDATION_FAILED|wxPG_FL_VALUE_CHANGE_IN_EVENT);
+
+    //
+    // Filter out excess wxTextCtrl modified events
+    if ( event.GetEventType() == wxEVT_COMMAND_TEXT_UPDATED &&
+         wnd &&
+         wnd->IsKindOf(CLASSINFO(wxTextCtrl)) )
+    {
+        wxTextCtrl* tc = (wxTextCtrl*) wnd;
+
+        wxString newTcValue = tc->GetValue();
+        if ( m_prevTcValue == newTcValue )
+            return;
+
+        m_prevTcValue = newTcValue;
+    }
+
+    SetInternalFlag(wxPG_FL_IN_HANDLECUSTOMEDITOREVENT);
+
+    bool validationFailure = false;
+    bool buttonWasHandled = false;
+
+    //
+    // Try common button handling
+    if ( m_wndEditor2 && event.GetEventType() == wxEVT_COMMAND_BUTTON_CLICKED )
+    {
+        wxPGEditorDialogAdapter* adapter = selected->GetEditorDialog();
+
+        if ( adapter )
+        {
+            buttonWasHandled = true;
+            // Store as res2, as previously (and still currently alternatively)
+            // dialogs can be shown by handling wxEVT_COMMAND_BUTTON_CLICKED
+            // in wxPGProperty::OnEvent().
+            adapter->ShowDialog( this, selected );
+            delete adapter;
+        }
+    }
+
+    if ( !buttonWasHandled )
+    {
+        if ( wnd || m_wndEditor2 )
+        {
+            // First call editor class' event handler.
+            const wxPGEditor* editor = selected->GetEditorClass();
+
+            if ( editor->OnEvent( this, selected, editorWnd, event ) )
+            {
+                // If changes, validate them
+                if ( DoEditorValidate() )
+                {
+                    if ( editor->GetValueFromControl( pendingValue,
+                                                      m_selected,
+                                                      wnd ) )
+                        valueIsPending = true;
+                }
+                else
+                {
+                    validationFailure = true;
+                }
+            }
+        }
+
+        // Then the property's custom handler (must be always called, unless
+        // validation failed).
+        if ( !validationFailure )
+            buttonWasHandled = selected->OnEvent( this, editorWnd, event );
+    }
+
+    // SetValueInEvent(), as called in one of the functions referred above
+    // overrides editor's value.
+    if ( m_iFlags & wxPG_FL_VALUE_CHANGE_IN_EVENT )
+    {
+        valueIsPending = true;
+        pendingValue = m_changeInEventValue;
+        selFlags |= wxPG_SEL_DIALOGVAL;
+    }
+
+    if ( !validationFailure && valueIsPending )
+        if ( !PerformValidation(m_selected, pendingValue) )
+            validationFailure = true;
+
+    if ( validationFailure)
+    {
+        OnValidationFailure(selected, pendingValue);
+    }
+    else if ( valueIsPending )
+    {
+        selFlags |= ( !wasUnspecified && selected->IsValueUnspecified() && usesAutoUnspecified ) ? wxPG_SEL_SETUNSPEC : 0;
+
+        DoPropertyChanged(selected, selFlags);
+        EditorsValueWasNotModified();
+
+        // Regardless of editor type, unfocus editor on
+        // text-editing related enter press.
+        if ( event.GetEventType() == wxEVT_COMMAND_TEXT_ENTER )
+        {
+            SetFocusOnCanvas();
+        }
+    }
+    else
+    {
+        // No value after all
+
+        // Regardless of editor type, unfocus editor on
+        // text-editing related enter press.
+        if ( event.GetEventType() == wxEVT_COMMAND_TEXT_ENTER )
+        {
+            SetFocusOnCanvas();
+        }
+
+        // Let unhandled button click events go to the parent
+        if ( !buttonWasHandled && event.GetEventType() == wxEVT_COMMAND_BUTTON_CLICKED )
+        {
+            wxCommandEvent evt(wxEVT_COMMAND_BUTTON_CLICKED,GetId());
+            GetEventHandler()->AddPendingEvent(evt);
+        }
+    }
+
+    ClearInternalFlag(wxPG_FL_IN_HANDLECUSTOMEDITOREVENT);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid editor control helper methods
+// -----------------------------------------------------------------------
+
+wxRect wxPropertyGrid::GetEditorWidgetRect( wxPGProperty* p, int column ) const
+{
+    int itemy = p->GetY2(m_lineHeight);
+    int vy = 0;
+    int splitterX = m_pState->DoGetSplitterPosition(column-1);
+    int colEnd = splitterX + m_pState->m_colWidths[column];
+    int imageOffset = 0;
+
+    // TODO: If custom image detection changes from current, change this.
+    if ( m_iFlags & wxPG_FL_CUR_USES_CUSTOM_IMAGE )
+    {
+        //m_iFlags |= wxPG_FL_CUR_USES_CUSTOM_IMAGE;
+        int iw = p->OnMeasureImage().x;
+        if ( iw < 1 )
+            iw = wxPG_CUSTOM_IMAGE_WIDTH;
+        imageOffset = p->GetImageOffset(iw);
+    }
+
+    return wxRect
+      (
+        splitterX+imageOffset+wxPG_XBEFOREWIDGET+wxPG_CONTROL_MARGIN+1,
+        itemy-vy,
+        colEnd-splitterX-wxPG_XBEFOREWIDGET-wxPG_CONTROL_MARGIN-imageOffset-1,
+        m_lineHeight-1
+      );
+}
+
+// -----------------------------------------------------------------------
+
+wxRect wxPropertyGrid::GetImageRect( wxPGProperty* p, int item ) const
+{
+    wxSize sz = GetImageSize(p, item);
+    return wxRect(wxPG_CONTROL_MARGIN + wxCC_CUSTOM_IMAGE_MARGIN1,
+                  wxPG_CUSTOM_IMAGE_SPACINGY,
+                  sz.x,
+                  sz.y);
+}
+
+// return size of custom paint image
+wxSize wxPropertyGrid::GetImageSize( wxPGProperty* p, int item ) const
+{
+    // If called with NULL property, then return default image
+    // size for properties that use image.
+    if ( !p )
+        return wxSize(wxPG_CUSTOM_IMAGE_WIDTH,wxPG_STD_CUST_IMAGE_HEIGHT(m_lineHeight));
+
+    wxSize cis = p->OnMeasureImage(item);
+
+    int choiceCount = p->m_choices.GetCount();
+    int comVals = p->GetDisplayedCommonValueCount();
+    if ( item >= choiceCount && comVals > 0 )
+    {
+        unsigned int cvi = item-choiceCount;
+        cis = GetCommonValue(cvi)->GetRenderer()->GetImageSize(NULL, 1, cvi);
+    }
+    else if ( item >= 0 && choiceCount == 0 )
+        return wxSize(0, 0);
+
+    if ( cis.x < 0 )
+    {
+        if ( cis.x <= -1 )
+            cis.x = wxPG_CUSTOM_IMAGE_WIDTH;
+    }
+    if ( cis.y <= 0 )
+    {
+        if ( cis.y >= -1 )
+            cis.y = wxPG_STD_CUST_IMAGE_HEIGHT(m_lineHeight);
+        else
+            cis.y = -cis.y;
+    }
+    return cis;
+}
+
+// -----------------------------------------------------------------------
+
+// takes scrolling into account
+void wxPropertyGrid::ImprovedClientToScreen( int* px, int* py )
+{
+    int vx, vy;
+    GetViewStart(&vx,&vy);
+    vy*=wxPG_PIXELS_PER_UNIT;
+    vx*=wxPG_PIXELS_PER_UNIT;
+    *px -= vx;
+    *py -= vy;
+    ClientToScreen( px, py );
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridHitTestResult wxPropertyGrid::HitTest( const wxPoint& pt ) const
+{
+    wxPoint pt2;
+    GetViewStart(&pt2.x,&pt2.y);
+    pt2.x *= wxPG_PIXELS_PER_UNIT;
+    pt2.y *= wxPG_PIXELS_PER_UNIT;
+    pt2.x += pt.x;
+    pt2.y += pt.y;
+
+    return m_pState->HitTest(pt2);
+}
+
+// -----------------------------------------------------------------------
+
+// custom set cursor
+void wxPropertyGrid::CustomSetCursor( int type, bool override )
+{
+    if ( type == m_curcursor && !override ) return;
+
+    wxCursor* cursor = &wxPG_DEFAULT_CURSOR;
+
+    if ( type == wxCURSOR_SIZEWE )
+        cursor = m_cursorSizeWE;
+
+    m_canvas->SetCursor( *cursor );
+
+    m_curcursor = type;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid property selection, editor creation
+// -----------------------------------------------------------------------
+
+//
+// This class forwards events from property editor controls to wxPropertyGrid.
+class wxPropertyGridEditorEventForwarder : public wxEvtHandler
+{
+public:
+    wxPropertyGridEditorEventForwarder( wxPropertyGrid* propGrid )
+        : wxEvtHandler(), m_propGrid(propGrid)
+    {
+    }
+
+    virtual ~wxPropertyGridEditorEventForwarder()
+    {
+    }
+
+private:
+    bool ProcessEvent( wxEvent& event )
+    {
+        // Always skip
+        event.Skip();
+
+        m_propGrid->HandleCustomEditorEvent(event);
+
+        return wxEvtHandler::ProcessEvent(event);
+    }
+
+    wxPropertyGrid*         m_propGrid;
+};
+
+// Setups event handling for child control
+void wxPropertyGrid::SetupChildEventHandling( wxWindow* argWnd )
+{
+    wxWindowID id = argWnd->GetId();
+
+    if ( argWnd == m_wndEditor )
+    {
+        argWnd->Connect(id, wxEVT_MOTION,
+            wxMouseEventHandler(wxPropertyGrid::OnMouseMoveChild),
+            NULL, this);
+        argWnd->Connect(id, wxEVT_LEFT_UP,
+            wxMouseEventHandler(wxPropertyGrid::OnMouseUpChild),
+            NULL, this);
+        argWnd->Connect(id, wxEVT_LEFT_DOWN,
+            wxMouseEventHandler(wxPropertyGrid::OnMouseClickChild),
+            NULL, this);
+        argWnd->Connect(id, wxEVT_RIGHT_UP,
+            wxMouseEventHandler(wxPropertyGrid::OnMouseRightClickChild),
+            NULL, this);
+        argWnd->Connect(id, wxEVT_ENTER_WINDOW,
+            wxMouseEventHandler(wxPropertyGrid::OnMouseEntry),
+            NULL, this);
+        argWnd->Connect(id, wxEVT_LEAVE_WINDOW,
+            wxMouseEventHandler(wxPropertyGrid::OnMouseEntry),
+            NULL, this);
+    }
+
+    wxPropertyGridEditorEventForwarder* forwarder;
+    forwarder = new wxPropertyGridEditorEventForwarder(this);
+    argWnd->PushEventHandler(forwarder);
+
+    argWnd->Connect(id, wxEVT_KEY_DOWN,
+        wxCharEventHandler(wxPropertyGrid::OnChildKeyDown),
+        NULL, this);
+}
+
+void wxPropertyGrid::FreeEditors()
+{
+    //
+    // Return focus back to canvas from children (this is required at least for
+    // GTK+, which, unlike Windows, clears focus when control is destroyed
+    // instead of moving it to closest parent).
+    wxWindow* focus = wxWindow::FindFocus();
+    if ( focus )
+    {
+        wxWindow* parent = focus->GetParent();
+        while ( parent )
+        {
+            if ( parent == m_canvas )
+            {
+                SetFocusOnCanvas();
+                break;
+            }
+            parent = parent->GetParent();
+        }
+    }
+
+    // Do not free editors immediately if processing events
+    if ( m_wndEditor2 )
+    {
+        wxEvtHandler* handler = m_wndEditor2->PopEventHandler(false);
+        m_wndEditor2->Hide();
+        wxPendingDelete.Append( handler );
+        wxPendingDelete.Append( m_wndEditor2 );
+        m_wndEditor2 = NULL;
+    }
+
+    if ( m_wndEditor )
+    {
+        wxEvtHandler* handler = m_wndEditor->PopEventHandler(false);
+        m_wndEditor->Hide();
+        wxPendingDelete.Append( handler );
+        wxPendingDelete.Append( m_wndEditor );
+        m_wndEditor = NULL;
+    }
+}
+
+// Call with NULL to de-select property
+bool wxPropertyGrid::DoSelectProperty( wxPGProperty* p, unsigned int flags )
+{
+    /*
+    if (p)
+        wxLogDebug(wxT("SelectProperty( %s (%s[%i]) )"),p->m_label.c_str(),
+            p->m_parent->m_label.c_str(),p->GetIndexInParent());
+    else
+        wxLogDebug(wxT("SelectProperty( NULL, -1 )"));
+    */
+
+    if ( m_inDoSelectProperty )
+        return true;
+
+    m_inDoSelectProperty = 1;
+
+    wxPGProperty* prev = m_selected;
+
+    if ( !m_pState )
+    {
+        m_inDoSelectProperty = 0;
+        return false;
+    }
+
+/*
+    if (m_selected)
+        wxPrintf( "Selected %s\n", m_selected->GetClassInfo()->GetClassName() );
+    else
+        wxPrintf( "None selected\n" );
+
+    if (p)
+        wxPrintf( "P =  %s\n", p->GetClassInfo()->GetClassName() );
+    else
+        wxPrintf( "P = NULL\n" );
+*/
+
+    // If we are frozen, then just set the values.
+    if ( m_frozen )
+    {
+        m_iFlags &= ~(wxPG_FL_ABNORMAL_EDITOR);
+        m_editorFocused = 0;
+        m_selected = p;
+        m_selColumn = 1;
+        m_pState->m_selected = p;
+
+        // If frozen, always free controls. But don't worry, as Thaw will
+        // recall SelectProperty to recreate them.
+        FreeEditors();
+
+        // Prevent any further selection measures in this call
+        p = NULL;
+    }
+    else
+    {
+        // Is it the same?
+        if ( m_selected == p && !(flags & wxPG_SEL_FORCE) )
+        {
+            // Only set focus if not deselecting
+            if ( p )
+            {
+                if ( flags & wxPG_SEL_FOCUS )
+                {
+                    if ( m_wndEditor )
+                    {
+                        m_wndEditor->SetFocus();
+                        m_editorFocused = 1;
+                    }
+                }
+                else
+                {
+                    SetFocusOnCanvas();
+                }
+            }
+
+            m_inDoSelectProperty = 0;
+            return true;
+        }
+
+        //
+        // First, deactivate previous
+        if ( m_selected )
+        {
+
+            OnValidationFailureReset(m_selected);
+
+            // Must double-check if this is an selected in case of forceswitch
+            if ( p != prev )
+            {
+                if ( !CommitChangesFromEditor(flags) )
+                {
+                    // Validation has failed, so we can't exit the previous editor
+                    //::wxMessageBox(_("Please correct the value or press ESC to cancel the edit."),
+                    //               _("Invalid Value"),wxOK|wxICON_ERROR);
+                    m_inDoSelectProperty = 0;
+                    return false;
+                }
+            }
+
+            FreeEditors();
+            m_selColumn = -1;
+
+            m_selected = NULL;
+            m_pState->m_selected = NULL;
+
+            // We need to always fully refresh the grid here
+            Refresh(false);
+
+            m_iFlags &= ~(wxPG_FL_ABNORMAL_EDITOR);
+            EditorsValueWasNotModified();
+        }
+
+        SetInternalFlag(wxPG_FL_IN_SELECT_PROPERTY);
+
+        //
+        // Then, activate the one given.
+        if ( p )
+        {
+            int propY = p->GetY2(m_lineHeight);
+
+            int splitterX = GetSplitterPosition();
+            m_editorFocused = 0;
+            m_selected = p;
+            m_pState->m_selected = p;
+            m_iFlags |= wxPG_FL_PRIMARY_FILLS_ENTIRE;
+            if ( p != prev )
+                m_iFlags &= ~(wxPG_FL_VALIDATION_FAILED);
+
+            wxASSERT( m_wndEditor == NULL );
+
+            //
+            // Only create editor for non-disabled non-caption
+            if ( !p->IsCategory() && !(p->m_flags & wxPG_PROP_DISABLED) )
+            {
+            // do this for non-caption items
+
+                m_selColumn = 1;
+
+                // Do we need to paint the custom image, if any?
+                m_iFlags &= ~(wxPG_FL_CUR_USES_CUSTOM_IMAGE);
+                if ( (p->m_flags & wxPG_PROP_CUSTOMIMAGE) &&
+                     !p->GetEditorClass()->CanContainCustomImage()
+                   )
+                    m_iFlags |= wxPG_FL_CUR_USES_CUSTOM_IMAGE;
+
+                wxRect grect = GetEditorWidgetRect(p, m_selColumn);
+                wxPoint goodPos = grect.GetPosition();
+            #if wxPG_CREATE_CONTROLS_HIDDEN
+                int coord_adjust = m_height - goodPos.y;
+                goodPos.y += coord_adjust;
+            #endif
+
+                const wxPGEditor* editor = p->GetEditorClass();
+                wxCHECK_MSG(editor, false,
+                    wxT("NULL editor class not allowed"));
+
+                m_iFlags &= ~wxPG_FL_FIXED_WIDTH_EDITOR;
+
+                wxPGWindowList wndList = editor->CreateControls(this,
+                                                                p,
+                                                                goodPos,
+                                                                grect.GetSize());
+
+                m_wndEditor = wndList.m_primary;
+                m_wndEditor2 = wndList.m_secondary;
+                wxWindow* primaryCtrl = GetEditorControl();
+
+                //
+                // Essentially, primaryCtrl == m_wndEditor
+                //
+
+                // NOTE: It is allowed for m_wndEditor to be NULL - in this case
+                //       value is drawn as normal, and m_wndEditor2 is assumed
+                //       to be a right-aligned button that triggers a separate editorCtrl
+                //       window.
+
+                if ( m_wndEditor )
+                {
+                    wxASSERT_MSG( m_wndEditor->GetParent() == GetPanel(),
+                                  wxT("CreateControls must use result of wxPropertyGrid::GetPanel() as parent of controls.") );
+
+                    // Set validator, if any
+                #if wxUSE_VALIDATORS
+                    wxValidator* validator = p->GetValidator();
+                    if ( validator )
+                        primaryCtrl->SetValidator(*validator);
+                #endif
+
+                    if ( m_wndEditor->GetSize().y > (m_lineHeight+6) )
+                        m_iFlags |= wxPG_FL_ABNORMAL_EDITOR;
+
+                    // If it has modified status, use bold font
+                    // (must be done before capturing m_ctrlXAdjust)
+                    if ( (p->m_flags & wxPG_PROP_MODIFIED) && (m_windowStyle & wxPG_BOLD_MODIFIED) )
+                        SetCurControlBoldFont();
+
+                    //
+                    // Fix TextCtrl indentation
+                #if defined(__WXMSW__) && !defined(__WXWINCE__)
+                    wxTextCtrl* tc = NULL;
+                    if ( primaryCtrl->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)) )
+                        tc = ((wxOwnerDrawnComboBox*)primaryCtrl)->GetTextCtrl();
+                    else
+                        tc = wxDynamicCast(primaryCtrl, wxTextCtrl);
+                    if ( tc )
+                        ::SendMessage(GetHwndOf(tc), EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELONG(0, 0));
+                #endif
+
+                    // Store x relative to splitter (we'll need it).
+                    m_ctrlXAdjust = m_wndEditor->GetPosition().x - splitterX;
+
+                    // Check if background clear is not necessary
+                    wxPoint pos = m_wndEditor->GetPosition();
+                    if ( pos.x > (splitterX+1) || pos.y > propY )
+                    {
+                        m_iFlags &= ~(wxPG_FL_PRIMARY_FILLS_ENTIRE);
+                    }
+
+                    m_wndEditor->SetSizeHints(3, 3);
+
+                #if wxPG_CREATE_CONTROLS_HIDDEN
+                    m_wndEditor->Show(false);
+                    m_wndEditor->Freeze();
+
+                    goodPos = m_wndEditor->GetPosition();
+                    goodPos.y -= coord_adjust;
+                    m_wndEditor->Move( goodPos );
+                #endif
+
+                    SetupChildEventHandling(primaryCtrl);
+
+                    // Focus and select all (wxTextCtrl, wxComboBox etc)
+                    if ( flags & wxPG_SEL_FOCUS )
+                    {
+                        primaryCtrl->SetFocus();
+
+                        p->GetEditorClass()->OnFocus(p, primaryCtrl);
+                    }
+                }
+
+                if ( m_wndEditor2 )
+                {
+                    wxASSERT_MSG( m_wndEditor2->GetParent() == GetPanel(),
+                                  wxT("CreateControls must use result of wxPropertyGrid::GetPanel() as parent of controls.") );
+
+                    // Get proper id for wndSecondary
+                    m_wndSecId = m_wndEditor2->GetId();
+                    wxWindowList children = m_wndEditor2->GetChildren();
+                    wxWindowList::iterator node = children.begin();
+                    if ( node != children.end() )
+                        m_wndSecId = ((wxWindow*)*node)->GetId();
+
+                    m_wndEditor2->SetSizeHints(3,3);
+
+                #if wxPG_CREATE_CONTROLS_HIDDEN
+                    wxRect sec_rect = m_wndEditor2->GetRect();
+                    sec_rect.y -= coord_adjust;
+
+                    // Fine tuning required to fix "oversized"
+                    // button disappearance bug.
+                    if ( sec_rect.y < 0 )
+                    {
+                        sec_rect.height += sec_rect.y;
+                        sec_rect.y = 0;
+                    }
+                    m_wndEditor2->SetSize( sec_rect );
+                #endif
+                    m_wndEditor2->Show();
+
+                    SetupChildEventHandling(m_wndEditor2);
+
+                    // If no primary editor, focus to button to allow
+                    // it to interprete ENTER etc.
+                    // NOTE: Due to problems focusing away from it, this
+                    //       has been disabled.
+                    /*
+                    if ( (flags & wxPG_SEL_FOCUS) && !m_wndEditor )
+                        m_wndEditor2->SetFocus();
+                    */
+                }
+
+                if ( flags & wxPG_SEL_FOCUS )
+                    m_editorFocused = 1;
+
+            }
+            else
+            {
+                // Make sure focus is in grid canvas (important for wxGTK, at least)
+                SetFocusOnCanvas();
+            }
+
+            EditorsValueWasNotModified();
+
+            // If it's inside collapsed section, expand parent, scroll, etc.
+            // Also, if it was partially visible, scroll it into view.
+            if ( !(flags & wxPG_SEL_NONVISIBLE) )
+                EnsureVisible( p );
+
+            if ( m_wndEditor )
+            {
+            #if wxPG_CREATE_CONTROLS_HIDDEN
+                m_wndEditor->Thaw();
+            #endif
+                m_wndEditor->Show(true);
+            }
+
+            DrawItems(p, p);
+        }
+        else
+        {
+            // Make sure focus is in grid canvas
+            SetFocusOnCanvas();
+        }
+
+        ClearInternalFlag(wxPG_FL_IN_SELECT_PROPERTY);
+    }
+
+#if wxUSE_STATUSBAR
+
+    //
+    // Show help text in status bar.
+    //   (if found and grid not embedded in manager with help box and
+    //    style wxPG_EX_HELP_AS_TOOLTIPS is not used).
+    //
+
+    if ( !(GetExtraStyle() & wxPG_EX_HELP_AS_TOOLTIPS) )
+    {
+        wxStatusBar* statusbar = NULL;
+        if ( !(m_iFlags & wxPG_FL_NOSTATUSBARHELP) )
+        {
+            wxFrame* frame = wxDynamicCast(::wxGetTopLevelParent(this),wxFrame);
+            if ( frame )
+                statusbar = frame->GetStatusBar();
+        }
+
+        if ( statusbar )
+        {
+            const wxString* pHelpString = (const wxString*) NULL;
+
+            if ( p )
+            {
+                pHelpString = &p->GetHelpString();
+                if ( pHelpString->length() )
+                {
+                    // Set help box text.
+                    statusbar->SetStatusText( *pHelpString );
+                    m_iFlags |= wxPG_FL_STRING_IN_STATUSBAR;
+                }
+            }
+
+            if ( (!pHelpString || !pHelpString->length()) &&
+                 (m_iFlags & wxPG_FL_STRING_IN_STATUSBAR) )
+            {
+                // Clear help box - but only if it was written
+                // by us at previous time.
+                statusbar->SetStatusText( m_emptyString );
+                m_iFlags &= ~(wxPG_FL_STRING_IN_STATUSBAR);
+            }
+        }
+    }
+#endif
+
+    m_inDoSelectProperty = 0;
+
+    // call wx event handler (here so that it also occurs on deselection)
+    SendEvent( wxEVT_PG_SELECTED, m_selected, NULL, flags );
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::UnfocusEditor()
+{
+    if ( !m_selected || !m_wndEditor || m_frozen )
+        return true;
+
+    if ( !CommitChangesFromEditor(0) )
+        return false;
+
+    SetFocusOnCanvas();
+    DrawItem(m_selected);
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::RefreshEditor()
+{
+    wxPGProperty* p = m_selected;
+    if ( !p ) 
+        return;
+
+    wxWindow* wnd = GetEditorControl();
+    if ( !wnd )
+        return;
+
+    // Set editor font boldness - must do this before
+    // calling UpdateControl().
+    if ( HasFlag(wxPG_BOLD_MODIFIED) )
+    {
+        if ( p->HasFlag(wxPG_PROP_MODIFIED) )
+            wnd->SetFont(GetCaptionFont());
+        else
+            wnd->SetFont(GetFont());
+    }
+
+    const wxPGEditor* editorClass = p->GetEditorClass();
+
+    editorClass->UpdateControl(p, wnd);
+
+    if ( p->IsValueUnspecified() )
+        editorClass ->SetValueToUnspecified(p, wnd);
+}
+
+// -----------------------------------------------------------------------
+
+// This method is not inline because it called dozens of times
+// (i.e. two-arg function calls create smaller code size).
+bool wxPropertyGrid::DoClearSelection()
+{
+    return DoSelectProperty(NULL);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid expand/collapse state
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::DoCollapse( wxPGProperty* p, bool sendEvents )
+{
+    wxPGProperty* pwc = wxStaticCast(p, wxPGProperty);
+
+    // If active editor was inside collapsed section, then disable it
+    if ( m_selected && m_selected->IsSomeParent(p) )
+    {
+        ClearSelection(false);
+    }
+
+    // Store dont-center-splitter flag 'cause we need to temporarily set it
+    wxUint32 old_flag = m_iFlags & wxPG_FL_DONT_CENTER_SPLITTER;
+    m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
+
+    bool res = m_pState->DoCollapse(pwc);
+
+    if ( res )
+    {
+        if ( sendEvents )
+            SendEvent( wxEVT_PG_ITEM_COLLAPSED, p );
+
+        RecalculateVirtualSize();
+
+        // Redraw etc. only if collapsed was visible.
+        if (pwc->IsVisible() &&
+            !m_frozen &&
+            ( !pwc->IsCategory() || !(m_windowStyle & wxPG_HIDE_CATEGORIES) ) )
+        {
+            // When item is collapsed so that scrollbar would move,
+            // graphics mess is about (unless we redraw everything).
+            Refresh();
+        }
+    }
+
+    // Clear dont-center-splitter flag if it wasn't set
+    m_iFlags = (m_iFlags & ~wxPG_FL_DONT_CENTER_SPLITTER) | old_flag;
+
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::DoExpand( wxPGProperty* p, bool sendEvents )
+{
+    wxCHECK_MSG( p, false, wxT("invalid property id") );
+
+    wxPGProperty* pwc = (wxPGProperty*)p;
+
+    // Store dont-center-splitter flag 'cause we need to temporarily set it
+    wxUint32 old_flag = m_iFlags & wxPG_FL_DONT_CENTER_SPLITTER;
+    m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
+
+    bool res = m_pState->DoExpand(pwc);
+
+    if ( res )
+    {
+        if ( sendEvents )
+            SendEvent( wxEVT_PG_ITEM_EXPANDED, p );
+
+        RecalculateVirtualSize();
+
+        // Redraw etc. only if expanded was visible.
+        if ( pwc->IsVisible() && !m_frozen &&
+             ( !pwc->IsCategory() || !(m_windowStyle & wxPG_HIDE_CATEGORIES) )
+           )
+        {
+            // Redraw
+        #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+            Refresh();
+        #else
+            DrawItems(pwc, NULL);
+        #endif
+        }
+    }
+
+    // Clear dont-center-splitter flag if it wasn't set
+    m_iFlags = (m_iFlags & ~wxPG_FL_DONT_CENTER_SPLITTER) | old_flag;
+
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::DoHideProperty( wxPGProperty* p, bool hide, int flags )
+{
+    if ( m_frozen )
+        return m_pState->DoHideProperty(p, hide, flags);
+
+    if ( m_selected &&
+         ( m_selected == p || m_selected->IsSomeParent(p) )
+       )
+        {
+            ClearSelection(false);
+        }
+
+    m_pState->DoHideProperty(p, hide, flags);
+
+    RecalculateVirtualSize();
+    Refresh();
+
+    return true;
+}
+
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid size related methods
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::RecalculateVirtualSize( int forceXPos )
+{
+    if ( (m_iFlags & wxPG_FL_RECALCULATING_VIRTUAL_SIZE) || m_frozen )
+        return;
+
+    //
+    // If virtual height was changed, then recalculate editor control position(s)
+    if ( m_pState->m_vhCalcPending )
+        CorrectEditorWidgetPosY();
+
+    m_pState->EnsureVirtualHeight();
+
+    wxASSERT_LEVEL_2_MSG(
+        m_pState->GetVirtualHeight() == m_pState->GetActualVirtualHeight(),
+        "VirtualHeight and ActualVirtualHeight should match"
+    );
+
+    m_iFlags |= wxPG_FL_RECALCULATING_VIRTUAL_SIZE;
+
+    int x = m_pState->m_width;
+    int y = m_pState->m_virtualHeight;
+
+    int width, height;
+    GetClientSize(&width,&height);
+
+    // Now adjust virtual size.
+    SetVirtualSize(x, y);
+
+    int xAmount = 0;
+    int xPos = 0;
+
+    //
+    // Adjust scrollbars
+    if ( HasVirtualWidth() )
+    {
+        xAmount = x/wxPG_PIXELS_PER_UNIT;
+        xPos = GetScrollPos( wxHORIZONTAL );
+    }
+
+    if ( forceXPos != -1 )
+        xPos = forceXPos;
+    // xPos too high?
+    else if ( xPos > (xAmount-(width/wxPG_PIXELS_PER_UNIT)) )
+        xPos = 0;
+
+    int yAmount = y / wxPG_PIXELS_PER_UNIT;
+    int yPos = GetScrollPos( wxVERTICAL );
+
+    SetScrollbars( wxPG_PIXELS_PER_UNIT, wxPG_PIXELS_PER_UNIT,
+                   xAmount, yAmount, xPos, yPos, true );
+
+    // Must re-get size now
+    GetClientSize(&width,&height);
+
+    if ( !HasVirtualWidth() )
+    {
+        m_pState->SetVirtualWidth(width);
+        x = width;
+    }
+
+    m_width = width;
+    m_height = height;
+
+    m_canvas->SetSize( x, y );
+
+    m_pState->CheckColumnWidths();
+
+    if ( m_selected )
+        CorrectEditorWidgetSizeX();
+
+    m_iFlags &= ~wxPG_FL_RECALCULATING_VIRTUAL_SIZE;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnResize( wxSizeEvent& event )
+{
+    if ( !(m_iFlags & wxPG_FL_INITIALIZED) )
+        return;
+
+    int width, height;
+    GetClientSize(&width,&height);
+
+    m_width = width;
+    m_height = height;
+
+#if wxPG_DOUBLE_BUFFER
+    if ( !(GetExtraStyle() & wxPG_EX_NATIVE_DOUBLE_BUFFERING) )
+    {
+        int dblh = (m_lineHeight*2);
+        if ( !m_doubleBuffer )
+        {
+            // Create double buffer bitmap to draw on, if none
+            int w = (width>250)?width:250;
+            int h = height + dblh;
+            h = (h>400)?h:400;
+            m_doubleBuffer = new wxBitmap( w, h );
+        }
+        else
+        {
+            int w = m_doubleBuffer->GetWidth();
+            int h = m_doubleBuffer->GetHeight();
+
+            // Double buffer must be large enough
+            if ( w < width || h < (height+dblh) )
+            {
+                if ( w < width ) w = width;
+                if ( h < (height+dblh) ) h = height + dblh;
+                delete m_doubleBuffer;
+                m_doubleBuffer = new wxBitmap( w, h );
+            }
+        }
+    }
+
+#endif
+
+    m_pState->OnClientWidthChange( width, event.GetSize().x - m_ncWidth, true );
+    m_ncWidth = event.GetSize().x;
+
+    if ( !m_frozen )
+    {
+        if ( m_pState->m_itemsAdded )
+            PrepareAfterItemsAdded();
+        else
+            // Without this, virtual size (atleast under wxGTK) will be skewed
+            RecalculateVirtualSize();
+
+        Refresh();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::SetVirtualWidth( int width )
+{
+    if ( width == -1 )
+    {
+        // Disable virtual width
+        width = GetClientSize().x;
+        ClearInternalFlag(wxPG_FL_HAS_VIRTUAL_WIDTH);
+    }
+    else
+    {
+        // Enable virtual width
+        SetInternalFlag(wxPG_FL_HAS_VIRTUAL_WIDTH);
+    }
+    m_pState->SetVirtualWidth( width );
+}
+
+void wxPropertyGrid::SetFocusOnCanvas()
+{
+    m_canvas->SetFocusIgnoringChildren();
+    m_editorFocused = 0;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid mouse event handling
+// -----------------------------------------------------------------------
+
+// selFlags uses same values DoSelectProperty's flags
+// Returns true if event was vetoed.
+bool wxPropertyGrid::SendEvent( int eventType, wxPGProperty* p, wxVariant* pValue, unsigned int WXUNUSED(selFlags) )
+{
+    // Send property grid event of specific type and with specific property
+    wxPropertyGridEvent evt( eventType, m_eventObject->GetId() );
+    evt.SetPropertyGrid(this);
+    evt.SetEventObject(m_eventObject);
+    evt.SetProperty(p);
+    if ( pValue )
+    {
+        evt.SetCanVeto(true);
+        evt.SetupValidationInfo();
+        m_validationInfo.m_pValue = pValue;
+    }
+    wxEvtHandler* evtHandler = m_eventObject->GetEventHandler();
+
+    evtHandler->ProcessEvent(evt);
+
+    return evt.WasVetoed();
+}
+
+// -----------------------------------------------------------------------
+
+// Return false if should be skipped
+bool wxPropertyGrid::HandleMouseClick( int x, unsigned int y, wxMouseEvent &event )
+{
+    bool res = true;
+
+    // Need to set focus?
+    if ( !(m_iFlags & wxPG_FL_FOCUSED) )
+    {
+        SetFocusOnCanvas();
+    }
+
+    wxPropertyGridPageState* state = m_pState;
+    int splitterHit;
+    int splitterHitOffset;
+    int columnHit = state->HitTestH( x, &splitterHit, &splitterHitOffset );
+
+    wxPGProperty* p = DoGetItemAtY(y);
+
+    if ( p )
+    {
+        int depth = (int)p->GetDepth() - 1;
+
+        int marginEnds = m_marginWidth + ( depth * m_subgroup_extramargin );
+
+        if ( x >= marginEnds )
+        {
+            // Outside margin.
+
+            if ( p->IsCategory() )
+            {
+                // This is category.
+                wxPropertyCategory* pwc = (wxPropertyCategory*)p;
+
+                int textX = m_marginWidth + ((unsigned int)((pwc->m_depth-1)*m_subgroup_extramargin));
+
+                // Expand, collapse, activate etc. if click on text or left of splitter.
+                if ( x >= textX
+                     &&
+                     ( x < (textX+pwc->GetTextExtent(this, m_captionFont)+(wxPG_CAPRECTXMARGIN*2)) ||
+                       columnHit == 0
+                     )
+                    )
+                {
+                    if ( !DoSelectProperty( p ) )
+                        return res;
+
+                    // On double-click, expand/collapse.
+                    if ( event.ButtonDClick() && !(m_windowStyle & wxPG_HIDE_MARGIN) )
+                    {
+                        if ( pwc->IsExpanded() ) DoCollapse( p, true );
+                        else DoExpand( p, true );
+                    }
+                }
+            }
+            else if ( splitterHit == -1 )
+            {
+            // Click on value.
+                unsigned int selFlag = 0;
+                if ( columnHit == 1 )
+                {
+                    m_iFlags |= wxPG_FL_ACTIVATION_BY_CLICK;
+                    selFlag = wxPG_SEL_FOCUS;
+                }
+                if ( !DoSelectProperty( p, selFlag ) )
+                    return res;
+
+                m_iFlags &= ~(wxPG_FL_ACTIVATION_BY_CLICK);
+
+                if ( p->GetChildCount() && !p->IsCategory() )
+                    // On double-click, expand/collapse.
+                    if ( event.ButtonDClick() && !(m_windowStyle & wxPG_HIDE_MARGIN) )
+                    {
+                        wxPGProperty* pwc = (wxPGProperty*)p;
+                        if ( pwc->IsExpanded() ) DoCollapse( p, true );
+                        else DoExpand( p, true );
+                    }
+
+                res = false;
+            }
+            else
+            {
+            // click on splitter
+                if ( !(m_windowStyle & wxPG_STATIC_SPLITTER) )
+                {
+                    if ( event.GetEventType() == wxEVT_LEFT_DCLICK )
+                    {
+                        // Double-clicking the splitter causes auto-centering
+                        CenterSplitter( true );
+                    }
+                    else if ( m_dragStatus == 0 )
+                    {
+                    //
+                    // Begin draggin the splitter
+                    //
+                        if ( m_wndEditor )
+                        {
+                            // Changes must be committed here or the
+                            // value won't be drawn correctly
+                            if ( !CommitChangesFromEditor() )
+                                return res;
+
+                            m_wndEditor->Show ( false );
+                        }
+
+                        if ( !(m_iFlags & wxPG_FL_MOUSE_CAPTURED) )
+                        {
+                            m_canvas->CaptureMouse();
+                            m_iFlags |= wxPG_FL_MOUSE_CAPTURED;
+                        }
+
+                        m_dragStatus = 1;
+                        m_draggedSplitter = splitterHit;
+                        m_dragOffset = splitterHitOffset;
+
+                        wxClientDC dc(m_canvas);
+
+                    #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+                        // Fixes button disappearance bug
+                        if ( m_wndEditor2 )
+                            m_wndEditor2->Show ( false );
+                    #endif
+
+                        m_startingSplitterX = x - splitterHitOffset;
+                    }
+                }
+            }
+        }
+        else
+        {
+        // Click on margin.
+            if ( p->GetChildCount() )
+            {
+                int nx = x + m_marginWidth - marginEnds; // Normalize x.
+
+                if ( (nx >= m_gutterWidth && nx < (m_gutterWidth+m_iconWidth)) )
+                {
+                    int y2 = y % m_lineHeight;
+                    if ( (y2 >= m_buttonSpacingY && y2 < (m_buttonSpacingY+m_iconHeight)) )
+                    {
+                        // On click on expander button, expand/collapse
+                        if ( ((wxPGProperty*)p)->IsExpanded() )
+                            DoCollapse( p, true );
+                        else
+                            DoExpand( p, true );
+                    }
+                }
+            }
+        }
+    }
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::HandleMouseRightClick( int WXUNUSED(x), unsigned int WXUNUSED(y),
+                                            wxMouseEvent& WXUNUSED(event) )
+{
+    if ( m_propHover )
+    {
+        // Select property here as well
+        wxPGProperty* p = m_propHover;
+        if ( p != m_selected )
+            DoSelectProperty( p );
+
+        // Send right click event.
+        SendEvent( wxEVT_PG_RIGHT_CLICK, p );
+
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::HandleMouseDoubleClick( int WXUNUSED(x), unsigned int WXUNUSED(y),
+                                             wxMouseEvent& WXUNUSED(event) )
+{
+    if ( m_propHover )
+    {
+        // Select property here as well
+        wxPGProperty* p = m_propHover;
+
+        if ( p != m_selected )
+            DoSelectProperty( p );
+
+        // Send double-click event.
+        SendEvent( wxEVT_PG_DOUBLE_CLICK, m_propHover );
+
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+#if wxPG_SUPPORT_TOOLTIPS
+
+void wxPropertyGrid::SetToolTip( const wxString& tipString )
+{
+    if ( tipString.length() )
+    {
+        m_canvas->SetToolTip(tipString);
+    }
+    else
+    {
+    #if wxPG_ALLOW_EMPTY_TOOLTIPS
+        m_canvas->SetToolTip( m_emptyString );
+    #else
+        m_canvas->SetToolTip( NULL );
+    #endif
+    }
+}
+
+#endif // #if wxPG_SUPPORT_TOOLTIPS
+
+// -----------------------------------------------------------------------
+
+// Return false if should be skipped
+bool wxPropertyGrid::HandleMouseMove( int x, unsigned int y, wxMouseEvent &event )
+{
+    // Safety check (needed because mouse capturing may
+    // otherwise freeze the control)
+    if ( m_dragStatus > 0 && !event.Dragging() )
+    {
+        HandleMouseUp(x,y,event);
+    }
+
+    wxPropertyGridPageState* state = m_pState;
+    int splitterHit;
+    int splitterHitOffset;
+    int columnHit = state->HitTestH( x, &splitterHit, &splitterHitOffset );
+    int splitterX = x - splitterHitOffset;
+
+    if ( m_dragStatus > 0 )
+    {
+        if ( x > (m_marginWidth + wxPG_DRAG_MARGIN) &&
+             x < (m_pState->m_width - wxPG_DRAG_MARGIN) )
+        {
+
+            int newSplitterX = x - m_dragOffset;
+            int splitterX = x - splitterHitOffset;
+
+            // Splitter redraw required?
+            if ( newSplitterX != splitterX )
+            {
+                // Move everything
+                SetInternalFlag(wxPG_FL_DONT_CENTER_SPLITTER);
+                state->DoSetSplitterPosition( newSplitterX, m_draggedSplitter, false );
+                state->m_fSplitterX = (float) newSplitterX;
+
+                if ( m_selected )
+                    CorrectEditorWidgetSizeX();
+
+                Update();
+                Refresh();
+            }
+
+            m_dragStatus = 2;
+        }
+
+        return false;
+    }
+    else
+    {
+
+        int ih = m_lineHeight;
+        int sy = y;
+
+    #if wxPG_SUPPORT_TOOLTIPS
+        wxPGProperty* prevHover = m_propHover;
+        unsigned char prevSide = m_mouseSide;
+    #endif
+        int curPropHoverY = y - (y % ih);
+
+        // On which item it hovers
+        if ( !m_propHover
+             ||
+             ( sy < m_propHoverY || sy >= (m_propHoverY+ih) )
+           )
+        {
+            // Mouse moves on another property
+
+            m_propHover = DoGetItemAtY(y);
+            m_propHoverY = curPropHoverY;
+
+            // Send hover event
+            SendEvent( wxEVT_PG_HIGHLIGHTED, m_propHover );
+        }
+
+    #if wxPG_SUPPORT_TOOLTIPS
+        // Store which side we are on
+        m_mouseSide = 0;
+        if ( columnHit == 1 )
+            m_mouseSide = 2;
+        else if ( columnHit == 0 )
+            m_mouseSide = 1;
+
+        //
+        // If tooltips are enabled, show label or value as a tip
+        // in case it doesn't otherwise show in full length.
+        //
+        if ( m_windowStyle & wxPG_TOOLTIPS )
+        {
+            wxToolTip* tooltip = m_canvas->GetToolTip();
+
+            if ( m_propHover != prevHover || prevSide != m_mouseSide )
+            {
+                if ( m_propHover && !m_propHover->IsCategory() )
+                {
+
+                    if ( GetExtraStyle() & wxPG_EX_HELP_AS_TOOLTIPS )
+                    {
+                        // Show help string as a tooltip
+                        wxString tipString = m_propHover->GetHelpString();
+
+                        SetToolTip(tipString);
+                    }
+                    else
+                    {
+                        // Show cropped value string as a tooltip
+                        wxString tipString;
+                        int space = 0;
+
+                        if ( m_mouseSide == 1 )
+                        {
+                            tipString = m_propHover->m_label;
+                            space = splitterX-m_marginWidth-3;
+                        }
+                        else if ( m_mouseSide == 2 )
+                        {
+                            tipString = m_propHover->GetDisplayedString();
+
+                            space = m_width - splitterX;
+                            if ( m_propHover->m_flags & wxPG_PROP_CUSTOMIMAGE )
+                                space -= wxPG_CUSTOM_IMAGE_WIDTH + wxCC_CUSTOM_IMAGE_MARGIN1 + wxCC_CUSTOM_IMAGE_MARGIN2;
+                        }
+
+                        if ( space )
+                        {
+                            int tw, th;
+                            GetTextExtent( tipString, &tw, &th, 0, 0 );
+                            if ( tw > space )
+                            {
+                                SetToolTip( tipString );
+                            }
+                        }
+                        else
+                        {
+                            if ( tooltip )
+                            {
+                            #if wxPG_ALLOW_EMPTY_TOOLTIPS
+                                m_canvas->SetToolTip( m_emptyString );
+                            #else
+                                m_canvas->SetToolTip( NULL );
+                            #endif
+                            }
+                        }
+
+                    }
+                }
+                else
+                {
+                    if ( tooltip )
+                    {
+                    #if wxPG_ALLOW_EMPTY_TOOLTIPS
+                        m_canvas->SetToolTip( m_emptyString );
+                    #else
+                        m_canvas->SetToolTip( NULL );
+                    #endif
+                    }
+                }
+            }
+        }
+    #endif
+
+        if ( splitterHit == -1 ||
+             !m_propHover ||
+             HasFlag(wxPG_STATIC_SPLITTER) )
+        {
+            // hovering on something else
+            if ( m_curcursor != wxCURSOR_ARROW )
+                CustomSetCursor( wxCURSOR_ARROW );
+        }
+        else
+        {
+            // Do not allow splitter cursor on caption items.
+            // (also not if we were dragging and its started
+            // outside the splitter region)
+
+            if ( !m_propHover->IsCategory() &&
+                 !event.Dragging() )
+            {
+
+                // hovering on splitter
+
+                // NB: Condition disabled since MouseLeave event (from the editor control) cannot be
+                //     reliably detected.
+                //if ( m_curcursor != wxCURSOR_SIZEWE )
+                CustomSetCursor( wxCURSOR_SIZEWE, true );
+
+                return false;
+            }
+            else
+            {
+                // hovering on something else
+                if ( m_curcursor != wxCURSOR_ARROW )
+                    CustomSetCursor( wxCURSOR_ARROW );
+            }
+        }
+    }
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+// Also handles Leaving event
+bool wxPropertyGrid::HandleMouseUp( int x, unsigned int WXUNUSED(y),
+                                    wxMouseEvent &WXUNUSED(event) )
+{
+    wxPropertyGridPageState* state = m_pState;
+    bool res = false;
+
+    int splitterHit;
+    int splitterHitOffset;
+    state->HitTestH( x, &splitterHit, &splitterHitOffset );
+
+    // No event type check - basicly calling this method should
+    // just stop dragging.
+    // Left up after dragged?
+    if ( m_dragStatus >= 1 )
+    {
+    //
+    // End Splitter Dragging
+    //
+        // DO NOT ENABLE FOLLOWING LINE!
+        // (it is only here as a reminder to not to do it)
+        //splitterX = x;
+
+        // Disable splitter auto-centering
+        m_iFlags |= wxPG_FL_DONT_CENTER_SPLITTER;
+
+        // This is necessary to return cursor
+        if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
+        {
+            m_canvas->ReleaseMouse();
+            m_iFlags &= ~(wxPG_FL_MOUSE_CAPTURED);
+        }
+
+        // Set back the default cursor, if necessary
+        if ( splitterHit == -1 ||
+             !m_propHover )
+        {
+            CustomSetCursor( wxCURSOR_ARROW );
+        }
+
+        m_dragStatus = 0;
+
+        // Control background needs to be cleared
+        if ( !(m_iFlags & wxPG_FL_PRIMARY_FILLS_ENTIRE) && m_selected )
+            DrawItem( m_selected );
+
+        if ( m_wndEditor )
+        {
+            m_wndEditor->Show ( true );
+        }
+
+    #if wxPG_REFRESH_CONTROLS_AFTER_REPAINT
+        // Fixes button disappearance bug
+        if ( m_wndEditor2 )
+            m_wndEditor2->Show ( true );
+    #endif
+
+        // This clears the focus.
+        m_editorFocused = 0;
+
+    }
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::OnMouseCommon( wxMouseEvent& event, int* px, int* py )
+{
+    int splitterX = GetSplitterPosition();
+
+    //int ux, uy;
+    //CalcUnscrolledPosition( event.m_x, event.m_y, &ux, &uy );
+    int ux = event.m_x;
+    int uy = event.m_y;
+
+    wxWindow* wnd = GetEditorControl();
+
+    // Hide popup on clicks
+    if ( event.GetEventType() != wxEVT_MOTION )
+        if ( wnd && wnd->IsKindOf(CLASSINFO(wxOwnerDrawnComboBox)) )
+        {
+            ((wxOwnerDrawnComboBox*)wnd)->HidePopup();
+        }
+
+    wxRect r;
+    if ( wnd )
+        r = wnd->GetRect();
+    if ( wnd == NULL || m_dragStatus ||
+         (
+           ux <= (splitterX + wxPG_SPLITTERX_DETECTMARGIN2) ||
+           ux >= (r.x+r.width) ||
+           event.m_y < r.y ||
+           event.m_y >= (r.y+r.height)
+         )
+       )
+    {
+        *px = ux;
+        *py = uy;
+        return true;
+    }
+    else
+    {
+        if ( m_curcursor != wxCURSOR_ARROW ) CustomSetCursor ( wxCURSOR_ARROW );
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseClick( wxMouseEvent &event )
+{
+    int x, y;
+    if ( OnMouseCommon( event, &x, &y ) )
+    {
+        HandleMouseClick(x,y,event);
+    }
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseRightClick( wxMouseEvent &event )
+{
+    int x, y;
+    CalcUnscrolledPosition( event.m_x, event.m_y, &x, &y );
+    HandleMouseRightClick(x,y,event);
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseDoubleClick( wxMouseEvent &event )
+{
+    // Always run standard mouse-down handler as well
+    OnMouseClick(event);
+
+    int x, y;
+    CalcUnscrolledPosition( event.m_x, event.m_y, &x, &y );
+    HandleMouseDoubleClick(x,y,event);
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseMove( wxMouseEvent &event )
+{
+    int x, y;
+    if ( OnMouseCommon( event, &x, &y ) )
+    {
+        HandleMouseMove(x,y,event);
+    }
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseMoveBottom( wxMouseEvent& WXUNUSED(event) )
+{
+    // Called when mouse moves in the empty space below the properties.
+    CustomSetCursor( wxCURSOR_ARROW );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseUp( wxMouseEvent &event )
+{
+    int x, y;
+    if ( OnMouseCommon( event, &x, &y ) )
+    {
+        HandleMouseUp(x,y,event);
+    }
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnMouseEntry( wxMouseEvent &event )
+{
+    // This may get called from child control as well, so event's
+    // mouse position cannot be relied on.
+
+    if ( event.Entering() )
+    {
+        if ( !(m_iFlags & wxPG_FL_MOUSE_INSIDE) )
+        {
+            // TODO: Fix this (detect parent and only do
+            //   cursor trick if it is a manager).
+            wxASSERT( GetParent() );
+            GetParent()->SetCursor(wxNullCursor);
+
+            m_iFlags |= wxPG_FL_MOUSE_INSIDE;
+        }
+        else
+            GetParent()->SetCursor(wxNullCursor);
+    }
+    else if ( event.Leaving() )
+    {
+        // Without this, wxSpinCtrl editor will sometimes have wrong cursor
+        m_canvas->SetCursor( wxNullCursor );
+
+        // Get real cursor position
+        wxPoint pt = ScreenToClient(::wxGetMousePosition());
+
+        if ( ( pt.x <= 0 || pt.y <= 0 || pt.x >= m_width || pt.y >= m_height ) )
+        {
+            {
+                if ( (m_iFlags & wxPG_FL_MOUSE_INSIDE) )
+                {
+                    m_iFlags &= ~(wxPG_FL_MOUSE_INSIDE);
+                }
+
+                if ( m_dragStatus )
+                    wxPropertyGrid::HandleMouseUp ( -1, 10000, event );
+            }
+        }
+    }
+
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+// Common code used by various OnMouseXXXChild methods.
+bool wxPropertyGrid::OnMouseChildCommon( wxMouseEvent &event, int* px, int *py )
+{
+    wxWindow* topCtrlWnd = (wxWindow*)event.GetEventObject();
+    wxASSERT( topCtrlWnd );
+    int x, y;
+    event.GetPosition(&x,&y);
+
+    int splitterX = GetSplitterPosition();
+
+    wxRect r = topCtrlWnd->GetRect();
+    if ( !m_dragStatus &&
+         x > (splitterX-r.x+wxPG_SPLITTERX_DETECTMARGIN2) &&
+         y >= 0 && y < r.height \
+       )
+    {
+        if ( m_curcursor != wxCURSOR_ARROW ) CustomSetCursor ( wxCURSOR_ARROW );
+        event.Skip();
+    }
+    else
+    {
+        CalcUnscrolledPosition( event.m_x + r.x, event.m_y + r.y, \
+            px, py );
+        return true;
+    }
+    return false;
+}
+
+void wxPropertyGrid::OnMouseClickChild( wxMouseEvent &event )
+{
+    int x,y;
+    if ( OnMouseChildCommon(event,&x,&y) )
+    {
+        bool res = HandleMouseClick(x,y,event);
+        if ( !res ) event.Skip();
+    }
+}
+
+void wxPropertyGrid::OnMouseRightClickChild( wxMouseEvent &event )
+{
+    int x,y;
+    wxASSERT( m_wndEditor );
+    // These coords may not be exact (about +-2),
+    // but that should not matter (right click is about item, not position).
+    wxPoint pt = m_wndEditor->GetPosition();
+    CalcUnscrolledPosition( event.m_x + pt.x, event.m_y + pt.y, &x, &y );
+    wxASSERT( m_selected );
+    m_propHover = m_selected;
+    bool res = HandleMouseRightClick(x,y,event);
+    if ( !res ) event.Skip();
+}
+
+void wxPropertyGrid::OnMouseMoveChild( wxMouseEvent &event )
+{
+    int x,y;
+    if ( OnMouseChildCommon(event,&x,&y) )
+    {
+        bool res = HandleMouseMove(x,y,event);
+        if ( !res ) event.Skip();
+    }
+}
+
+void wxPropertyGrid::OnMouseUpChild( wxMouseEvent &event )
+{
+    int x,y;
+    if ( OnMouseChildCommon(event,&x,&y) )
+    {
+        bool res = HandleMouseUp(x,y,event);
+        if ( !res ) event.Skip();
+    }
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid keyboard event handling
+// -----------------------------------------------------------------------
+
+int wxPropertyGrid::KeyEventToActions(wxKeyEvent &event, int* pSecond) const
+{
+    // Translates wxKeyEvent to wxPG_ACTION_XXX
+
+    int keycode = event.GetKeyCode();
+    int modifiers = event.GetModifiers();
+
+    wxASSERT( !(modifiers&~(0xFFFF)) );
+
+    int hashMapKey = (keycode & 0xFFFF) | ((modifiers & 0xFFFF) << 16);
+
+    wxPGHashMapI2I::const_iterator it = m_actionTriggers.find(hashMapKey);
+
+    if ( it == m_actionTriggers.end() )
+        return 0;
+
+    if ( pSecond )
+    {
+        int second = (it->second>>16) & 0xFFFF;
+        *pSecond = second;
+    }
+
+    return (it->second & 0xFFFF);
+}
+
+void wxPropertyGrid::AddActionTrigger( int action, int keycode, int modifiers )
+{
+    wxASSERT( !(modifiers&~(0xFFFF)) );
+
+    int hashMapKey = (keycode & 0xFFFF) | ((modifiers & 0xFFFF) << 16);
+
+    wxPGHashMapI2I::iterator it = m_actionTriggers.find(hashMapKey);
+
+    if ( it != m_actionTriggers.end() )
+    {
+        // This key combination is already used
+
+        // Can add secondary?
+        wxASSERT_MSG( !(it->second&~(0xFFFF)),
+                      wxT("You can only add up to two separate actions per key combination.") );
+
+        action = it->second | (action<<16);
+    }
+
+    m_actionTriggers[hashMapKey] = action;
+}
+
+void wxPropertyGrid::ClearActionTriggers( int action )
+{
+    wxPGHashMapI2I::iterator it;
+
+    for ( it = m_actionTriggers.begin(); it != m_actionTriggers.end(); ++it )
+    {
+        if ( it->second == action )
+        {
+            m_actionTriggers.erase(it);
+        }
+    }
+}
+
+void wxPropertyGrid::HandleKeyEvent( wxKeyEvent &event, bool fromChild )
+{
+    //
+    // Handles key event when editor control is not focused.
+    //
+
+    wxCHECK2(!m_frozen, return);
+
+    // Travelsal between items, collapsing/expanding, etc.
+    int keycode = event.GetKeyCode();
+    bool editorFocused = IsEditorFocused();
+
+    if ( keycode == WXK_TAB )
+    {
+        wxWindow* mainControl;
+
+        if ( HasInternalFlag(wxPG_FL_IN_MANAGER) )
+            mainControl = GetParent();
+        else
+            mainControl = this;
+
+        if ( !event.ShiftDown() )
+        {
+            if ( !editorFocused && m_wndEditor )
+            {
+                DoSelectProperty( m_selected, wxPG_SEL_FOCUS );
+            }
+            else
+            {
+                // Tab traversal workaround for platforms on which
+                // wxWindow::Navigate() may navigate into first child
+                // instead of next sibling. Does not work perfectly
+                // in every scenario (for instance, when property grid
+                // is either first or last control).
+            #if defined(__WXGTK__)
+                wxWindow* sibling = mainControl->GetNextSibling();
+                if ( sibling )
+                    sibling->SetFocusFromKbd();
+            #else
+                Navigate(wxNavigationKeyEvent::IsForward);
+            #endif
+            }
+        }
+        else
+        {
+            if ( editorFocused )
+            {
+                UnfocusEditor();
+            }
+            else
+            {
+            #if defined(__WXGTK__)
+                wxWindow* sibling = mainControl->GetPrevSibling();
+                if ( sibling )
+                    sibling->SetFocusFromKbd();
+            #else
+                Navigate(wxNavigationKeyEvent::IsBackward);
+            #endif
+            }
+        }
+
+        return;
+    }
+
+    // Ignore Alt and Control when they are down alone
+    if ( keycode == WXK_ALT ||
+         keycode == WXK_CONTROL )
+    {
+        event.Skip();
+        return;
+    }
+
+    int secondAction;
+    int action = KeyEventToActions(event, &secondAction);
+
+    if ( editorFocused && action == wxPG_ACTION_CANCEL_EDIT )
+    {
+        //
+        // Esc cancels any changes
+        if ( IsEditorsValueModified() )
+        {
+            EditorsValueWasNotModified();
+
+            // Update the control as well
+            m_selected->GetEditorClass()->SetControlStringValue( m_selected,
+                                                                 GetEditorControl(),
+                                                                 m_selected->GetDisplayedString() );
+        }
+
+        OnValidationFailureReset(m_selected);
+
+        UnfocusEditor();
+        return;
+    }
+
+    // Except for TAB and ESC, handle child control events in child control
+    if ( fromChild )
+    {
+        // Only propagate event if it had modifiers
+        if ( !event.HasModifiers() )
+        {
+            event.StopPropagation();
+        }
+        event.Skip();
+        return;
+    }
+
+    bool wasHandled = false;
+
+    if ( m_selected )
+    {
+        // Show dialog?
+        if ( ButtonTriggerKeyTest(action, event) )
+            return;
+
+        wxPGProperty* p = m_selected;
+
+        // Travel and expand/collapse
+        int selectDir = -2;
+
+        if ( p->GetChildCount() )
+        {
+            if ( action == wxPG_ACTION_COLLAPSE_PROPERTY || secondAction == wxPG_ACTION_COLLAPSE_PROPERTY )
+            {
+                if ( (m_windowStyle & wxPG_HIDE_MARGIN) || Collapse(p) )
+                    wasHandled = true;
+            }
+            else if ( action == wxPG_ACTION_EXPAND_PROPERTY || secondAction == wxPG_ACTION_EXPAND_PROPERTY )
+            {
+                if ( (m_windowStyle & wxPG_HIDE_MARGIN) || Expand(p) )
+                    wasHandled = true;
+            }
+        }
+
+        if ( !wasHandled )
+        {
+            if ( action == wxPG_ACTION_PREV_PROPERTY || secondAction == wxPG_ACTION_PREV_PROPERTY )
+            {
+                selectDir = -1;
+            }
+            else if ( action == wxPG_ACTION_NEXT_PROPERTY || secondAction == wxPG_ACTION_NEXT_PROPERTY )
+            {
+                selectDir = 1;
+            }
+        }
+
+        if ( selectDir >= -1 )
+        {
+            p = wxPropertyGridIterator::OneStep( m_pState, wxPG_ITERATE_VISIBLE, p, selectDir );
+            if ( p )
+                DoSelectProperty(p);
+            wasHandled = true;
+        }
+    }
+    else
+    {
+        // If nothing was selected, select the first item now
+        // (or navigate out of tab).
+        if ( action != wxPG_ACTION_CANCEL_EDIT && secondAction != wxPG_ACTION_CANCEL_EDIT )
+        {
+            wxPGProperty* p = wxPropertyGridInterface::GetFirst();
+            if ( p ) DoSelectProperty(p);
+            wasHandled = true;
+        }
+    }
+
+    if ( !wasHandled )
+        event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnKey( wxKeyEvent &event )
+{
+    // If there was editor open and focused, then this event should not
+    // really be processed here.
+    if ( IsEditorFocused() )
+    {
+        // However, if event had modifiers, it is probably still best
+        // to skip it.
+        if ( event.HasModifiers() )
+            event.Skip();
+        else
+            event.StopPropagation();
+        return;
+    }
+
+    HandleKeyEvent(event, false);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGrid::ButtonTriggerKeyTest( int action, wxKeyEvent& event )
+{
+    if ( action == -1 )
+    {
+        int secondAction;
+        action = KeyEventToActions(event, &secondAction);
+    }
+
+    // Does the keycode trigger button?
+    if ( action == wxPG_ACTION_PRESS_BUTTON &&
+         m_wndEditor2 )
+    {
+        wxCommandEvent evt(wxEVT_COMMAND_BUTTON_CLICKED, m_wndEditor2->GetId());
+        GetEventHandler()->AddPendingEvent(evt);
+        return true;
+    }
+
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnChildKeyDown( wxKeyEvent &event )
+{
+    HandleKeyEvent(event, true);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGrid miscellaneous event handling
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnIdle( wxIdleEvent& WXUNUSED(event) )
+{
+    //
+    // Check if the focus is in this control or one of its children
+    wxWindow* newFocused = wxWindow::FindFocus();
+
+    if ( newFocused != m_curFocused )
+        HandleFocusChange( newFocused );
+}
+
+bool wxPropertyGrid::IsEditorFocused() const
+{
+    wxWindow* focus = wxWindow::FindFocus();
+
+    if ( focus == m_wndEditor || focus == m_wndEditor2 ||
+         focus == GetEditorControl() )
+         return true;
+
+    return false;
+}
+
+// Called by focus event handlers. newFocused is the window that becomes focused.
+void wxPropertyGrid::HandleFocusChange( wxWindow* newFocused )
+{
+    unsigned int oldFlags = m_iFlags;
+
+    m_iFlags &= ~(wxPG_FL_FOCUSED);
+
+    wxWindow* parent = newFocused;
+
+    // This must be one of nextFocus' parents.
+    while ( parent )
+    {
+        // Use m_eventObject, which is either wxPropertyGrid or
+        // wxPropertyGridManager, as appropriate.
+        if ( parent == m_eventObject )
+        {
+            m_iFlags |= wxPG_FL_FOCUSED;
+            break;
+        }
+        parent = parent->GetParent();
+    }
+
+    m_curFocused = newFocused;
+
+    if ( (m_iFlags & wxPG_FL_FOCUSED) !=
+         (oldFlags & wxPG_FL_FOCUSED) )
+    {
+        if ( !(m_iFlags & wxPG_FL_FOCUSED) )
+        {
+            // Need to store changed value
+            CommitChangesFromEditor();
+        }
+        else
+        {
+            /*
+            //
+            // Preliminary code for tab-order respecting
+            // tab-traversal (but should be moved to
+            // OnNav handler)
+            //
+            wxWindow* prevFocus = event.GetWindow();
+            wxWindow* useThis = this;
+            if ( m_iFlags & wxPG_FL_IN_MANAGER )
+                useThis = GetParent();
+
+            if ( prevFocus &&
+                 prevFocus->GetParent() == useThis->GetParent() )
+            {
+                wxList& children = useThis->GetParent()->GetChildren();
+
+                wxNode* node = children.Find(prevFocus);
+
+                if ( node->GetNext() &&
+                     useThis == node->GetNext()->GetData() )
+                    DoSelectProperty(GetFirst());
+                else if ( node->GetPrevious () &&
+                          useThis == node->GetPrevious()->GetData() )
+                    DoSelectProperty(GetLastProperty());
+
+            }
+            */
+        }
+
+        // Redraw selected
+        if ( m_selected && (m_iFlags & wxPG_FL_INITIALIZED) )
+            DrawItem( m_selected );
+    }
+}
+
+void wxPropertyGrid::OnFocusEvent( wxFocusEvent& event )
+{
+    if ( event.GetEventType() == wxEVT_SET_FOCUS )
+        HandleFocusChange((wxWindow*)event.GetEventObject());
+    // Line changed to "else" when applying wxPropertyGrid patch #1675902
+    //else if ( event.GetWindow() )
+    else
+        HandleFocusChange(event.GetWindow());
+
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnChildFocusEvent( wxChildFocusEvent& event )
+{
+    HandleFocusChange((wxWindow*)event.GetEventObject());
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnScrollEvent( wxScrollWinEvent &event )
+{
+    m_iFlags |= wxPG_FL_SCROLLED;
+
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGrid::OnCaptureChange( wxMouseCaptureChangedEvent& WXUNUSED(event) )
+{
+    if ( m_iFlags & wxPG_FL_MOUSE_CAPTURED )
+    {
+        m_iFlags &= ~(wxPG_FL_MOUSE_CAPTURED);
+    }
+}
+
+// -----------------------------------------------------------------------
+// Property editor related functions
+// -----------------------------------------------------------------------
+
+// noDefCheck = true prevents infinite recursion.
+wxPGEditor* wxPropertyGrid::DoRegisterEditorClass( wxPGEditor* editorClass,
+                                                   const wxString& editorName,
+                                                   bool noDefCheck )
+{
+    wxASSERT( editorClass );
+
+    if ( !noDefCheck && wxPGGlobalVars->m_mapEditorClasses.empty() )
+        RegisterDefaultEditors();
+
+    wxString name = editorName;
+    if ( name.length() == 0 )
+        name = editorClass->GetName();
+
+    // Existing editor under this name?
+    wxPGHashMapS2P::iterator vt_it = wxPGGlobalVars->m_mapEditorClasses.find(name);
+
+    if ( vt_it != wxPGGlobalVars->m_mapEditorClasses.end() )
+    {
+        // If this name was already used, try class name.
+        name = editorClass->GetClassInfo()->GetClassName();
+        vt_it = wxPGGlobalVars->m_mapEditorClasses.find(name);
+    }
+
+    wxCHECK_MSG( vt_it == wxPGGlobalVars->m_mapEditorClasses.end(),
+                 (wxPGEditor*) vt_it->second,
+                 "Editor with given name was already registered" );
+
+    wxPGGlobalVars->m_mapEditorClasses[name] = (void*)editorClass;
+
+    return editorClass;
+}
+
+// Use this in RegisterDefaultEditors.
+#define wxPGRegisterDefaultEditorClass(EDITOR) \
+    if ( wxPGEditor_##EDITOR == NULL ) \
+    { \
+        wxPGEditor_##EDITOR = wxPropertyGrid::RegisterEditorClass( \
+            new wxPG##EDITOR##Editor, true ); \
+    }
+
+// Registers all default editor classes
+void wxPropertyGrid::RegisterDefaultEditors()
+{
+    wxPGRegisterDefaultEditorClass( TextCtrl );
+    wxPGRegisterDefaultEditorClass( Choice );
+    wxPGRegisterDefaultEditorClass( ComboBox );
+    wxPGRegisterDefaultEditorClass( TextCtrlAndButton );
+#if wxPG_INCLUDE_CHECKBOX
+    wxPGRegisterDefaultEditorClass( CheckBox );
+#endif
+    wxPGRegisterDefaultEditorClass( ChoiceAndButton );
+
+    // Register SpinCtrl etc. editors before use
+    RegisterAdditionalEditors();
+}
+
+// -----------------------------------------------------------------------
+// wxPGStringTokenizer
+//   Needed to handle C-style string lists (e.g. "str1" "str2")
+// -----------------------------------------------------------------------
+
+wxPGStringTokenizer::wxPGStringTokenizer( const wxString& str, wxChar delimeter )
+    : m_str(&str), m_curPos(str.begin()), m_delimeter(delimeter)
+{
+}
+
+wxPGStringTokenizer::~wxPGStringTokenizer()
+{
+}
+
+bool wxPGStringTokenizer::HasMoreTokens()
+{
+    const wxString& str = *m_str;
+
+    wxString::const_iterator i = m_curPos;
+
+    wxUniChar delim = m_delimeter;
+    wxUniChar a;
+    wxUniChar prev_a = wxT('\0');
+
+    bool inToken = false;
+
+    while ( i != str.end() )
+    {
+        a = *i;
+
+        if ( !inToken )
+        {
+            if ( a == delim )
+            {
+                inToken = true;
+                m_readyToken.clear();
+            }
+        }
+        else
+        {
+            if ( prev_a != wxT('\\') )
+            {
+                if ( a != delim )
+                {
+                    if ( a != wxT('\\') )
+                        m_readyToken << a;
+                }
+                else
+                {
+                    ++i;
+                    m_curPos = i;
+                    return true;
+                }
+                prev_a = a;
+            }
+            else
+            {
+                m_readyToken << a;
+                prev_a = wxT('\0');
+            }
+        }
+        ++i;
+    }
+
+    m_curPos = str.end();
+
+    if ( inToken )
+        return true;
+
+    return false;
+}
+
+wxString wxPGStringTokenizer::GetNextToken()
+{
+    return m_readyToken;
+}
+
+// -----------------------------------------------------------------------
+// wxPGChoiceEntry
+// -----------------------------------------------------------------------
+
+wxPGChoiceEntry::wxPGChoiceEntry()
+    : wxPGCell(), m_value(wxPG_INVALID_VALUE)
+{
+}
+
+// -----------------------------------------------------------------------
+// wxPGChoicesData
+// -----------------------------------------------------------------------
+
+wxPGChoicesData::wxPGChoicesData()
+{
+    m_refCount = 1;
+}
+
+wxPGChoicesData::~wxPGChoicesData()
+{
+    Clear();
+}
+
+void wxPGChoicesData::Clear()
+{
+    m_items.clear();
+}
+
+void wxPGChoicesData::CopyDataFrom( wxPGChoicesData* data )
+{
+    wxASSERT( m_items.size() == 0 );
+
+    m_items = data->m_items;
+}
+
+wxPGChoiceEntry& wxPGChoicesData::Insert( int index,
+                                          const wxPGChoiceEntry& item )
+{
+    wxVector<wxPGChoiceEntry>::iterator it;
+    if ( index == -1 )
+    {
+        it = m_items.end();
+        index = (int) m_items.size();
+    }
+    else
+    {
+        it = m_items.begin() + index;
+    }
+
+    m_items.insert(it, item);
+
+    wxPGChoiceEntry& ownEntry = m_items[index];
+
+    // Need to fix value?
+    if ( ownEntry.GetValue() == wxPG_INVALID_VALUE )
+        ownEntry.SetValue(index);
+
+    return ownEntry;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridEvent
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxPropertyGridEvent, wxCommandEvent)
+
+
+wxDEFINE_EVENT( wxEVT_PG_SELECTED, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_CHANGING, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_CHANGED, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_HIGHLIGHTED, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_RIGHT_CLICK, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_PAGE_CHANGED, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_ITEM_EXPANDED, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_ITEM_COLLAPSED, wxPropertyGridEvent );
+wxDEFINE_EVENT( wxEVT_PG_DOUBLE_CLICK, wxPropertyGridEvent );
+
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridEvent::Init()
+{
+    m_validationInfo = NULL;
+    m_canVeto = false;
+    m_wasVetoed = false;
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridEvent::wxPropertyGridEvent(wxEventType commandType, int id)
+    : wxCommandEvent(commandType,id)
+{
+    m_property = NULL;
+    Init();
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridEvent::wxPropertyGridEvent(const wxPropertyGridEvent& event)
+    : wxCommandEvent(event)
+{
+    m_eventType = event.GetEventType();
+    m_eventObject = event.m_eventObject;
+    m_pg = event.m_pg;
+    m_property = event.m_property;
+    m_validationInfo = event.m_validationInfo;
+    m_canVeto = event.m_canVeto;
+    m_wasVetoed = event.m_wasVetoed;
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridEvent::~wxPropertyGridEvent()
+{
+}
+
+// -----------------------------------------------------------------------
+
+wxEvent* wxPropertyGridEvent::Clone() const
+{
+    return new wxPropertyGridEvent( *this );
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPopulator
+// -----------------------------------------------------------------------
+
+wxPropertyGridPopulator::wxPropertyGridPopulator()
+{
+    m_state = NULL;
+    m_pg = NULL;
+    wxPGGlobalVars->m_offline++;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPopulator::SetState( wxPropertyGridPageState* state )
+{
+    m_state = state;
+    m_propHierarchy.clear();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPopulator::SetGrid( wxPropertyGrid* pg )
+{
+    m_pg = pg;
+    pg->Freeze();
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridPopulator::~wxPropertyGridPopulator()
+{
+    //
+    // Free unused sets of choices
+    wxPGHashMapS2P::iterator it;
+
+    for( it = m_dictIdChoices.begin(); it != m_dictIdChoices.end(); ++it )
+    {
+        wxPGChoicesData* data = (wxPGChoicesData*) it->second;
+        data->DecRef();
+    }
+
+    if ( m_pg )
+    {
+        m_pg->Thaw();
+        m_pg->GetPanel()->Refresh();
+    }
+    wxPGGlobalVars->m_offline--;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPopulator::Add( const wxString& propClass,
+                                            const wxString& propLabel,
+                                            const wxString& propName,
+                                            const wxString* propValue,
+                                            wxPGChoices* pChoices )
+{
+    wxClassInfo* classInfo = wxClassInfo::FindClass(propClass);
+    wxPGProperty* parent = GetCurParent();
+
+    if ( parent->HasFlag(wxPG_PROP_AGGREGATE) )
+    {
+        ProcessError(wxString::Format(wxT("new children cannot be added to '%s'"),parent->GetName().c_str()));
+        return NULL;
+    }
+
+    if ( !classInfo || !classInfo->IsKindOf(CLASSINFO(wxPGProperty)) )
+    {
+        ProcessError(wxString::Format(wxT("'%s' is not valid property class"),propClass.c_str()));
+        return NULL;
+    }
+
+    wxPGProperty* property = (wxPGProperty*) classInfo->CreateObject();
+
+    property->SetLabel(propLabel);
+    property->DoSetName(propName);
+
+    if ( pChoices && pChoices->IsOk() )
+        property->SetChoices(*pChoices);
+
+    m_state->DoInsert(parent, -1, property);
+
+    if ( propValue )
+        property->SetValueFromString( *propValue, wxPG_FULL_VALUE|
+                                                  wxPG_PROGRAMMATIC_VALUE );
+
+    return property;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPopulator::AddChildren( wxPGProperty* property )
+{
+    m_propHierarchy.push_back(property);
+    DoScanForChildren();
+    m_propHierarchy.pop_back();
+}
+
+// -----------------------------------------------------------------------
+
+wxPGChoices wxPropertyGridPopulator::ParseChoices( const wxString& choicesString,
+                                                   const wxString& idString )
+{
+    wxPGChoices choices;
+
+    // Using id?
+    if ( choicesString[0] == wxT('@') )
+    {
+        wxString ids = choicesString.substr(1);
+        wxPGHashMapS2P::iterator it = m_dictIdChoices.find(ids);
+        if ( it == m_dictIdChoices.end() )
+            ProcessError(wxString::Format(wxT("No choices defined for id '%s'"),ids.c_str()));
+        else
+            choices.AssignData((wxPGChoicesData*)it->second);
+    }
+    else
+    {
+        bool found = false;
+        if ( idString.length() )
+        {
+            wxPGHashMapS2P::iterator it = m_dictIdChoices.find(idString);
+            if ( it != m_dictIdChoices.end() )
+            {
+                choices.AssignData((wxPGChoicesData*)it->second);
+                found = true;
+            }
+        }
+
+        if ( !found )
+        {
+            // Parse choices string
+            wxString::const_iterator it = choicesString.begin();
+            wxString label;
+            wxString value;
+            int state = 0;
+            bool labelValid = false;
+
+            for ( ; it != choicesString.end(); ++it )
+            {
+                wxChar c = *it;
+
+                if ( state != 1 )
+                {
+                    if ( c == wxT('"') )
+                    {
+                        if ( labelValid )
+                        {
+                            long l;
+                            if ( !value.ToLong(&l, 0) ) l = wxPG_INVALID_VALUE;
+                            choices.Add(label, l);
+                        }
+                        labelValid = false;
+                        //wxLogDebug(wxT("%s, %s"),label.c_str(),value.c_str());
+                        value.clear();
+                        label.clear();
+                        state = 1;
+                    }
+                    else if ( c == wxT('=') )
+                    {
+                        if ( labelValid )
+                        {
+                            state = 2;
+                        }
+                    }
+                    else if ( state == 2 && (wxIsalnum(c) || c == wxT('x')) )
+                    {
+                        value << c;
+                    }
+                }
+                else
+                {
+                    if ( c == wxT('"') )
+                    {
+                        state = 0;
+                        labelValid = true;
+                    }
+                    else
+                        label << c;
+                }
+            }
+
+            if ( labelValid )
+            {
+                long l;
+                if ( !value.ToLong(&l, 0) ) l = wxPG_INVALID_VALUE;
+                choices.Add(label, l);
+            }
+
+            if ( !choices.IsOk() )
+            {
+                choices.EnsureData();
+            }
+
+            // Assign to id
+            if ( idString.length() )
+                m_dictIdChoices[idString] = choices.GetData();
+        }
+    }
+
+    return choices;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPopulator::ToLongPCT( const wxString& s, long* pval, long max )
+{
+    if ( s.Last() == wxT('%') )
+    {
+        wxString s2 = s.substr(0,s.length()-1);
+        long val;
+        if ( s2.ToLong(&val, 10) )
+        {
+            *pval = (val*max)/100;
+            return true;
+        }
+        return false;
+    }
+
+    return s.ToLong(pval, 10);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPopulator::AddAttribute( const wxString& name,
+                                            const wxString& type,
+                                            const wxString& value )
+{
+    int l = m_propHierarchy.size();
+    if ( !l )
+        return false;
+
+    wxPGProperty* p = m_propHierarchy[l-1];
+    wxString valuel = value.Lower();
+    wxVariant variant;
+
+    if ( type.length() == 0 )
+    {
+        long v;
+
+        // Auto-detect type
+        if ( valuel == wxT("true") || valuel == wxT("yes") || valuel == wxT("1") )
+            variant = true;
+        else if ( valuel == wxT("false") || valuel == wxT("no") || valuel == wxT("0") )
+            variant = false;
+        else if ( value.ToLong(&v, 0) )
+            variant = v;
+        else
+            variant = value;
+    }
+    else
+    {
+        if ( type == wxT("string") )
+        {
+            variant = value;
+        }
+        else if ( type == wxT("int") )
+        {
+            long v = 0;
+            value.ToLong(&v, 0);
+            variant = v;
+        }
+        else if ( type == wxT("bool") )
+        {
+            if ( valuel == wxT("true") || valuel == wxT("yes") || valuel == wxT("1") )
+                variant = true;
+            else
+                variant = false;
+        }
+        else
+        {
+            ProcessError(wxString::Format(wxT("Invalid attribute type '%s'"),type.c_str()));
+            return false;
+        }
+    }
+
+    p->SetAttribute( name, variant );
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPopulator::ProcessError( const wxString& msg )
+{
+    wxLogError(_("Error in resource: %s"),msg.c_str());
+}
+
+// -----------------------------------------------------------------------
+
+#endif  // wxUSE_PROPGRID
Index: propgridiface.cpp
===================================================================
--- propgridiface.cpp	(revision 102)
+++ propgridiface.cpp	(working copy)
@@ -1,1278 +1,1278 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/propgridiface.cpp
-// Purpose:     wxPropertyGridInterface class
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2008-08-24
-// RCS-ID:      $Id: propgridiface.cpp 59320 2009-03-04 19:53:34Z JMS $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcmemory.h"
-    #include "wx/button.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/settings.h"
-    #include "wx/sizer.h"
-    #include "wx/intl.h"
-#endif
-
-#include "wx/propgrid/property.h"
-#include "wx/propgrid/propgrid.h"
-
-
-const wxChar *wxPGTypeName_long = wxT("long");
-const wxChar *wxPGTypeName_bool = wxT("bool");
-const wxChar *wxPGTypeName_double = wxT("double");
-const wxChar *wxPGTypeName_wxString = wxT("string");
-const wxChar *wxPGTypeName_void = wxT("void*");
-const wxChar *wxPGTypeName_wxArrayString = wxT("arrstring");
-
-
-// ----------------------------------------------------------------------------
-// VariantDatas
-// ----------------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED(wxPoint, WXDLLIMPEXP_PROPGRID)
-WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED(wxSize, WXDLLIMPEXP_PROPGRID)
-WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED_DUMMY_EQ(wxArrayInt, WXDLLIMPEXP_PROPGRID)
-
-// For wxLongLong and wxULongLong have custom classname << variant
-// implementation for improved flexibility.
-WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED_NO_EQ_NO_GETTER(wxLongLong, WXDLLIMPEXP_PROPGRID)
-WX_PG_IMPLEMENT_VARIANT_DATA_EQ(wxLongLong, WXDLLIMPEXP_PROPGRID)
-WXDLLIMPEXP_PROPGRID wxLongLong& operator << ( wxLongLong &value, const wxVariant &variant )
-{
-    wxLongLong_t ll;
-    if ( !wxPGVariantToLongLong(variant, &ll) )
-    {
-        wxFAIL_MSG("Cannot convert to wxLongLong");
-    }
-    value = ll;
-    return value;
-}
-WXDLLIMPEXP_PROPGRID wxLongLong_t& operator << ( wxLongLong_t &value, const wxVariant &variant )
-{
-    if ( !wxPGVariantToLongLong(variant, &value) )
-    {
-        wxFAIL_MSG("Cannot convert to wxLongLong");
-    }
-    return value;
-}
-
-WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED_NO_EQ_NO_GETTER(wxULongLong, WXDLLIMPEXP_PROPGRID)
-WX_PG_IMPLEMENT_VARIANT_DATA_EQ(wxULongLong, WXDLLIMPEXP_PROPGRID)
-WXDLLIMPEXP_PROPGRID wxULongLong& operator << ( wxULongLong &value, const wxVariant &variant )
-{
-    wxULongLong_t ull;
-    if ( !wxPGVariantToULongLong(variant, &ull) )
-    {
-        wxFAIL_MSG("Cannot convert to wxULongLong");
-    }
-    value = ull;
-    return value;
-}
-WXDLLIMPEXP_PROPGRID wxULongLong_t& operator << ( wxULongLong_t &value, const wxVariant &variant )
-{
-    if ( !wxPGVariantToULongLong(variant, &value) )
-    {
-        wxFAIL_MSG("Cannot convert to wxULongLong");
-    }
-    return value;
-}
-
-IMPLEMENT_VARIANT_OBJECT_EXPORTED(wxFont, WXDLLIMPEXP_PROPGRID)
-
-// -----------------------------------------------------------------------
-// wxVariant helpers
-// -----------------------------------------------------------------------
-
-long wxPGVariantToInt( const wxVariant& variant, long defVal )
-{
-    if ( variant.IsNull() )
-        return defVal;
-
-    if ( variant.GetType() == wxS("long") )
-        return variant.GetLong();
-
-    if ( variant.GetType() == wxS("bool") )
-        return variant.GetBool() ? 1 : 0;
-
-    if ( variant.GetType() == wxS("wxLongLong") )
-    {
-        wxLongLong ll;
-        ll << variant;
-        if ( ll >= LONG_MAX )
-            return LONG_MAX;
-        else if ( ll <= LONG_MIN )
-            return LONG_MIN;
-        return ll.ToLong();
-    }
-
-    long l = defVal;
-
-    if ( variant.GetType() == wxPG_VARIANT_TYPE_STRING )
-        variant.GetString().ToLong(&l, 0);
-
-    return l;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPGVariantToLongLong( const wxVariant& variant, wxLongLong_t* pResult )
-{
-    if ( variant.IsNull() )
-        return false;
-
-    wxString variantType = variant.GetType();
-
-    if ( variantType == wxPG_VARIANT_TYPE_LONG )
-    {
-        *pResult = variant.GetLong();
-        return true;
-    }
-
-    if ( variantType == wxLongLong_VariantType )
-    {
-        // NOTE: << operator uses this functions, so we can't use it here
-        *pResult = wxLongLongRefFromVariant(variant).GetValue();
-        return true;
-    }
-
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPGVariantToULongLong( const wxVariant& variant, wxULongLong_t* pResult )
-{
-    if ( variant.IsNull() )
-        return false;
-
-    wxString variantType = variant.GetType();
-
-    if ( variantType == wxPG_VARIANT_TYPE_LONG )
-    {
-        *pResult = (unsigned long)variant.GetLong();
-        return true;
-    }
-
-    if ( variantType == wxULongLong_VariantType )
-    {
-        // NOTE: << operator uses this functions, so we can't use it here
-        *pResult = wxULongLongRefFromVariant(variant).GetValue();
-        return true;
-    }
-
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPGVariantToDouble( const wxVariant& variant, double* pResult )
-{
-    if ( variant.IsNull() )
-        return false;
-
-    wxString variantType = variant.GetType();
-
-    if ( variantType == wxPG_VARIANT_TYPE_DOUBLE )
-    {
-        *pResult = variant.GetDouble();
-        return true;
-    }
-
-    if ( variantType == wxPG_VARIANT_TYPE_LONG )
-    {
-        *pResult = (double)variant.GetLong();
-        return true;
-    }
-
-    if ( variantType == wxLongLong_VariantType )
-    {
-        wxLongLong ll;
-        ll << variant;
-        *pResult = ll.ToDouble();
-        return true;
-    }
-
-    if ( variantType == wxPG_VARIANT_TYPE_STRING )
-        if ( variant.GetString().ToDouble(pResult) )
-            return true;
-
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPGPropArgCls
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPGPropArgCls::GetPtr( wxPropertyGridInterface* iface ) const
-{
-    if ( m_flags == IsProperty )
-    {
-        wxASSERT_MSG( m_ptr.property, wxT("invalid property ptr") );
-        return m_ptr.property;
-    }
-    else if ( m_flags & IsWxString )
-        return iface->GetPropertyByNameA(*m_ptr.stringName);
-    else if ( m_flags & IsCharPtr )
-        return iface->GetPropertyByNameA(m_ptr.charName);
-#if wxUSE_WCHAR_T
-    else if ( m_flags & IsWCharPtr )
-        return iface->GetPropertyByNameA(m_ptr.wcharName);
-#endif
-
-    return NULL;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridInterface
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::RefreshGrid( wxPropertyGridPageState* state )
-{
-    if ( !state )
-        state = m_pState;
-
-    wxPropertyGrid* grid = state->GetGrid();
-    if ( grid->GetState() == state && !grid->IsFrozen() )
-    {
-        grid->Refresh();
-    }
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::Append( wxPGProperty* property )
-{
-    wxPGProperty* retp = m_pState->DoAppend(property);
-    
-    wxPropertyGrid* grid = m_pState->GetGrid();
-    if ( grid )
-        grid->RefreshGrid();
-
-    return retp;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::AppendIn( wxPGPropArg id, wxPGProperty* newproperty )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
-    wxPGProperty* pwc = (wxPGProperty*) p;
-    wxPGProperty* retp = m_pState->DoInsert(pwc, pwc->GetChildCount(), newproperty);
-    return retp;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::Insert( wxPGPropArg id, wxPGProperty* property )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
-    wxPGProperty* retp = m_pState->DoInsert(p->GetParent(), p->GetIndexInParent(), property);
-    RefreshGrid();
-    return retp;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::Insert( wxPGPropArg id, int index, wxPGProperty* newproperty )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
-    wxPGProperty* retp = m_pState->DoInsert((wxPGProperty*)p,index,newproperty);
-    RefreshGrid();
-    return retp;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::DeleteProperty( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    wxPropertyGridPageState* state = p->GetParentState();
-    wxPropertyGrid* grid = state->GetGrid();
-
-    if ( grid->GetState() == state )
-        grid->DoSelectProperty(NULL, wxPG_SEL_DELETING|wxPG_SEL_NOVALIDATE);
-
-    state->DoDelete( p, true );
-
-    RefreshGrid(state);
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::RemoveProperty( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
-
-    wxCHECK( !p->GetChildCount() || p->HasFlag(wxPG_PROP_AGGREGATE),
-             wxNullProperty);
-
-    wxPropertyGridPageState* state = p->GetParentState();
-    wxPropertyGrid* grid = state->GetGrid();
-
-    if ( grid->GetState() == state )
-    {
-        grid->DoSelectProperty(NULL,
-            wxPG_SEL_DELETING|wxPG_SEL_NOVALIDATE);
-    }
-
-    state->DoDelete( p, false );
-
-    // Mark the property as 'unattached'
-    p->m_parentState = NULL;
-    p->m_parent = NULL;
-
-    RefreshGrid(state);
-
-    return p;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::ReplaceProperty( wxPGPropArg id, wxPGProperty* property )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
-
-    wxPGProperty* replaced = p;
-    wxCHECK_MSG( replaced && property,
-                 wxNullProperty,
-                 wxT("NULL property") );
-    wxCHECK_MSG( !replaced->IsCategory(),
-                 wxNullProperty,
-                 wxT("cannot replace this type of property") );
-    wxCHECK_MSG( !m_pState->IsInNonCatMode(),
-                 wxNullProperty,
-                 wxT("cannot replace properties in alphabetic mode") );
-
-    // Get address to the slot
-    wxPGProperty* parent = replaced->GetParent();
-    int ind = replaced->GetIndexInParent();
-
-    wxPropertyGridPageState* state = replaced->GetParentState();
-    DeleteProperty(replaced); // Must use generic Delete
-    state->DoInsert(parent,ind,property);
-
-    return property;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridInterface property operations
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::ClearSelection( bool validation )
-{
-    int flags = 0;
-    if ( !validation )
-        flags |= wxPG_SEL_NOVALIDATE;
-
-    wxPropertyGridPageState* state = m_pState;
-
-    if ( state )
-    {
-        wxPropertyGrid* pg = state->GetGrid();
-        if ( pg->GetState() == state )
-            return pg->DoSelectProperty(NULL, flags);
-        else
-            state->SetSelection(NULL);
-    }
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::LimitPropertyEditing( wxPGPropArg id, bool limit )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    m_pState->DoLimitPropertyEditing(p, limit);
-    RefreshProperty(p);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::EnableProperty( wxPGPropArg id, bool enable )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-
-    wxPropertyGridPageState* state = p->GetParentState();
-    wxPropertyGrid* grid = state->GetGrid();
-
-    if ( enable )
-    {
-        if ( !(p->m_flags & wxPG_PROP_DISABLED) )
-            return false;
-
-        // If active, Set active Editor.
-        if ( grid->GetState() == state && p == grid->GetSelection() )
-            grid->DoSelectProperty( p, wxPG_SEL_FORCE );
-    }
-    else
-    {
-        if ( p->m_flags & wxPG_PROP_DISABLED )
-            return false;
-
-        // If active, Disable as active Editor.
-        if ( grid->GetState() == state && p == grid->GetSelection() )
-            grid->DoSelectProperty( p, wxPG_SEL_FORCE );
-    }
-
-    state->DoEnableProperty(p, enable);
-
-    RefreshProperty( p );
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::ExpandAll( bool doExpand )
-{
-    wxPropertyGridPageState* state = m_pState;
-
-    if ( !state->DoGetRoot()->GetChildCount() )
-        return true;
-
-    wxPropertyGrid* pg = state->GetGrid();
-
-    if ( GetSelection() && GetSelection() != state->DoGetRoot() &&
-         !doExpand )
-    {
-        pg->ClearSelection(false);
-    }
-
-    wxPGVIterator it;
-
-    for ( it = GetVIterator( wxPG_ITERATE_ALL ); !it.AtEnd(); it.Next() )
-    {
-        wxPGProperty* p = (wxPGProperty*) it.GetProperty();
-        if ( p->GetChildCount() )
-        {
-            if ( doExpand )
-            {
-                if ( !p->IsExpanded() )
-                {
-                    state->DoExpand(p);
-                }
-            }
-            else
-            {
-                if ( p->IsExpanded() )
-                {
-                    state->DoCollapse(p);
-                }
-            }
-        }
-    }
-
-    pg->RecalculateVirtualSize();
-
-    RefreshGrid();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::ClearModifiedStatus()
-{
-    unsigned int pageIndex = 0;
-
-    for (;;)
-    {
-        wxPropertyGridPageState* page = GetPageState(pageIndex);
-        if ( !page ) break;
-
-        page->DoGetRoot()->SetFlagRecursively(wxPG_PROP_MODIFIED, false);
-
-        pageIndex++;
-    }
-
-    // Update active editor control, if any
-    GetPropertyGrid()->RefreshEditor();
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridInterface property value setting and getting
-// -----------------------------------------------------------------------
-
-void wxPGGetFailed( const wxPGProperty* p, const wxString& typestr )
-{
-    wxPGTypeOperationFailed(p, typestr, wxS("Get"));
-}
-
-// -----------------------------------------------------------------------
-
-void wxPGTypeOperationFailed( const wxPGProperty* p,
-                              const wxString& typestr,
-                              const wxString& op )
-{
-    wxASSERT( p != NULL );
-    wxLogError( _("Type operation \"%s\" failed: Property labeled \"%s\" is of type \"%s\", NOT \"%s\"."),
-        op.c_str(), p->GetLabel().c_str(), p->GetValue().GetType().c_str(), typestr.c_str() );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropVal( wxPGPropArg id, wxVariant& value )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    if ( p )
-        p->SetValue(value);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropertyValueString( wxPGPropArg id, const wxString& value )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    if ( p )
-        m_pState->DoSetPropertyValueString(p, value);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetValidationFailureBehavior( int vfbFlags )
-{
-    GetPropertyGrid()->m_permanentValidationFailureBehavior = vfbFlags;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::GetPropertyByNameA( const wxString& name ) const
-{
-    wxPGProperty* p = GetPropertyByName(name);
-    wxASSERT_MSG(p,wxString::Format(wxT("no property with name '%s'"),name.c_str()));
-    return p;
-}
-
-// ----------------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::GetPropertyByLabel( const wxString& label ) const
-{
-    wxPGVIterator it;
-
-    for ( it = GetVIterator( wxPG_ITERATE_PROPERTIES ); !it.AtEnd(); it.Next() )
-    {
-        if ( it.GetProperty()->GetLabel() == label )
-            return it.GetProperty();
-    }
-
-    return wxNullProperty;
-}
-
-// ----------------------------------------------------------------------------
-
-void wxPropertyGridInterface::DoSetPropertyAttribute( wxPGPropArg id, const wxString& name,
-                                                      wxVariant& value, long argFlags )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    p->SetAttribute( name, value );
-
-    if ( argFlags & wxPG_RECURSE )
-    {
-        unsigned int i;
-        for ( i = 0; i < p->GetChildCount(); i++ )
-            DoSetPropertyAttribute(p->Item(i), name, value, argFlags);
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropertyAttributeAll( const wxString& attrName,
-                                                       wxVariant value )
-{
-    unsigned int pageIndex = 0;
-
-    for (;;)
-    {
-        wxPropertyGridPageState* page = GetPageState(pageIndex);
-        if ( !page ) break;
-
-        DoSetPropertyAttribute(page->DoGetRoot(), attrName, value, wxPG_RECURSE);
-
-        pageIndex++;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::GetPropertiesWithFlag( wxArrayPGProperty* targetArr,
-                                                     wxPGProperty::FlagType flags,
-                                                     bool inverse,
-                                                     int iterFlags ) const
-{
-    wxASSERT( targetArr );
-    wxPGVIterator it = GetVIterator( iterFlags );
-
-    for ( ;
-          !it.AtEnd();
-          it.Next() )
-    {
-        const wxPGProperty* property = it.GetProperty();
-
-        if ( !inverse )
-        {
-            if ( (property->GetFlags() & flags) == flags )
-                targetArr->push_back((wxPGProperty*)property);
-        }
-        else
-        {
-            if ( (property->GetFlags() & flags) != flags )
-                targetArr->push_back((wxPGProperty*)property);
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetBoolChoices( const wxString& trueChoice,
-                                                 const wxString& falseChoice )
-{
-    wxPGGlobalVars->m_boolChoices[0] = falseChoice;
-    wxPGGlobalVars->m_boolChoices[1] = trueChoice;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::DoGetPropertyByName( const wxString& name ) const
-{
-    return m_pState->BaseGetPropertyByName(name);
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridInterface::GetPropertyByName( const wxString& name,
-                                                             const wxString& subname ) const
-{
-    wxPGProperty* p = DoGetPropertyByName(name);
-    if ( !p || !p->GetChildCount() )
-        return wxNullProperty;
-
-    return p->GetPropertyByName(subname);
-}
-
-// -----------------------------------------------------------------------
-
-// Since GetPropertyByName is used *a lot*, this makes sense
-// since non-virtual method can be called with less code.
-wxPGProperty* wxPropertyGridInterface::GetPropertyByName( const wxString& name ) const
-{
-    wxPGProperty* p = DoGetPropertyByName(name);
-    if ( p )
-        return p;
-
-    // Check if its "Property.SubProperty" format
-    int pos = name.Find(wxT('.'));
-    if ( pos <= 0 )
-        return NULL;
-
-    return GetPropertyByName(name.substr(0,pos),
-                             name.substr(pos+1,name.length()-pos-1));
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::HideProperty( wxPGPropArg id, bool hide, int flags )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-
-    wxPropertyGrid* pg = m_pState->GetGrid();
-
-    if ( pg == p->GetGrid() )
-        return pg->DoHideProperty(p, hide, flags);
-    else
-        m_pState->DoHideProperty(p, hide, flags);
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::Collapse( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-    wxPropertyGrid* pg = p->GetGridIfDisplayed();
-    if ( pg )
-        return pg->DoCollapse(p);
-
-    return p->GetParentState()->DoCollapse(p);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::Expand( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-    wxPropertyGrid* pg = p->GetGridIfDisplayed();
-    if ( pg )
-        return pg->DoExpand(p);
-
-    return p->GetParentState()->DoExpand(p);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::Sort( int flags )
-{
-    wxPropertyGrid* pg = GetPropertyGrid();
-
-    pg->ClearSelection(false);
-
-    unsigned int pageIndex = 0;
-
-    for (;;)
-    {
-        wxPropertyGridPageState* page = GetPageState(pageIndex);
-        if ( !page ) break;
-        page->DoSort(flags);
-        pageIndex++;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropertyLabel( wxPGPropArg id, const wxString& newproplabel )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    p->SetLabel( newproplabel );
-
-    wxPropertyGridPageState* state = p->GetParentState();
-    wxPropertyGrid* pg = state->GetGrid();
-
-    if ( pg->HasFlag(wxPG_AUTO_SORT) )
-        pg->SortChildren(p->GetParent());
-
-    if ( pg->GetState() == state )
-    {
-        if ( pg->HasFlag(wxPG_AUTO_SORT) )
-            pg->Refresh();
-        else
-            pg->DrawItem( p );
-    }
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::SetPropertyMaxLength( wxPGPropArg id, int maxLen )
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-
-    wxPropertyGrid* pg = m_pState->GetGrid();
-
-    p->m_maxLen = (short) maxLen;
-
-    // Adjust control if selected currently
-    if ( pg == p->GetGrid() && p == m_pState->GetSelection() )
-    {
-        wxWindow* wnd = pg->GetEditorControl();
-        wxTextCtrl* tc = wxDynamicCast(wnd,wxTextCtrl);
-        if ( tc )
-            tc->SetMaxLength( maxLen );
-        else
-        // Not a text ctrl
-            return false;
-    }
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-void
-wxPropertyGridInterface::SetPropertyBackgroundColour( wxPGPropArg id,
-                                                      const wxColour& colour,
-                                                      bool recursively )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-    p->SetBackgroundColour( colour, recursively );
-    RefreshProperty( p );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropertyTextColour( wxPGPropArg id,
-                                                     const wxColour& colour,
-                                                     bool recursively )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-    p->SetTextColour( colour, recursively );
-    RefreshProperty( p );
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropertyColoursToDefault( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    p->m_cells.clear();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::SetPropertyCell( wxPGPropArg id,
-                                               int column,
-                                               const wxString& text,
-                                               const wxBitmap& bitmap,
-                                               const wxColour& fgCol,
-                                               const wxColour& bgCol )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-
-    wxPGCell& cell = p->GetCell(column);
-    if ( text.length() && text != wxPG_LABEL )
-        cell.SetText(text);
-    if ( bitmap.IsOk() )
-        cell.SetBitmap(bitmap);
-    if ( fgCol != wxNullColour )
-        cell.SetFgCol(fgCol);
-    if ( bgCol != wxNullColour )
-        cell.SetBgCol(bgCol);
-}
-
-// -----------------------------------------------------------------------
-// GetPropertyValueAsXXX methods
-
-#define IMPLEMENT_GET_VALUE(T,TRET,BIGNAME,DEFRETVAL) \
-TRET wxPropertyGridInterface::GetPropertyValueAs##BIGNAME( wxPGPropArg id ) const \
-{ \
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(DEFRETVAL) \
-    wxVariant value = p->GetValue(); \
-    if ( wxStrcmp(value.GetType(), wxPGTypeName_##T) != 0 ) \
-    { \
-        wxPGGetFailed(p,wxPGTypeName_##T); \
-        return (TRET)DEFRETVAL; \
-    } \
-    return (TRET)value.Get##BIGNAME(); \
-}
-
-// String is different than others.
-wxString wxPropertyGridInterface::GetPropertyValueAsString( wxPGPropArg id ) const
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxEmptyString)
-    return p->GetValueAsString(wxPG_FULL_VALUE);
-}
-
-bool wxPropertyGridInterface::GetPropertyValueAsBool( wxPGPropArg id ) const
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-    wxVariant value = p->GetValue();
-    if ( wxStrcmp(value.GetType(), wxPGTypeName_bool) == 0 )
-    {
-        return value.GetBool();
-    }
-    if ( wxStrcmp(value.GetType(), wxPGTypeName_long) == 0 )
-    {
-        return value.GetLong()?true:false;
-    }
-    wxPGGetFailed(p,wxPGTypeName_bool);
-    return false;
-}
-
-IMPLEMENT_GET_VALUE(long,long,Long,0)
-IMPLEMENT_GET_VALUE(double,double,Double,0.0)
-
-bool wxPropertyGridInterface::IsPropertyExpanded( wxPGPropArg id ) const
-{
-    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
-    return p->IsExpanded();
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridInterface wrappers
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::ChangePropertyValue( wxPGPropArg id, wxVariant newValue )
-{
-    return GetPropertyGrid()->ChangePropertyValue(id, newValue);
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::BeginAddChildren( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-    wxCHECK_RET( p->HasFlag(wxPG_PROP_AGGREGATE), wxT("only call on properties with fixed children") );
-    p->ClearFlag(wxPG_PROP_AGGREGATE);
-    p->SetFlag(wxPG_PROP_MISC_PARENT);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridInterface::EditorValidate()
-{
-    return GetPropertyGrid()->DoEditorValidate();
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridInterface::EndAddChildren( wxPGPropArg id )
-{
-    wxPG_PROP_ARG_CALL_PROLOG()
-    wxCHECK_RET( p->HasFlag(wxPG_PROP_MISC_PARENT), wxT("only call on properties for which BeginAddChildren was called prior") );
-    p->ClearFlag(wxPG_PROP_MISC_PARENT);
-    p->SetFlag(wxPG_PROP_AGGREGATE);
-}
-
-// -----------------------------------------------------------------------
-// wxPGVIterator_State
-// -----------------------------------------------------------------------
-
-// Default returned by wxPropertyGridInterface::GetVIterator().
-class wxPGVIteratorBase_State : public wxPGVIteratorBase
-{
-public:
-    wxPGVIteratorBase_State( wxPropertyGridPageState* state, int flags )
-    {
-        m_it.Init( state, flags );
-    }
-    virtual ~wxPGVIteratorBase_State() { }
-    virtual void Next() { m_it.Next(); }
-};
-
-wxPGVIterator wxPropertyGridInterface::GetVIterator( int flags ) const
-{
-    return wxPGVIterator( new wxPGVIteratorBase_State( m_pState, flags ) );
-}
-
-// -----------------------------------------------------------------------
-// wxPGEditableState related functions
-// -----------------------------------------------------------------------
-
-// EscapeDelimiters() changes ";" into "\;" and "|" into "\|"
-// in the input string.  This is an internal functions which is
-// used for saving states
-// NB: Similar function exists in aui/framemanager.cpp
-static wxString EscapeDelimiters(const wxString& s)
-{
-    wxString result;
-    result.Alloc(s.length());
-    const wxChar* ch = s.c_str();
-    while (*ch)
-    {
-        if (*ch == wxT(';') || *ch == wxT('|') || *ch == wxT(','))
-            result += wxT('\\');
-        result += *ch;
-        ++ch;
-    }
-    return result;
-}
-
-wxString wxPropertyGridInterface::SaveEditableState( int includedStates ) const
-{
-    wxString result;
-
-    //
-    // Save state on page basis
-    unsigned int pageIndex = 0;
-    wxArrayPtrVoid pageStates;
-
-    for (;;)
-    {
-        wxPropertyGridPageState* page = GetPageState(pageIndex);
-        if ( !page ) break;
-
-        pageStates.Add(page);
-
-        pageIndex++;
-    }
-
-    for ( pageIndex=0; pageIndex < pageStates.size(); pageIndex++ )
-    {
-        wxPropertyGridPageState* pageState = (wxPropertyGridPageState*) pageStates[pageIndex];
-
-        if ( includedStates & SelectionState )
-        {
-            wxString sel;
-            if ( pageState->GetSelection() )
-                sel = pageState->GetSelection()->GetName();
-            result += wxS("selection=");
-            result += EscapeDelimiters(sel);
-            result += wxS(";");
-        }
-        if ( includedStates & ExpandedState )
-        {
-            wxArrayPGProperty ptrs;
-            wxPropertyGridConstIterator it = 
-                wxPropertyGridConstIterator( pageState,
-                                             wxPG_ITERATE_ALL_PARENTS_RECURSIVELY|wxPG_ITERATE_HIDDEN,
-                                             wxNullProperty );
-
-            result += wxS("expanded=");
-
-            for ( ;
-                  !it.AtEnd();
-                  it.Next() )
-            {
-                const wxPGProperty* p = it.GetProperty();
-
-                if ( !p->HasFlag(wxPG_PROP_COLLAPSED) )
-                    result += EscapeDelimiters(p->GetName());
-                result += wxS(",");
-
-            }
-
-            if ( result.Last() == wxS(',') )
-                result.RemoveLast();
-
-            result += wxS(";");
-        }
-        if ( includedStates & ScrollPosState )
-        {
-            int x, y;
-            GetPropertyGrid()->GetViewStart(&x,&y);
-            result += wxString::Format(wxS("scrollpos=%i,%i;"), x, y);
-        }
-        if ( includedStates & SplitterPosState )
-        {
-            result += wxS("splitterpos=");
-
-            for ( size_t i=0; i<pageState->GetColumnCount(); i++ )
-                result += wxString::Format(wxS("%i,"), pageState->DoGetSplitterPosition(i));
-
-            result.RemoveLast();  // Remove last comma
-            result += wxS(";");
-        }
-        if ( includedStates & PageState )
-        {
-            result += wxS("ispageselected=");
-
-            if ( GetPageState(-1) == pageState )
-                result += wxS("1;");
-            else
-                result += wxS("0;");
-        }
-        if ( includedStates & DescBoxState )
-        {
-            wxVariant v = GetEditableStateItem(wxS("descboxheight"));
-            if ( !v.IsNull() )
-                result += wxString::Format(wxS("descboxheight=%i;"), (int)v.GetLong());
-        }
-        result.RemoveLast();  // Remove last semicolon
-        result += wxS("|");
-    }
-
-    // Remove last '|'
-    if ( result.length() )
-        result.RemoveLast();
-
-    return result;
-}
-
-bool wxPropertyGridInterface::RestoreEditableState( const wxString& src, int restoreStates )
-{
-    wxPropertyGrid* pg = GetPropertyGrid();
-    wxPGProperty* newSelection = NULL;
-    size_t pageIndex;
-    long vx = -1;
-    long vy = -1;
-    long selectedPage = -1;
-    bool pgSelectionSet = false;
-    bool res = true;
-
-    pg->Freeze();
-    wxArrayString pageStrings = ::wxSplit(src, wxS('|'), wxS('\\'));
-
-    for ( pageIndex=0; pageIndex<pageStrings.size(); pageIndex++ )
-    {
-        wxPropertyGridPageState* pageState = GetPageState(pageIndex);
-        if ( !pageState )
-            break;
-
-        wxArrayString kvpairStrings = ::wxSplit(pageStrings[pageIndex], wxS(';'), wxS('\\'));
-
-        for ( size_t i=0; i<kvpairStrings.size(); i++ )
-        {
-            const wxString& kvs = kvpairStrings[i];
-            int eq_pos = kvs.Find(wxS('='));
-            if ( eq_pos != wxNOT_FOUND )
-            {
-                wxString key = kvs.substr(0, eq_pos);
-                wxString value = kvs.substr(eq_pos+1);
-
-                // Further split value by commas
-                wxArrayString values = ::wxSplit(value, wxS(','), wxS('\\'));
-
-                if ( key == wxS("expanded") )
-                {
-                    if ( restoreStates & ExpandedState )
-                    {
-                        wxPropertyGridIterator it = 
-                            wxPropertyGridIterator( pageState,
-                                                    wxPG_ITERATE_ALL,
-                                                    wxNullProperty );
-
-                        // First collapse all
-                        for ( ; !it.AtEnd(); it.Next() )
-                        {
-                            wxPGProperty* p = it.GetProperty();
-                            pageState->DoCollapse(p);
-                        }
-
-                        // Then expand those which names are in values
-                        for ( size_t n=0; n<values.size(); n++ )
-                        {
-                            const wxString& name = values[n];
-                            wxPGProperty* prop = GetPropertyByName(name);
-                            if ( prop )
-                                pageState->DoExpand(prop);
-                        }
-                    }
-                }
-                else if ( key == wxS("scrollpos") )
-                {
-                    if ( restoreStates & ScrollPosState )
-                    {
-                        if ( values.size() == 2 )
-                        {
-                            values[0].ToLong(&vx);
-                            values[1].ToLong(&vy);
-                        }
-                        else
-                        {
-                            res = false;
-                        }
-                    }
-                }
-                else if ( key == wxS("splitterpos") )
-                {
-                    if ( restoreStates & SplitterPosState )
-                    {
-                        for ( size_t n=1; n<values.size(); n++ )
-                        {
-                            long pos = 0;
-                            values[n].ToLong(&pos);
-                            if ( pos > 0 )
-                                pageState->DoSetSplitterPosition(pos, n);
-                        }
-                    }
-                }
-                else if ( key == wxS("selection") )
-                {
-                    if ( restoreStates & SelectionState )
-                    {
-                        if ( values.size() > 0 )
-                        {
-                            if ( pageState->IsDisplayed() )
-                            {
-                                if ( values[0].length() )
-                                    newSelection = GetPropertyByName(value);
-                                pgSelectionSet = true;
-                            }
-                            else
-                            {
-                                if ( values[0].length() )
-                                    pageState->SetSelection(GetPropertyByName(value));
-                                else
-                                    pageState->DoClearSelection();
-                            }
-                        }
-                    }
-                }
-                else if ( key == wxS("ispageselected") )
-                {
-                    if ( restoreStates & PageState )
-                    {
-                        long pageSelStatus;
-                        if ( values.size() == 1 && values[0].ToLong(&pageSelStatus) )
-                        {
-                            if ( pageSelStatus )
-                                selectedPage = pageIndex;
-                        }
-                        else
-                        {
-                            res = false;
-                        }
-                    }
-                }
-                else if ( key == wxS("descboxheight") )
-                {
-                    if ( restoreStates & DescBoxState )
-                    {
-                        long descBoxHeight;
-                        if ( values.size() == 1 && values[0].ToLong(&descBoxHeight) )
-                        {
-                            SetEditableStateItem(wxS("descboxheight"), descBoxHeight);
-                        }
-                        else
-                        {
-                            res = false;
-                        }
-                    }
-                }
-                else
-                {
-                    res = false;
-                }
-            }
-        }
-    }
-
-    //
-    // Force recalculation of virtual heights of all pages
-    // (may be needed on unclean source string).
-    pageIndex = 0;
-    wxPropertyGridPageState* pageState = GetPageState(pageIndex);
-    while ( pageState )
-    {
-        pageState->VirtualHeightChanged();
-        pageIndex += 1;
-        pageState = GetPageState(pageIndex);
-    }
-
-    pg->Thaw();
-
-    //
-    // Selection of visible grid page must be set after Thaw() call
-    if ( pgSelectionSet )
-    {
-        if ( newSelection )
-            pg->SelectProperty(newSelection);
-        else
-            pg->ClearSelection();
-    }
-
-    if ( selectedPage != -1 )
-    {
-        DoSelectPage(selectedPage);
-    }
-
-    if ( vx >= 0 )
-    {
-        pg->Scroll(vx, vy);
-    }
-
-    return res;
-}
-
-#endif  // wxUSE_PROPGRID
-
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/propgridiface.cpp
+// Purpose:     wxPropertyGridInterface class
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2008-08-24
+// RCS-ID:      $Id: propgridiface.cpp 59320 2009-03-04 19:53:34Z JMS $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcmemory.h"
+    #include "wx/button.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/settings.h"
+    #include "wx/sizer.h"
+    #include "wx/intl.h"
+#endif
+
+#include "wx/propgrid/property.h"
+#include "wx/propgrid/propgrid.h"
+
+
+const wxChar *wxPGTypeName_long = wxT("long");
+const wxChar *wxPGTypeName_bool = wxT("bool");
+const wxChar *wxPGTypeName_double = wxT("double");
+const wxChar *wxPGTypeName_wxString = wxT("string");
+const wxChar *wxPGTypeName_void = wxT("void*");
+const wxChar *wxPGTypeName_wxArrayString = wxT("arrstring");
+
+
+// ----------------------------------------------------------------------------
+// VariantDatas
+// ----------------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED(wxPoint, WXDLLIMPEXP_PROPGRID)
+WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED(wxSize, WXDLLIMPEXP_PROPGRID)
+WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED_DUMMY_EQ(wxArrayInt, WXDLLIMPEXP_PROPGRID)
+
+// For wxLongLong and wxULongLong have custom classname << variant
+// implementation for improved flexibility.
+WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED_NO_EQ_NO_GETTER(wxLongLong, WXDLLIMPEXP_PROPGRID)
+WX_PG_IMPLEMENT_VARIANT_DATA_EQ(wxLongLong, WXDLLIMPEXP_PROPGRID)
+WXDLLIMPEXP_PROPGRID wxLongLong& operator << ( wxLongLong &value, const wxVariant &variant )
+{
+    wxLongLong_t ll;
+    if ( !wxPGVariantToLongLong(variant, &ll) )
+    {
+        wxFAIL_MSG("Cannot convert to wxLongLong");
+    }
+    value = ll;
+    return value;
+}
+WXDLLIMPEXP_PROPGRID wxLongLong_t& operator << ( wxLongLong_t &value, const wxVariant &variant )
+{
+    if ( !wxPGVariantToLongLong(variant, &value) )
+    {
+        wxFAIL_MSG("Cannot convert to wxLongLong");
+    }
+    return value;
+}
+
+WX_PG_IMPLEMENT_VARIANT_DATA_EXPORTED_NO_EQ_NO_GETTER(wxULongLong, WXDLLIMPEXP_PROPGRID)
+WX_PG_IMPLEMENT_VARIANT_DATA_EQ(wxULongLong, WXDLLIMPEXP_PROPGRID)
+WXDLLIMPEXP_PROPGRID wxULongLong& operator << ( wxULongLong &value, const wxVariant &variant )
+{
+    wxULongLong_t ull;
+    if ( !wxPGVariantToULongLong(variant, &ull) )
+    {
+        wxFAIL_MSG("Cannot convert to wxULongLong");
+    }
+    value = ull;
+    return value;
+}
+WXDLLIMPEXP_PROPGRID wxULongLong_t& operator << ( wxULongLong_t &value, const wxVariant &variant )
+{
+    if ( !wxPGVariantToULongLong(variant, &value) )
+    {
+        wxFAIL_MSG("Cannot convert to wxULongLong");
+    }
+    return value;
+}
+
+IMPLEMENT_VARIANT_OBJECT_EXPORTED(wxFont, WXDLLIMPEXP_PROPGRID)
+
+// -----------------------------------------------------------------------
+// wxVariant helpers
+// -----------------------------------------------------------------------
+
+long wxPGVariantToInt( const wxVariant& variant, long defVal )
+{
+    if ( variant.IsNull() )
+        return defVal;
+
+    if ( variant.GetType() == wxS("long") )
+        return variant.GetLong();
+
+    if ( variant.GetType() == wxS("bool") )
+        return variant.GetBool() ? 1 : 0;
+
+    if ( variant.GetType() == wxS("wxLongLong") )
+    {
+        wxLongLong ll;
+        ll << variant;
+        if ( ll >= LONG_MAX )
+            return LONG_MAX;
+        else if ( ll <= LONG_MIN )
+            return LONG_MIN;
+        return ll.ToLong();
+    }
+
+    long l = defVal;
+
+    if ( variant.GetType() == wxPG_VARIANT_TYPE_STRING )
+        variant.GetString().ToLong(&l, 0);
+
+    return l;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPGVariantToLongLong( const wxVariant& variant, wxLongLong_t* pResult )
+{
+    if ( variant.IsNull() )
+        return false;
+
+    wxString variantType = variant.GetType();
+
+    if ( variantType == wxPG_VARIANT_TYPE_LONG )
+    {
+        *pResult = variant.GetLong();
+        return true;
+    }
+
+    if ( variantType == wxLongLong_VariantType )
+    {
+        // NOTE: << operator uses this functions, so we can't use it here
+        *pResult = wxLongLongRefFromVariant(variant).GetValue();
+        return true;
+    }
+
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPGVariantToULongLong( const wxVariant& variant, wxULongLong_t* pResult )
+{
+    if ( variant.IsNull() )
+        return false;
+
+    wxString variantType = variant.GetType();
+
+    if ( variantType == wxPG_VARIANT_TYPE_LONG )
+    {
+        *pResult = (unsigned long)variant.GetLong();
+        return true;
+    }
+
+    if ( variantType == wxULongLong_VariantType )
+    {
+        // NOTE: << operator uses this functions, so we can't use it here
+        *pResult = wxULongLongRefFromVariant(variant).GetValue();
+        return true;
+    }
+
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPGVariantToDouble( const wxVariant& variant, double* pResult )
+{
+    if ( variant.IsNull() )
+        return false;
+
+    wxString variantType = variant.GetType();
+
+    if ( variantType == wxPG_VARIANT_TYPE_DOUBLE )
+    {
+        *pResult = variant.GetDouble();
+        return true;
+    }
+
+    if ( variantType == wxPG_VARIANT_TYPE_LONG )
+    {
+        *pResult = (double)variant.GetLong();
+        return true;
+    }
+
+    if ( variantType == wxLongLong_VariantType )
+    {
+        wxLongLong ll;
+        ll << variant;
+        *pResult = ll.ToDouble();
+        return true;
+    }
+
+    if ( variantType == wxPG_VARIANT_TYPE_STRING )
+        if ( variant.GetString().ToDouble(pResult) )
+            return true;
+
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPGPropArgCls
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPGPropArgCls::GetPtr( wxPropertyGridInterface* iface ) const
+{
+    if ( m_flags == IsProperty )
+    {
+        wxASSERT_MSG( m_ptr.property, wxT("invalid property ptr") );
+        return m_ptr.property;
+    }
+    else if ( m_flags & IsWxString )
+        return iface->GetPropertyByNameA(*m_ptr.stringName);
+    else if ( m_flags & IsCharPtr )
+        return iface->GetPropertyByNameA(m_ptr.charName);
+#if wxUSE_WCHAR_T
+    else if ( m_flags & IsWCharPtr )
+        return iface->GetPropertyByNameA(m_ptr.wcharName);
+#endif
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridInterface
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::RefreshGrid( wxPropertyGridPageState* state )
+{
+    if ( !state )
+        state = m_pState;
+
+    wxPropertyGrid* grid = state->GetGrid();
+    if ( grid->GetState() == state && !grid->IsFrozen() )
+    {
+        grid->Refresh();
+    }
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::Append( wxPGProperty* property )
+{
+    wxPGProperty* retp = m_pState->DoAppend(property);
+    
+    wxPropertyGrid* grid = m_pState->GetGrid();
+    if ( grid )
+        grid->RefreshGrid();
+
+    return retp;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::AppendIn( wxPGPropArg id, wxPGProperty* newproperty )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
+    wxPGProperty* pwc = (wxPGProperty*) p;
+    wxPGProperty* retp = m_pState->DoInsert(pwc, pwc->GetChildCount(), newproperty);
+    return retp;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::Insert( wxPGPropArg id, wxPGProperty* property )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
+    wxPGProperty* retp = m_pState->DoInsert(p->GetParent(), p->GetIndexInParent(), property);
+    RefreshGrid();
+    return retp;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::Insert( wxPGPropArg id, int index, wxPGProperty* newproperty )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
+    wxPGProperty* retp = m_pState->DoInsert((wxPGProperty*)p,index,newproperty);
+    RefreshGrid();
+    return retp;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::DeleteProperty( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    wxPropertyGridPageState* state = p->GetParentState();
+    wxPropertyGrid* grid = state->GetGrid();
+
+    if ( grid->GetState() == state )
+        grid->DoSelectProperty(NULL, wxPG_SEL_DELETING|wxPG_SEL_NOVALIDATE);
+
+    state->DoDelete( p, true );
+
+    RefreshGrid(state);
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::RemoveProperty( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
+
+    wxCHECK( !p->GetChildCount() || p->HasFlag(wxPG_PROP_AGGREGATE),
+             wxNullProperty);
+
+    wxPropertyGridPageState* state = p->GetParentState();
+    wxPropertyGrid* grid = state->GetGrid();
+
+    if ( grid->GetState() == state )
+    {
+        grid->DoSelectProperty(NULL,
+            wxPG_SEL_DELETING|wxPG_SEL_NOVALIDATE);
+    }
+
+    state->DoDelete( p, false );
+
+    // Mark the property as 'unattached'
+    p->m_parentState = NULL;
+    p->m_parent = NULL;
+
+    RefreshGrid(state);
+
+    return p;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::ReplaceProperty( wxPGPropArg id, wxPGProperty* property )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxNullProperty)
+
+    wxPGProperty* replaced = p;
+    wxCHECK_MSG( replaced && property,
+                 wxNullProperty,
+                 wxT("NULL property") );
+    wxCHECK_MSG( !replaced->IsCategory(),
+                 wxNullProperty,
+                 wxT("cannot replace this type of property") );
+    wxCHECK_MSG( !m_pState->IsInNonCatMode(),
+                 wxNullProperty,
+                 wxT("cannot replace properties in alphabetic mode") );
+
+    // Get address to the slot
+    wxPGProperty* parent = replaced->GetParent();
+    int ind = replaced->GetIndexInParent();
+
+    wxPropertyGridPageState* state = replaced->GetParentState();
+    DeleteProperty(replaced); // Must use generic Delete
+    state->DoInsert(parent,ind,property);
+
+    return property;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridInterface property operations
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::ClearSelection( bool validation )
+{
+    int flags = 0;
+    if ( !validation )
+        flags |= wxPG_SEL_NOVALIDATE;
+
+    wxPropertyGridPageState* state = m_pState;
+
+    if ( state )
+    {
+        wxPropertyGrid* pg = state->GetGrid();
+        if ( pg->GetState() == state )
+            return pg->DoSelectProperty(NULL, flags);
+        else
+            state->SetSelection(NULL);
+    }
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::LimitPropertyEditing( wxPGPropArg id, bool limit )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    m_pState->DoLimitPropertyEditing(p, limit);
+    RefreshProperty(p);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::EnableProperty( wxPGPropArg id, bool enable )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+
+    wxPropertyGridPageState* state = p->GetParentState();
+    wxPropertyGrid* grid = state->GetGrid();
+
+    if ( enable )
+    {
+        if ( !(p->m_flags & wxPG_PROP_DISABLED) )
+            return false;
+
+        // If active, Set active Editor.
+        if ( grid->GetState() == state && p == grid->GetSelection() )
+            grid->DoSelectProperty( p, wxPG_SEL_FORCE );
+    }
+    else
+    {
+        if ( p->m_flags & wxPG_PROP_DISABLED )
+            return false;
+
+        // If active, Disable as active Editor.
+        if ( grid->GetState() == state && p == grid->GetSelection() )
+            grid->DoSelectProperty( p, wxPG_SEL_FORCE );
+    }
+
+    state->DoEnableProperty(p, enable);
+
+    RefreshProperty( p );
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::ExpandAll( bool doExpand )
+{
+    wxPropertyGridPageState* state = m_pState;
+
+    if ( !state->DoGetRoot()->GetChildCount() )
+        return true;
+
+    wxPropertyGrid* pg = state->GetGrid();
+
+    if ( GetSelection() && GetSelection() != state->DoGetRoot() &&
+         !doExpand )
+    {
+        pg->ClearSelection(false);
+    }
+
+    wxPGVIterator it;
+
+    for ( it = GetVIterator( wxPG_ITERATE_ALL ); !it.AtEnd(); it.Next() )
+    {
+        wxPGProperty* p = (wxPGProperty*) it.GetProperty();
+        if ( p->GetChildCount() )
+        {
+            if ( doExpand )
+            {
+                if ( !p->IsExpanded() )
+                {
+                    state->DoExpand(p);
+                }
+            }
+            else
+            {
+                if ( p->IsExpanded() )
+                {
+                    state->DoCollapse(p);
+                }
+            }
+        }
+    }
+
+    pg->RecalculateVirtualSize();
+
+    RefreshGrid();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::ClearModifiedStatus()
+{
+    unsigned int pageIndex = 0;
+
+    for (;;)
+    {
+        wxPropertyGridPageState* page = GetPageState(pageIndex);
+        if ( !page ) break;
+
+        page->DoGetRoot()->SetFlagRecursively(wxPG_PROP_MODIFIED, false);
+
+        pageIndex++;
+    }
+
+    // Update active editor control, if any
+    GetPropertyGrid()->RefreshEditor();
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridInterface property value setting and getting
+// -----------------------------------------------------------------------
+
+void wxPGGetFailed( const wxPGProperty* p, const wxString& typestr )
+{
+    wxPGTypeOperationFailed(p, typestr, wxS("Get"));
+}
+
+// -----------------------------------------------------------------------
+
+void wxPGTypeOperationFailed( const wxPGProperty* p,
+                              const wxString& typestr,
+                              const wxString& op )
+{
+    wxASSERT( p != NULL );
+    wxLogError( _("Type operation \"%s\" failed: Property labeled \"%s\" is of type \"%s\", NOT \"%s\"."),
+        op.c_str(), p->GetLabel().c_str(), p->GetValue().GetType().c_str(), typestr.c_str() );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropVal( wxPGPropArg id, wxVariant& value )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    if ( p )
+        p->SetValue(value);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropertyValueString( wxPGPropArg id, const wxString& value )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    if ( p )
+        m_pState->DoSetPropertyValueString(p, value);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetValidationFailureBehavior( int vfbFlags )
+{
+    GetPropertyGrid()->m_permanentValidationFailureBehavior = vfbFlags;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::GetPropertyByNameA( const wxString& name ) const
+{
+    wxPGProperty* p = GetPropertyByName(name);
+    wxASSERT_MSG(p,wxString::Format(wxT("no property with name '%s'"),name.c_str()));
+    return p;
+}
+
+// ----------------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::GetPropertyByLabel( const wxString& label ) const
+{
+    wxPGVIterator it;
+
+    for ( it = GetVIterator( wxPG_ITERATE_PROPERTIES ); !it.AtEnd(); it.Next() )
+    {
+        if ( it.GetProperty()->GetLabel() == label )
+            return it.GetProperty();
+    }
+
+    return wxNullProperty;
+}
+
+// ----------------------------------------------------------------------------
+
+void wxPropertyGridInterface::DoSetPropertyAttribute( wxPGPropArg id, const wxString& name,
+                                                      wxVariant& value, long argFlags )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    p->SetAttribute( name, value );
+
+    if ( argFlags & wxPG_RECURSE )
+    {
+        unsigned int i;
+        for ( i = 0; i < p->GetChildCount(); i++ )
+            DoSetPropertyAttribute(p->Item(i), name, value, argFlags);
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropertyAttributeAll( const wxString& attrName,
+                                                       wxVariant value )
+{
+    unsigned int pageIndex = 0;
+
+    for (;;)
+    {
+        wxPropertyGridPageState* page = GetPageState(pageIndex);
+        if ( !page ) break;
+
+        DoSetPropertyAttribute(page->DoGetRoot(), attrName, value, wxPG_RECURSE);
+
+        pageIndex++;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::GetPropertiesWithFlag( wxArrayPGProperty* targetArr,
+                                                     wxPGProperty::FlagType flags,
+                                                     bool inverse,
+                                                     int iterFlags ) const
+{
+    wxASSERT( targetArr );
+    wxPGVIterator it = GetVIterator( iterFlags );
+
+    for ( ;
+          !it.AtEnd();
+          it.Next() )
+    {
+        const wxPGProperty* property = it.GetProperty();
+
+        if ( !inverse )
+        {
+            if ( (property->GetFlags() & flags) == flags )
+                targetArr->push_back((wxPGProperty*)property);
+        }
+        else
+        {
+            if ( (property->GetFlags() & flags) != flags )
+                targetArr->push_back((wxPGProperty*)property);
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetBoolChoices( const wxString& trueChoice,
+                                                 const wxString& falseChoice )
+{
+    wxPGGlobalVars->m_boolChoices[0] = falseChoice;
+    wxPGGlobalVars->m_boolChoices[1] = trueChoice;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::DoGetPropertyByName( const wxString& name ) const
+{
+    return m_pState->BaseGetPropertyByName(name);
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridInterface::GetPropertyByName( const wxString& name,
+                                                             const wxString& subname ) const
+{
+    wxPGProperty* p = DoGetPropertyByName(name);
+    if ( !p || !p->GetChildCount() )
+        return wxNullProperty;
+
+    return p->GetPropertyByName(subname);
+}
+
+// -----------------------------------------------------------------------
+
+// Since GetPropertyByName is used *a lot*, this makes sense
+// since non-virtual method can be called with less code.
+wxPGProperty* wxPropertyGridInterface::GetPropertyByName( const wxString& name ) const
+{
+    wxPGProperty* p = DoGetPropertyByName(name);
+    if ( p )
+        return p;
+
+    // Check if its "Property.SubProperty" format
+    int pos = name.Find(wxT('.'));
+    if ( pos <= 0 )
+        return NULL;
+
+    return GetPropertyByName(name.substr(0,pos),
+                             name.substr(pos+1,name.length()-pos-1));
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::HideProperty( wxPGPropArg id, bool hide, int flags )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+
+    wxPropertyGrid* pg = m_pState->GetGrid();
+
+    if ( pg == p->GetGrid() )
+        return pg->DoHideProperty(p, hide, flags);
+    else
+        m_pState->DoHideProperty(p, hide, flags);
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::Collapse( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+    wxPropertyGrid* pg = p->GetGridIfDisplayed();
+    if ( pg )
+        return pg->DoCollapse(p);
+
+    return p->GetParentState()->DoCollapse(p);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::Expand( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+    wxPropertyGrid* pg = p->GetGridIfDisplayed();
+    if ( pg )
+        return pg->DoExpand(p);
+
+    return p->GetParentState()->DoExpand(p);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::Sort( int flags )
+{
+    wxPropertyGrid* pg = GetPropertyGrid();
+
+    pg->ClearSelection(false);
+
+    unsigned int pageIndex = 0;
+
+    for (;;)
+    {
+        wxPropertyGridPageState* page = GetPageState(pageIndex);
+        if ( !page ) break;
+        page->DoSort(flags);
+        pageIndex++;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropertyLabel( wxPGPropArg id, const wxString& newproplabel )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    p->SetLabel( newproplabel );
+
+    wxPropertyGridPageState* state = p->GetParentState();
+    wxPropertyGrid* pg = state->GetGrid();
+
+    if ( pg->HasFlag(wxPG_AUTO_SORT) )
+        pg->SortChildren(p->GetParent());
+
+    if ( pg->GetState() == state )
+    {
+        if ( pg->HasFlag(wxPG_AUTO_SORT) )
+            pg->Refresh();
+        else
+            pg->DrawItem( p );
+    }
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::SetPropertyMaxLength( wxPGPropArg id, int maxLen )
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+
+    wxPropertyGrid* pg = m_pState->GetGrid();
+
+    p->m_maxLen = (short) maxLen;
+
+    // Adjust control if selected currently
+    if ( pg == p->GetGrid() && p == m_pState->GetSelection() )
+    {
+        wxWindow* wnd = pg->GetEditorControl();
+        wxTextCtrl* tc = wxDynamicCast(wnd,wxTextCtrl);
+        if ( tc )
+            tc->SetMaxLength( maxLen );
+        else
+        // Not a text ctrl
+            return false;
+    }
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+void
+wxPropertyGridInterface::SetPropertyBackgroundColour( wxPGPropArg id,
+                                                      const wxColour& colour,
+                                                      bool recursively )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+    p->SetBackgroundColour( colour, recursively );
+    RefreshProperty( p );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropertyTextColour( wxPGPropArg id,
+                                                     const wxColour& colour,
+                                                     bool recursively )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+    p->SetTextColour( colour, recursively );
+    RefreshProperty( p );
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropertyColoursToDefault( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    p->m_cells.clear();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::SetPropertyCell( wxPGPropArg id,
+                                               int column,
+                                               const wxString& text,
+                                               const wxBitmap& bitmap,
+                                               const wxColour& fgCol,
+                                               const wxColour& bgCol )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+
+    wxPGCell& cell = p->GetCell(column);
+    if ( text.length() && text != wxPG_LABEL )
+        cell.SetText(text);
+    if ( bitmap.IsOk() )
+        cell.SetBitmap(bitmap);
+    if ( fgCol != wxNullColour )
+        cell.SetFgCol(fgCol);
+    if ( bgCol != wxNullColour )
+        cell.SetBgCol(bgCol);
+}
+
+// -----------------------------------------------------------------------
+// GetPropertyValueAsXXX methods
+
+#define IMPLEMENT_GET_VALUE(T,TRET,BIGNAME,DEFRETVAL) \
+TRET wxPropertyGridInterface::GetPropertyValueAs##BIGNAME( wxPGPropArg id ) const \
+{ \
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(DEFRETVAL) \
+    wxVariant value = p->GetValue(); \
+    if ( wxStrcmp(value.GetType(), wxPGTypeName_##T) != 0 ) \
+    { \
+        wxPGGetFailed(p,wxPGTypeName_##T); \
+        return (TRET)DEFRETVAL; \
+    } \
+    return (TRET)value.Get##BIGNAME(); \
+}
+
+// String is different than others.
+wxString wxPropertyGridInterface::GetPropertyValueAsString( wxPGPropArg id ) const
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(wxEmptyString)
+    return p->GetValueAsString(wxPG_FULL_VALUE);
+}
+
+bool wxPropertyGridInterface::GetPropertyValueAsBool( wxPGPropArg id ) const
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+    wxVariant value = p->GetValue();
+    if ( wxStrcmp(value.GetType(), wxPGTypeName_bool) == 0 )
+    {
+        return value.GetBool();
+    }
+    if ( wxStrcmp(value.GetType(), wxPGTypeName_long) == 0 )
+    {
+        return value.GetLong()?true:false;
+    }
+    wxPGGetFailed(p,wxPGTypeName_bool);
+    return false;
+}
+
+IMPLEMENT_GET_VALUE(long,long,Long,0)
+IMPLEMENT_GET_VALUE(double,double,Double,0.0)
+
+bool wxPropertyGridInterface::IsPropertyExpanded( wxPGPropArg id ) const
+{
+    wxPG_PROP_ARG_CALL_PROLOG_RETVAL(false)
+    return p->IsExpanded();
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridInterface wrappers
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::ChangePropertyValue( wxPGPropArg id, wxVariant newValue )
+{
+    return GetPropertyGrid()->ChangePropertyValue(id, newValue);
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::BeginAddChildren( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+    wxCHECK_RET( p->HasFlag(wxPG_PROP_AGGREGATE), wxT("only call on properties with fixed children") );
+    p->ClearFlag(wxPG_PROP_AGGREGATE);
+    p->SetFlag(wxPG_PROP_MISC_PARENT);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridInterface::EditorValidate()
+{
+    return GetPropertyGrid()->DoEditorValidate();
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridInterface::EndAddChildren( wxPGPropArg id )
+{
+    wxPG_PROP_ARG_CALL_PROLOG()
+    wxCHECK_RET( p->HasFlag(wxPG_PROP_MISC_PARENT), wxT("only call on properties for which BeginAddChildren was called prior") );
+    p->ClearFlag(wxPG_PROP_MISC_PARENT);
+    p->SetFlag(wxPG_PROP_AGGREGATE);
+}
+
+// -----------------------------------------------------------------------
+// wxPGVIterator_State
+// -----------------------------------------------------------------------
+
+// Default returned by wxPropertyGridInterface::GetVIterator().
+class wxPGVIteratorBase_State : public wxPGVIteratorBase
+{
+public:
+    wxPGVIteratorBase_State( wxPropertyGridPageState* state, int flags )
+    {
+        m_it.Init( state, flags );
+    }
+    virtual ~wxPGVIteratorBase_State() { }
+    virtual void Next() { m_it.Next(); }
+};
+
+wxPGVIterator wxPropertyGridInterface::GetVIterator( int flags ) const
+{
+    return wxPGVIterator( new wxPGVIteratorBase_State( m_pState, flags ) );
+}
+
+// -----------------------------------------------------------------------
+// wxPGEditableState related functions
+// -----------------------------------------------------------------------
+
+// EscapeDelimiters() changes ";" into "\;" and "|" into "\|"
+// in the input string.  This is an internal functions which is
+// used for saving states
+// NB: Similar function exists in aui/framemanager.cpp
+static wxString EscapeDelimiters(const wxString& s)
+{
+    wxString result;
+    result.Alloc(s.length());
+    const wxChar* ch = s.c_str();
+    while (*ch)
+    {
+        if (*ch == wxT(';') || *ch == wxT('|') || *ch == wxT(','))
+            result += wxT('\\');
+        result += *ch;
+        ++ch;
+    }
+    return result;
+}
+
+wxString wxPropertyGridInterface::SaveEditableState( int includedStates ) const
+{
+    wxString result;
+
+    //
+    // Save state on page basis
+    unsigned int pageIndex = 0;
+    wxArrayPtrVoid pageStates;
+
+    for (;;)
+    {
+        wxPropertyGridPageState* page = GetPageState(pageIndex);
+        if ( !page ) break;
+
+        pageStates.Add(page);
+
+        pageIndex++;
+    }
+
+    for ( pageIndex=0; pageIndex < pageStates.size(); pageIndex++ )
+    {
+        wxPropertyGridPageState* pageState = (wxPropertyGridPageState*) pageStates[pageIndex];
+
+        if ( includedStates & SelectionState )
+        {
+            wxString sel;
+            if ( pageState->GetSelection() )
+                sel = pageState->GetSelection()->GetName();
+            result += wxS("selection=");
+            result += EscapeDelimiters(sel);
+            result += wxS(";");
+        }
+        if ( includedStates & ExpandedState )
+        {
+            wxArrayPGProperty ptrs;
+            wxPropertyGridConstIterator it = 
+                wxPropertyGridConstIterator( pageState,
+                                             wxPG_ITERATE_ALL_PARENTS_RECURSIVELY|wxPG_ITERATE_HIDDEN,
+                                             wxNullProperty );
+
+            result += wxS("expanded=");
+
+            for ( ;
+                  !it.AtEnd();
+                  it.Next() )
+            {
+                const wxPGProperty* p = it.GetProperty();
+
+                if ( !p->HasFlag(wxPG_PROP_COLLAPSED) )
+                    result += EscapeDelimiters(p->GetName());
+                result += wxS(",");
+
+            }
+
+            if ( result.Last() == wxS(',') )
+                result.RemoveLast();
+
+            result += wxS(";");
+        }
+        if ( includedStates & ScrollPosState )
+        {
+            int x, y;
+            GetPropertyGrid()->GetViewStart(&x,&y);
+            result += wxString::Format(wxS("scrollpos=%i,%i;"), x, y);
+        }
+        if ( includedStates & SplitterPosState )
+        {
+            result += wxS("splitterpos=");
+
+            for ( size_t i=0; i<pageState->GetColumnCount(); i++ )
+                result += wxString::Format(wxS("%i,"), pageState->DoGetSplitterPosition(i));
+
+            result.RemoveLast();  // Remove last comma
+            result += wxS(";");
+        }
+        if ( includedStates & PageState )
+        {
+            result += wxS("ispageselected=");
+
+            if ( GetPageState(-1) == pageState )
+                result += wxS("1;");
+            else
+                result += wxS("0;");
+        }
+        if ( includedStates & DescBoxState )
+        {
+            wxVariant v = GetEditableStateItem(wxS("descboxheight"));
+            if ( !v.IsNull() )
+                result += wxString::Format(wxS("descboxheight=%i;"), (int)v.GetLong());
+        }
+        result.RemoveLast();  // Remove last semicolon
+        result += wxS("|");
+    }
+
+    // Remove last '|'
+    if ( result.length() )
+        result.RemoveLast();
+
+    return result;
+}
+
+bool wxPropertyGridInterface::RestoreEditableState( const wxString& src, int restoreStates )
+{
+    wxPropertyGrid* pg = GetPropertyGrid();
+    wxPGProperty* newSelection = NULL;
+    size_t pageIndex;
+    long vx = -1;
+    long vy = -1;
+    long selectedPage = -1;
+    bool pgSelectionSet = false;
+    bool res = true;
+
+    pg->Freeze();
+    wxArrayString pageStrings = ::wxSplit(src, wxS('|'), wxS('\\'));
+
+    for ( pageIndex=0; pageIndex<pageStrings.size(); pageIndex++ )
+    {
+        wxPropertyGridPageState* pageState = GetPageState(pageIndex);
+        if ( !pageState )
+            break;
+
+        wxArrayString kvpairStrings = ::wxSplit(pageStrings[pageIndex], wxS(';'), wxS('\\'));
+
+        for ( size_t i=0; i<kvpairStrings.size(); i++ )
+        {
+            const wxString& kvs = kvpairStrings[i];
+            int eq_pos = kvs.Find(wxS('='));
+            if ( eq_pos != wxNOT_FOUND )
+            {
+                wxString key = kvs.substr(0, eq_pos);
+                wxString value = kvs.substr(eq_pos+1);
+
+                // Further split value by commas
+                wxArrayString values = ::wxSplit(value, wxS(','), wxS('\\'));
+
+                if ( key == wxS("expanded") )
+                {
+                    if ( restoreStates & ExpandedState )
+                    {
+                        wxPropertyGridIterator it = 
+                            wxPropertyGridIterator( pageState,
+                                                    wxPG_ITERATE_ALL,
+                                                    wxNullProperty );
+
+                        // First collapse all
+                        for ( ; !it.AtEnd(); it.Next() )
+                        {
+                            wxPGProperty* p = it.GetProperty();
+                            pageState->DoCollapse(p);
+                        }
+
+                        // Then expand those which names are in values
+                        for ( size_t n=0; n<values.size(); n++ )
+                        {
+                            const wxString& name = values[n];
+                            wxPGProperty* prop = GetPropertyByName(name);
+                            if ( prop )
+                                pageState->DoExpand(prop);
+                        }
+                    }
+                }
+                else if ( key == wxS("scrollpos") )
+                {
+                    if ( restoreStates & ScrollPosState )
+                    {
+                        if ( values.size() == 2 )
+                        {
+                            values[0].ToLong(&vx);
+                            values[1].ToLong(&vy);
+                        }
+                        else
+                        {
+                            res = false;
+                        }
+                    }
+                }
+                else if ( key == wxS("splitterpos") )
+                {
+                    if ( restoreStates & SplitterPosState )
+                    {
+                        for ( size_t n=1; n<values.size(); n++ )
+                        {
+                            long pos = 0;
+                            values[n].ToLong(&pos);
+                            if ( pos > 0 )
+                                pageState->DoSetSplitterPosition(pos, n);
+                        }
+                    }
+                }
+                else if ( key == wxS("selection") )
+                {
+                    if ( restoreStates & SelectionState )
+                    {
+                        if ( values.size() > 0 )
+                        {
+                            if ( pageState->IsDisplayed() )
+                            {
+                                if ( values[0].length() )
+                                    newSelection = GetPropertyByName(value);
+                                pgSelectionSet = true;
+                            }
+                            else
+                            {
+                                if ( values[0].length() )
+                                    pageState->SetSelection(GetPropertyByName(value));
+                                else
+                                    pageState->DoClearSelection();
+                            }
+                        }
+                    }
+                }
+                else if ( key == wxS("ispageselected") )
+                {
+                    if ( restoreStates & PageState )
+                    {
+                        long pageSelStatus;
+                        if ( values.size() == 1 && values[0].ToLong(&pageSelStatus) )
+                        {
+                            if ( pageSelStatus )
+                                selectedPage = pageIndex;
+                        }
+                        else
+                        {
+                            res = false;
+                        }
+                    }
+                }
+                else if ( key == wxS("descboxheight") )
+                {
+                    if ( restoreStates & DescBoxState )
+                    {
+                        long descBoxHeight;
+                        if ( values.size() == 1 && values[0].ToLong(&descBoxHeight) )
+                        {
+                            SetEditableStateItem(wxS("descboxheight"), descBoxHeight);
+                        }
+                        else
+                        {
+                            res = false;
+                        }
+                    }
+                }
+                else
+                {
+                    res = false;
+                }
+            }
+        }
+    }
+
+    //
+    // Force recalculation of virtual heights of all pages
+    // (may be needed on unclean source string).
+    pageIndex = 0;
+    wxPropertyGridPageState* pageState = GetPageState(pageIndex);
+    while ( pageState )
+    {
+        pageState->VirtualHeightChanged();
+        pageIndex += 1;
+        pageState = GetPageState(pageIndex);
+    }
+
+    pg->Thaw();
+
+    //
+    // Selection of visible grid page must be set after Thaw() call
+    if ( pgSelectionSet )
+    {
+        if ( newSelection )
+            pg->SelectProperty(newSelection);
+        else
+            pg->ClearSelection();
+    }
+
+    if ( selectedPage != -1 )
+    {
+        DoSelectPage(selectedPage);
+    }
+
+    if ( vx >= 0 )
+    {
+        pg->Scroll(vx, vy);
+    }
+
+    return res;
+}
+
+#endif  // wxUSE_PROPGRID
+
Index: propgridpagestate.cpp
===================================================================
--- propgridpagestate.cpp	(revision 102)
+++ propgridpagestate.cpp	(working copy)
@@ -1,1794 +1,1794 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/propgridpagestate.cpp
-// Purpose:     wxPropertyGridPageState class
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2008-08-24
-// RCS-ID:      $Id: propgridpagestate.cpp 59725 2009-03-22 12:53:48Z VZ $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcmemory.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/intl.h"
-    #include "wx/stopwatch.h"
-#endif
-
-// This define is necessary to prevent macro clearing
-#define __wxPG_SOURCE_FILE__
-
-#include "wx/propgrid/propgridpagestate.h"
-#include "wx/propgrid/propgrid.h"
-#include "wx/propgrid/editors.h"
-
-#define wxPG_DEFAULT_SPLITTERX      110
-
-
-// -----------------------------------------------------------------------
-// wxPropertyGridIterator
-// -----------------------------------------------------------------------
-
-void wxPropertyGridIteratorBase::Init( wxPropertyGridPageState* state, int flags, wxPGProperty* property, int dir  )
-{
-    wxASSERT( dir == 1 || dir == -1 );
-
-    m_state = state;
-    m_baseParent = state->DoGetRoot();
-    if ( !property && m_baseParent->GetChildCount() )
-        property = m_baseParent->Item(0);
-
-    m_property = property;
-
-    wxPG_ITERATOR_CREATE_MASKS(flags, m_itemExMask, m_parentExMask)
-
-    // Need to skip first?
-    if ( property && (property->GetFlags() & m_itemExMask) )
-    {
-        if ( dir == 1 )
-            Next();
-        else
-            Prev();
-    }
-}
-
-void wxPropertyGridIteratorBase::Init( wxPropertyGridPageState* state, int flags, int startPos, int dir  )
-{
-    wxPGProperty* property = NULL;
-
-    if ( startPos == wxTOP )
-    {
-        if ( dir == 0 )
-            dir = 1;
-    }
-    else if ( startPos == wxBOTTOM )
-    {
-        property = state->GetLastItem(flags);
-        if ( dir == 0 )
-            dir = -1;
-    }
-    else
-    {
-        wxFAIL_MSG("Only supported starting positions are wxTOP and wxBOTTOM");
-    }
-
-    Init( state, flags, property, dir );
-}
-
-void wxPropertyGridIteratorBase::Assign( const wxPropertyGridIteratorBase& it )
-{
-    m_property = it.m_property;
-    m_state = it.m_state;
-    m_baseParent = it.m_baseParent;
-    m_itemExMask = it.m_itemExMask;
-    m_parentExMask = it.m_parentExMask;
-}
-
-void wxPropertyGridIteratorBase::Prev()
-{
-    wxPGProperty* property = m_property;
-    wxASSERT( property );
-
-    wxPGProperty* parent = property->GetParent();
-    wxASSERT( parent );
-    unsigned int index = property->GetIndexInParent();
-
-    if ( index > 0 )
-    {
-        // Previous sibling
-        index--;
-
-        property = parent->Item(index);
-
-        // Go to last children?
-        if ( property->GetChildCount() &&
-             wxPG_ITERATOR_PARENTEXMASK_TEST(property, m_parentExMask) )
-        {
-            // First child
-            property = property->Last();
-        }
-    }
-    else
-    {
-        // Up to a parent
-        if ( parent == m_baseParent )
-        {
-            m_property = NULL;
-            return;
-        }
-        else
-        {
-            property = parent;
-        }
-    }
-
-    m_property = property;
-
-    // If property does not match our criteria, skip it
-    if ( property->GetFlags() & m_itemExMask )
-        Prev();
-}
-
-void wxPropertyGridIteratorBase::Next( bool iterateChildren )
-{
-    wxPGProperty* property = m_property;
-    wxASSERT( property );
-
-    if ( property->GetChildCount() &&
-         wxPG_ITERATOR_PARENTEXMASK_TEST(property, m_parentExMask) &&
-         iterateChildren )
-    {
-        // First child
-        property = property->Item(0);
-    }
-    else
-    {
-        wxPGProperty* parent = property->GetParent();
-        wxASSERT( parent );
-        unsigned int index = property->GetIndexInParent() + 1;
-
-        if ( index < parent->GetChildCount() )
-        {
-            // Next sibling
-            property = parent->Item(index);
-        }
-        else
-        {
-            // Next sibling of parent
-            if ( parent == m_baseParent )
-            {
-                m_property = NULL;
-            }
-            else
-            {
-                m_property = parent;
-                Next(false);
-            }
-            return;
-        }
-    }
-
-    m_property = property;
-
-    // If property does not match our criteria, skip it
-    if ( property->GetFlags() & m_itemExMask )
-        Next();
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState
-// -----------------------------------------------------------------------
-
-wxPropertyGridPageState::wxPropertyGridPageState()
-{
-    m_pPropGrid = NULL;
-    m_regularArray.SetParentState(this);
-    m_properties = &m_regularArray;
-    m_abcArray = NULL;
-    m_currentCategory = NULL;
-    m_selected = NULL;
-    m_width = 0;
-    m_virtualHeight = 0;
-    m_lastCaptionBottomnest = 1;
-    m_itemsAdded = 0;
-    m_anyModified = 0;
-    m_vhCalcPending = 0;
-    m_colWidths.push_back( wxPG_DEFAULT_SPLITTERX );
-    m_colWidths.push_back( wxPG_DEFAULT_SPLITTERX );
-    m_fSplitterX = wxPG_DEFAULT_SPLITTERX;
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridPageState::~wxPropertyGridPageState()
-{
-    delete m_abcArray;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::InitNonCatMode()
-{
-    if ( !m_abcArray )
-    {
-        m_abcArray = new wxPGRootProperty(wxS("<Root_NonCat>"));
-        m_abcArray->SetParentState(this);
-        m_abcArray->SetFlag(wxPG_PROP_CHILDREN_ARE_COPIES);
-    }
-
-    // Must be called when state::m_properties still points to regularArray.
-    wxPGProperty* oldProperties = m_properties;
-
-    // Must use temp value in state::m_properties for item iteration loop
-    // to run as expected.
-    m_properties = &m_regularArray;
-
-    if ( m_properties->GetChildCount() )
-    {
-        //
-        // Prepare m_abcArray
-        wxPropertyGridIterator it( this, wxPG_ITERATE_PROPERTIES );
-
-        for ( ; !it.AtEnd(); it.Next() )
-        {
-            wxPGProperty* p = it.GetProperty();
-            wxPGProperty* parent = p->GetParent();
-            if ( parent->IsCategory() || parent->IsRoot() )
-            {
-                m_abcArray->DoAddChild(p);
-                p->m_parent = &m_regularArray;
-            }
-        }
-    }
-
-    m_properties = oldProperties;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::DoClear()
-{
-    if ( m_pPropGrid && m_pPropGrid->GetState() == this  )
-    {
-        m_pPropGrid->ClearSelection(false);
-    }
-    else
-    {
-        m_selected = NULL;
-    }
-
-    m_regularArray.Empty();
-    if ( m_abcArray )
-        m_abcArray->Empty();
-
-    m_dictName.clear();
-
-    m_currentCategory = NULL;
-    m_lastCaptionBottomnest = 1;
-    m_itemsAdded = 0;
-
-    m_virtualHeight = 0;
-    m_vhCalcPending = 0;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::CalculateFontAndBitmapStuff( int WXUNUSED(vspacing) )
-{
-    wxPropertyGrid* propGrid = GetGrid();
-
-    VirtualHeightChanged();
-
-    // Recalculate caption text extents.
-    unsigned int i;
-
-    for ( i=0;i<m_regularArray.GetChildCount();i++ )
-    {
-        wxPGProperty* p =m_regularArray.Item(i);
-
-        if ( p->IsCategory() )
-            ((wxPropertyCategory*)p)->CalculateTextExtent(propGrid, propGrid->GetCaptionFont());
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::SetVirtualWidth( int width )
-{
-    wxASSERT( width >= 0 );
-    wxPropertyGrid* pg = GetGrid();
-    int gw = pg->GetClientSize().x;
-    if ( width < gw )
-        width = gw;
-
-    m_width = width;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::OnClientWidthChange( int newWidth, int widthChange, bool fromOnResize )
-{
-    wxPropertyGrid* pg = GetGrid();
-
-    if ( pg->HasVirtualWidth() )
-    {
-        if ( m_width < newWidth )
-            SetVirtualWidth( newWidth );
-
-        CheckColumnWidths(widthChange);
-    }
-    else
-    {
-        SetVirtualWidth( newWidth );
-
-        // This should be done before splitter auto centering
-        // NOTE: Splitter auto-centering is done in this function.
-        if ( !fromOnResize )
-            widthChange = 0;
-        CheckColumnWidths(widthChange);
-
-        if ( !(GetGrid()->GetInternalFlags() & wxPG_FL_SPLITTER_PRE_SET) &&
-             (GetGrid()->GetInternalFlags() & wxPG_FL_DONT_CENTER_SPLITTER) )
-        {
-            long timeSinceCreation = (::wxGetLocalTimeMillis() - GetGrid()->m_timeCreated).ToLong();
-
-            // If too long, don't set splitter
-            if ( timeSinceCreation < 3000 )
-            {
-                if ( m_properties->GetChildCount() || timeSinceCreation > 750 )
-                {
-                    SetSplitterLeft( false );
-                }
-                else
-                {
-                    DoSetSplitterPosition( newWidth / 2 );
-                    GetGrid()->ClearInternalFlag(wxPG_FL_SPLITTER_PRE_SET);
-                }
-            }
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState item iteration methods
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPageState::GetLastItem( int flags )
-{
-    if ( !m_properties->GetChildCount() )
-        return NULL;
-
-    wxPG_ITERATOR_CREATE_MASKS(flags, int itemExMask, int parentExMask)
-
-    // First, get last child of last parent
-    wxPGProperty* pwc = (wxPGProperty*)m_properties->Last();
-    while ( pwc->GetChildCount() &&
-            wxPG_ITERATOR_PARENTEXMASK_TEST(pwc, parentExMask) )
-        pwc = (wxPGProperty*) pwc->Last();
-
-    // Then, if it doesn't fit our criteria, back up until we find something that does
-    if ( pwc->GetFlags() & itemExMask )
-    {
-        wxPropertyGridIterator it( this, flags, pwc );
-        for ( ; !it.AtEnd(); it.Prev() )
-            ;
-        pwc = (wxPGProperty*) it.GetProperty();
-    }
-
-    return pwc;
-}
-
-wxPropertyCategory* wxPropertyGridPageState::GetPropertyCategory( const wxPGProperty* p ) const
-{
-    const wxPGProperty* parent = (const wxPGProperty*)p;
-    const wxPGProperty* grandparent = (const wxPGProperty*)parent->GetParent();
-    do
-    {
-        parent = grandparent;
-        grandparent = (wxPGProperty*)parent->GetParent();
-        if ( parent->IsCategory() && grandparent )
-            return (wxPropertyCategory*)parent;
-    } while ( grandparent );
-
-    return NULL;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState GetPropertyXXX methods
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPageState::GetPropertyByLabel( const wxString& label,
-                                                           wxPGProperty* parent ) const
-{
-
-    size_t i;
-
-    if ( !parent ) parent = (wxPGProperty*) &m_regularArray;
-
-    for ( i=0; i<parent->GetChildCount(); i++ )
-    {
-        wxPGProperty* p = parent->Item(i);
-        if ( p->m_label == label )
-            return p;
-        // Check children recursively.
-        if ( p->GetChildCount() )
-        {
-            p = GetPropertyByLabel(label,(wxPGProperty*)p);
-            if ( p )
-                return p;
-        }
-    }
-
-    return NULL;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPageState::BaseGetPropertyByName( const wxString& name ) const
-{
-    wxPGHashMapS2P::const_iterator it;
-    it = m_dictName.find(name);
-    if ( it != m_dictName.end() )
-        return (wxPGProperty*) it->second;
-    return NULL;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::DoSetPropertyName( wxPGProperty* p,
-                                                 const wxString& newName )
-{
-    wxCHECK_RET( p, wxT("invalid property id") );
-
-    wxPGProperty* parent = p->GetParent();
-
-    if ( parent->IsCategory() || parent->IsRoot() )
-    {
-        if ( p->GetBaseName().length() )
-            m_dictName.erase( p->GetBaseName() );
-        if ( newName.length() )
-            m_dictName[newName] = (void*) p;
-    }
-
-    p->DoSetName(newName);
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState global operations
-// -----------------------------------------------------------------------
-
-// -----------------------------------------------------------------------
-// Item iteration macros
-//   NB: Nowadays only needed for alphabetic/categoric mode switching.
-// -----------------------------------------------------------------------
-
-//#define II_INVALID_I    0x00FFFFFF
-
-#define ITEM_ITERATION_VARIABLES \
-    wxPGProperty* parent; \
-    unsigned int i; \
-    unsigned int iMax;
-
-#define ITEM_ITERATION_INIT_FROM_THE_TOP \
-    parent = m_properties; \
-    i = 0;
-
-#if 0
-#define ITEM_ITERATION_INIT(startparent, startindex, state) \
-    parent = startparent; \
-    i = (unsigned int)startindex; \
-    if ( parent == NULL ) \
-    { \
-        parent = state->m_properties; \
-        i = 0; \
-    }
-#endif
-
-#define ITEM_ITERATION_LOOP_BEGIN \
-    do \
-    { \
-        iMax = parent->GetChildCount(); \
-        while ( i < iMax ) \
-        {  \
-            wxPGProperty* p = parent->Item(i);
-
-#define ITEM_ITERATION_LOOP_END \
-            if ( p->GetChildCount() ) \
-            { \
-                i = 0; \
-                parent = (wxPGProperty*)p; \
-                iMax = parent->GetChildCount(); \
-            } \
-            else \
-                i++; \
-        } \
-        i = parent->m_arrIndex + 1; \
-        parent = parent->m_parent; \
-    } \
-    while ( parent != NULL );
-
-bool wxPropertyGridPageState::EnableCategories( bool enable )
-{
-    //
-    // NB: We can't use wxPropertyGridIterator in this
-    //     function, since it depends on m_arrIndexes,
-    //     which, among other things, is being fixed here.
-    //
-    ITEM_ITERATION_VARIABLES
-
-    if ( enable )
-    {
-        //
-        // Enable categories
-        //
-
-        if ( !IsInNonCatMode() )
-            return false;
-
-        m_properties = &m_regularArray;
-
-        // fix parents, indexes, and depths
-        ITEM_ITERATION_INIT_FROM_THE_TOP
-
-        ITEM_ITERATION_LOOP_BEGIN
-
-            p->m_arrIndex = i;
-
-            p->m_parent = parent;
-
-            // If parent was category, and this is not,
-            // then the depth stays the same.
-            if ( parent->IsCategory() &&
-                 !p->IsCategory() )
-                p->m_depth = parent->m_depth;
-            else
-                p->m_depth = parent->m_depth + 1;
-
-        ITEM_ITERATION_LOOP_END
-
-    }
-    else
-    {
-        //
-        // Disable categories
-        //
-
-        if ( IsInNonCatMode() )
-            return false;
-
-        // Create array, if necessary.
-        if ( !m_abcArray )
-            InitNonCatMode();
-
-        m_properties = m_abcArray;
-
-        // fix parents, indexes, and depths
-        ITEM_ITERATION_INIT_FROM_THE_TOP
-
-        ITEM_ITERATION_LOOP_BEGIN
-
-            p->m_arrIndex = i;
-
-            p->m_parent = parent;
-
-            p->m_depth = parent->m_depth + 1;
-
-        ITEM_ITERATION_LOOP_END
-    }
-
-    VirtualHeightChanged();
-
-    if ( m_pPropGrid->GetState() == this )
-        m_pPropGrid->RecalculateVirtualSize();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-#if wxUSE_STL
-#include <algorithm>
-
-static bool wxPG_SortFunc_ByFunction(wxPGProperty *p1, wxPGProperty *p2)
-{
-    wxPropertyGrid* pg = p1->GetGrid();
-    wxPGSortCallback sortFunction = pg->GetSortFunction();
-    return sortFunction(pg, p1, p2) < 0;
-}
-
-static bool wxPG_SortFunc_ByLabel(wxPGProperty *p1, wxPGProperty *p2)
-{
-    return p1->GetLabel().CmpNoCase( p2->GetLabel() ) < 0;
-}
-
-#else
-
-static int wxPG_SortFunc_ByFunction(wxPGProperty **pp1, wxPGProperty **pp2)
-{
-    wxPGProperty *p1 = *pp1;
-    wxPGProperty *p2 = *pp2;
-    wxPropertyGrid* pg = p1->GetGrid();
-    wxPGSortCallback sortFunction = pg->GetSortFunction();
-    return sortFunction(pg, p1, p2);
-}
-
-static int wxPG_SortFunc_ByLabel(wxPGProperty **pp1, wxPGProperty **pp2)
-{
-    wxPGProperty *p1 = *pp1;
-    wxPGProperty *p2 = *pp2;
-    return p1->GetLabel().CmpNoCase( p2->GetLabel() );
-}
-
-#endif
-
-void wxPropertyGridPageState::DoSortChildren( wxPGProperty* p,
-                                              int flags )
-{
-    if ( !p )
-        p = m_properties;
-
-    // Can only sort items with children
-    if ( !p->GetChildCount() )
-        return;
-
-    // Never sort children of aggregate properties
-    if ( p->HasFlag(wxPG_PROP_AGGREGATE) )
-        return;
-
-    if ( (flags & wxPG_SORT_TOP_LEVEL_ONLY)
-         && !p->IsCategory() && !p->IsRoot() )
-        return;
-
-#if wxUSE_STL
-    if ( GetGrid()->GetSortFunction() )
-        std::sort(p->m_children.begin(), p->m_children.end(),
-                  wxPG_SortFunc_ByFunction);
-    else
-        std::sort(p->m_children.begin(), p->m_children.end(),
-                  wxPG_SortFunc_ByLabel);
-#else
-    if ( GetGrid()->GetSortFunction() )
-        p->m_children.Sort( wxPG_SortFunc_ByFunction );
-    else
-        p->m_children.Sort( wxPG_SortFunc_ByLabel );
-#endif
-
-    // Fix indices
-    p->FixIndicesOfChildren();
-
-    if ( flags & wxPG_RECURSE )
-    {
-        // Apply sort recursively
-        for ( unsigned int i=0; i<p->GetChildCount(); i++ )
-            DoSortChildren(p->Item(i), flags);
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::DoSort( int flags )
-{
-    DoSortChildren( m_properties, flags | wxPG_RECURSE );
-
-    // We used to sort categories as well here also if in non-categorized
-    // mode, but doing would naturally cause child indices to become
-    // corrupted.
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::PrepareAfterItemsAdded()
-{
-    if ( !m_itemsAdded ) return false;
-
-    wxPropertyGrid* pg = GetGrid();
-
-    m_itemsAdded = 0;
-
-    if ( pg->HasFlag(wxPG_AUTO_SORT) )
-        DoSort(wxPG_SORT_TOP_LEVEL_ONLY);
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState splitter, column and hittest functions
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPageState::DoGetItemAtY( int y ) const
-{
-    // Outside?
-    if ( y < 0 )
-        return NULL;
-
-    unsigned int a = 0;
-    return m_properties->GetItemAtY(y, GetGrid()->m_lineHeight, &a);
-}
-
-// -----------------------------------------------------------------------
-
-wxPropertyGridHitTestResult wxPropertyGridPageState::HitTest( const wxPoint&pt ) const
-{
-    wxPropertyGridHitTestResult result;
-    result.column = HitTestH( pt.x, &result.splitter, &result.splitterHitOffset );
-    result.property = DoGetItemAtY( pt.y );
-    return result;
-}
-
-// -----------------------------------------------------------------------
-
-// Used by SetSplitterLeft() and DotFitColumns()
-int wxPropertyGridPageState::GetColumnFitWidth(wxClientDC& dc,
-                                           wxPGProperty* pwc,
-                                           unsigned int col,
-                                           bool subProps) const
-{
-    wxPropertyGrid* pg = m_pPropGrid;
-    size_t i;
-    int maxW = 0;
-    int w, h;
-
-    for ( i=0; i<pwc->GetChildCount(); i++ )
-    {
-        wxPGProperty* p = pwc->Item(i);
-        if ( !p->IsCategory() )
-        {
-            const wxPGCell* cell = NULL;
-            wxString text;
-            p->GetDisplayInfo(col, -1, 0, &text, &cell);
-            dc.GetTextExtent(text, &w, &h);
-            if ( col == 0 )
-                w += ( ((int)p->m_depth-1) * pg->m_subgroup_extramargin );
-
-            //
-            // TODO: Add bitmap support.
-
-            w += (wxPG_XBEFORETEXT*2);
-
-            if ( w > maxW )
-                maxW = w;
-        }
-
-        if ( p->GetChildCount() &&
-             ( subProps || p->IsCategory() ) )
-        {
-            w = GetColumnFitWidth( dc, p, col, subProps );
-
-            if ( w > maxW )
-                maxW = w;
-        }
-    }
-
-    return maxW;
-}
-
-int wxPropertyGridPageState::DoGetSplitterPosition( int splitterColumn ) const
-{
-    int n = GetGrid()->m_marginWidth;
-    int i;
-    for ( i=0; i<=splitterColumn; i++ )
-        n += m_colWidths[i];
-    return n;
-}
-
-int wxPropertyGridPageState::GetColumnMinWidth( int WXUNUSED(column) ) const
-{
-    return wxPG_DRAG_MARGIN;
-}
-
-void wxPropertyGridPageState::PropagateColSizeDec( int column, int decrease, int dir )
-{
-    int origWidth = m_colWidths[column];
-    m_colWidths[column] -= decrease;
-    int min = GetColumnMinWidth(column);
-    int more = 0;
-    if ( m_colWidths[column] < min )
-    {
-        more = decrease - (origWidth - min);
-        m_colWidths[column] = min;
-    }
-
-    //
-    // FIXME: Causes erratic splitter changing, so as a workaround
-    //        disabled if two or less columns.
-
-    if ( m_colWidths.size() <= 2 )
-        return;
-
-    column += dir;
-    if ( more && column < (int)m_colWidths.size() && column >= 0 )
-        PropagateColSizeDec( column, more, dir );
-}
-
-void wxPropertyGridPageState::DoSetSplitterPosition( int newXPos, int splitterColumn, bool WXUNUSED(allPages), bool fromAutoCenter )
-{
-    wxPropertyGrid* pg = GetGrid();
-
-    int adjust = newXPos - DoGetSplitterPosition(splitterColumn);
-
-    if ( !pg->HasVirtualWidth() )
-    {
-        // No virtual width
-        int otherColumn;
-        if ( adjust > 0 )
-        {
-            otherColumn = splitterColumn + 1;
-            if ( otherColumn == (int)m_colWidths.size() )
-                otherColumn = 0;
-            m_colWidths[splitterColumn] += adjust;
-            PropagateColSizeDec( otherColumn, adjust, 1 );
-        }
-        else
-        {
-            otherColumn = splitterColumn + 1;
-            if ( otherColumn == (int)m_colWidths.size() )
-                otherColumn = 0;
-            m_colWidths[otherColumn] -= adjust;
-            PropagateColSizeDec( splitterColumn, -adjust, -1 );
-        }
-    }
-    else
-    {
-        m_colWidths[splitterColumn] += adjust;
-    }
-
-    if ( splitterColumn == 0 )
-        m_fSplitterX = (double) newXPos;
-
-    if ( !fromAutoCenter )
-    {
-        // Don't allow initial splitter auto-positioning after this.
-        if ( pg->GetState() == this )
-            pg->SetInternalFlag(wxPG_FL_SPLITTER_PRE_SET);
-
-        CheckColumnWidths();
-    }
-}
-
-// Moves splitter so that all labels are visible, but just.
-void wxPropertyGridPageState::SetSplitterLeft( bool subProps )
-{
-    wxPropertyGrid* pg = GetGrid();
-    wxClientDC dc(pg);
-    dc.SetFont(pg->GetFont());
-
-    int maxW = GetColumnFitWidth(dc, m_properties, 0, subProps);
-
-    if ( maxW > 0 )
-    {
-        maxW += pg->m_marginWidth;
-        DoSetSplitterPosition( maxW );
-    }
-
-    pg->SetInternalFlag(wxPG_FL_DONT_CENTER_SPLITTER);
-}
-
-wxSize wxPropertyGridPageState::DoFitColumns( bool WXUNUSED(allowGridResize) )
-{
-    wxPropertyGrid* pg = GetGrid();
-    wxClientDC dc(pg);
-    dc.SetFont(pg->GetFont());
-
-    int marginWidth = pg->m_marginWidth;
-    int accWid = marginWidth;
-    int maxColWidth = 500;
-
-    for ( unsigned int col=0; col < GetColumnCount(); col++ )
-    {
-        int fitWid = GetColumnFitWidth(dc, m_properties, col, true);
-        int colMinWidth = GetColumnMinWidth(col);
-        if ( fitWid < colMinWidth )
-            fitWid = colMinWidth;
-        else if ( fitWid > maxColWidth )
-            fitWid = maxColWidth;
-
-        m_colWidths[col] = fitWid;
-
-        accWid += fitWid;
-    }
-
-    // Expand last one to fill the width
-    int remaining = m_width - accWid;
-    m_colWidths[GetColumnCount()-1] += remaining;
-
-    pg->SetInternalFlag(wxPG_FL_DONT_CENTER_SPLITTER);
-
-    int firstSplitterX = marginWidth + m_colWidths[0];
-    m_fSplitterX = (double) firstSplitterX;
-
-    // Don't allow initial splitter auto-positioning after this.
-    if ( pg->GetState() == this )
-    {
-        pg->SetSplitterPosition(firstSplitterX, false);
-        pg->Refresh();
-    }
-
-    int x, y;
-    pg->GetVirtualSize(&x, &y);
-
-    return wxSize(accWid, y);
-}
-
-void wxPropertyGridPageState::CheckColumnWidths( int widthChange )
-{
-    if ( m_width == 0 )
-        return;
-
-    wxPropertyGrid* pg = GetGrid();
-
-    unsigned int i;
-    unsigned int lastColumn = m_colWidths.size() - 1;
-    int width = m_width;
-    int clientWidth = pg->GetClientSize().x;
-
-    //
-    // Column to reduce, if needed. Take last one that exceeds minimum width.
-    int reduceCol = -1;
-
-    wxLogTrace("propgrid",
-               wxS("ColumnWidthCheck (virtualWidth: %i, clientWidth: %i)"),
-               width, clientWidth);
-
-    //
-    // Check min sizes
-    for ( i=0; i<m_colWidths.size(); i++ )
-    {
-        int min = GetColumnMinWidth(i);
-        if ( m_colWidths[i] <= min )
-        {
-            m_colWidths[i] = min;
-        }
-        else
-        {
-            // Always reduce the last column that is larger than minimum size
-            // (looks nicer, even with auto-centering enabled).
-            reduceCol = i;
-        }
-    }
-
-    int colsWidth = pg->m_marginWidth;
-    for ( i=0; i<m_colWidths.size(); i++ )
-        colsWidth += m_colWidths[i];
-
-    wxLogTrace("propgrid",
-               wxS("  HasVirtualWidth: %i  colsWidth: %i"),
-               (int)pg->HasVirtualWidth(), colsWidth);
-
-    // Then mode-based requirement
-    if ( !pg->HasVirtualWidth() )
-    {
-        int widthHigher = width - colsWidth;
-
-        // Adapt colsWidth to width
-        if ( colsWidth < width )
-        {
-            // Increase column
-            wxLogTrace("propgrid",
-                       wxS("  Adjust last column to %i"),
-                       m_colWidths[lastColumn] + widthHigher);
-            m_colWidths[lastColumn] = m_colWidths[lastColumn] + widthHigher;
-        }
-        else if ( colsWidth > width )
-        {
-            // Reduce column
-            if ( reduceCol != -1 )
-            {
-                wxLogTrace("propgrid",
-                           wxT("  Reduce column %i (by %i)"),
-                           reduceCol, -widthHigher);
-
-                // Reduce widest column, and recheck
-                m_colWidths[reduceCol] = m_colWidths[reduceCol] + widthHigher;
-                CheckColumnWidths();
-            }
-        }
-    }
-    else
-    {
-        // Only check colsWidth against clientWidth
-        if ( colsWidth < clientWidth )
-        {
-            m_colWidths[lastColumn] = m_colWidths[lastColumn] + (clientWidth-colsWidth);
-        }
-
-        m_width = colsWidth;
-
-        // If width changed, recalculate virtual size
-        if ( pg->GetState() == this )
-            pg->RecalculateVirtualSize();
-    }
-
-    for ( i=0; i<m_colWidths.size(); i++ )
-    {
-        wxLogTrace("propgrid", wxS("col%i: %i"), i, m_colWidths[i]);
-    }
-
-    // Auto center splitter
-    if ( !(pg->GetInternalFlags() & wxPG_FL_DONT_CENTER_SPLITTER) &&
-         m_colWidths.size() == 2 )
-    {
-        float centerX = (float)(pg->m_width/2);
-        float splitterX;
-
-        if ( m_fSplitterX < 0.0 )
-        {
-            splitterX = centerX;
-        }
-        else if ( widthChange )
-        {
-            //float centerX = float(pg->GetSize().x) * 0.5;
-
-            // Recenter?
-            splitterX = m_fSplitterX + (float(widthChange) * 0.5);
-            float deviation = fabs(centerX - splitterX);
-
-            // If deviating from center, adjust towards it
-            if ( deviation > 20.0 )
-            {
-                if ( splitterX > centerX)
-                    splitterX -= 2;
-                else
-                    splitterX += 2;
-            }
-        }
-        else
-        {
-            // No width change, just keep sure we keep splitter position intact
-            splitterX = m_fSplitterX;
-            float deviation = fabs(centerX - splitterX);
-            if ( deviation > 50.0 )
-            {
-                splitterX = centerX;
-            }
-        }
-
-        DoSetSplitterPosition((int)splitterX, 0, false, true);
-
-        m_fSplitterX = splitterX; // needed to retain accuracy
-    }
-}
-
-void wxPropertyGridPageState::SetColumnCount( int colCount )
-{
-    wxASSERT( colCount >= 2 );
-    m_colWidths.SetCount( colCount, wxPG_DRAG_MARGIN );
-    if ( m_colWidths.size() > (unsigned int)colCount )
-        m_colWidths.RemoveAt( m_colWidths.size(), m_colWidths.size() - colCount );
-
-    if ( m_pPropGrid->GetState() == this )
-        m_pPropGrid->RecalculateVirtualSize();
-    else
-        CheckColumnWidths();
-}
-
-// Returns column index, -1 for margin
-int wxPropertyGridPageState::HitTestH( int x, int* pSplitterHit, int* pSplitterHitOffset ) const
-{
-    int cx = GetGrid()->m_marginWidth;
-    int col = -1;
-    int prevSplitter = -1;
-
-    while ( x > cx )
-    {
-        col++;
-        if ( col >= (int)m_colWidths.size() )
-        {
-            *pSplitterHit = -1;
-            return col;
-        }
-        prevSplitter = cx;
-        cx += m_colWidths[col];
-    }
-
-    // Near prev. splitter
-    if ( col >= 1 )
-    {
-        int diff = x - prevSplitter;
-        if ( abs(diff) < wxPG_SPLITTERX_DETECTMARGIN1 )
-        {
-            *pSplitterHit = col - 1;
-            *pSplitterHitOffset = diff;
-            return col;
-        }
-    }
-
-    // Near next splitter
-    int nextSplitter = cx;
-    if ( col < (int)(m_colWidths.size()-1) )
-    {
-        int diff = x - nextSplitter;
-        if ( abs(diff) < wxPG_SPLITTERX_DETECTMARGIN1 )
-        {
-            *pSplitterHit = col;
-            *pSplitterHitOffset = diff;
-            return col;
-        }
-    }
-
-    *pSplitterHit = -1;
-    return col;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState property value setting and getting
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoSetPropertyValueString( wxPGProperty* p, const wxString& value )
-{
-    if ( p )
-    {
-        int flags = wxPG_REPORT_ERROR|wxPG_FULL_VALUE|wxPG_PROGRAMMATIC_VALUE;
-
-        wxVariant variant = p->GetValueRef();
-        bool res;
-
-        if ( p->GetMaxLength() <= 0 )
-            res = p->StringToValue( variant, value, flags );
-        else
-            res = p->StringToValue( variant, value.Mid(0,p->GetMaxLength()), flags );
-
-        if ( res )
-        {
-            p->SetValue(variant);
-            if ( m_selected==p && this==m_pPropGrid->GetState() )
-                m_pPropGrid->RefreshEditor();
-        }
-
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoSetPropertyValue( wxPGProperty* p, wxVariant& value )
-{
-    if ( p )
-    {
-        p->SetValue(value);
-        if ( m_selected==p && this==m_pPropGrid->GetState() )
-            m_pPropGrid->RefreshEditor();
-
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoSetPropertyValueWxObjectPtr( wxPGProperty* p, wxObject* value )
-{
-    if ( p )
-    {
-        // wnd_primary has to be given so the control can be updated as well.
-        wxVariant v(value);
-        DoSetPropertyValue(p, v);
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState property operations
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoCollapse( wxPGProperty* p )
-{
-    wxCHECK_MSG( p, false, wxT("invalid property id") );
-
-    if ( !p->GetChildCount() ) return false;
-
-    if ( !p->IsExpanded() ) return false;
-
-    p->SetExpanded(false);
-
-    VirtualHeightChanged();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoExpand( wxPGProperty* p )
-{
-    wxCHECK_MSG( p, false, wxT("invalid property id") );
-
-    if ( !p->GetChildCount() ) return false;
-
-    if ( p->IsExpanded() ) return false;
-
-    p->SetExpanded(true);
-
-    VirtualHeightChanged();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoSelectProperty( wxPGProperty* p, unsigned int flags )
-{
-    if ( this == m_pPropGrid->GetState() )
-        return m_pPropGrid->DoSelectProperty( p, flags );
-
-    m_selected = p;
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoHideProperty( wxPGProperty* p, bool hide, int flags )
-{
-    if ( !hide )
-        p->ClearFlag( wxPG_PROP_HIDDEN );
-    else
-        p->SetFlag( wxPG_PROP_HIDDEN );
-
-    if ( flags & wxPG_RECURSE )
-    {
-        unsigned int i;
-        for ( i = 0; i < p->GetChildCount(); i++ )
-            DoHideProperty(p->Item(i), hide, flags | wxPG_RECURSE_STARTS);
-    }
-
-    VirtualHeightChanged();
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::DoEnableProperty( wxPGProperty* p, bool enable )
-{
-    if ( p )
-    {
-        if ( enable )
-        {
-            if ( !(p->m_flags & wxPG_PROP_DISABLED) )
-                return false;
-
-            // Enabling
-
-            p->m_flags &= ~(wxPG_PROP_DISABLED);
-        }
-        else
-        {
-            if ( p->m_flags & wxPG_PROP_DISABLED )
-                return false;
-
-            // Disabling
-
-            p->m_flags |= wxPG_PROP_DISABLED;
-
-        }
-
-        // Apply same to sub-properties as well
-        unsigned int i;
-        for ( i = 0; i < p->GetChildCount(); i++ )
-            DoEnableProperty( p->Item(i), enable );
-
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState wxVariant related routines
-// -----------------------------------------------------------------------
-
-// Returns list of wxVariant objects (non-categories and non-sub-properties only).
-// Never includes sub-properties (unless they are parented by wxParentProperty).
-wxVariant wxPropertyGridPageState::DoGetPropertyValues( const wxString& listname,
-                                                    wxPGProperty* baseparent,
-                                                    long flags ) const
-{
-    wxPGProperty* pwc = (wxPGProperty*) baseparent;
-
-    // Root is the default base-parent.
-    if ( !pwc )
-        pwc = m_properties;
-
-    wxVariantList tempList;
-    wxVariant v( tempList, listname );
-
-    if ( pwc->GetChildCount() )
-    {
-        if ( flags & wxPG_KEEP_STRUCTURE )
-        {
-            wxASSERT( !pwc->HasFlag(wxPG_PROP_AGGREGATE) );
-
-            size_t i;
-            for ( i=0; i<pwc->GetChildCount(); i++ )
-            {
-                wxPGProperty* p = pwc->Item(i);
-                if ( !p->GetChildCount() || p->HasFlag(wxPG_PROP_AGGREGATE) )
-                {
-                    wxVariant variant = p->GetValue();
-                    variant.SetName( p->GetBaseName() );
-                    v.Append( variant );
-                }
-                else
-                {
-                    v.Append( DoGetPropertyValues(p->m_name,p,flags|wxPG_KEEP_STRUCTURE) );
-                }
-                if ( (flags & wxPG_INC_ATTRIBUTES) && p->m_attributes.GetCount() )
-                    v.Append( p->GetAttributesAsList() );
-            }
-        }
-        else
-        {
-            wxPropertyGridConstIterator it( this, wxPG_ITERATE_DEFAULT, pwc->Item(0) );
-            it.SetBaseParent( pwc );
-
-            for ( ; !it.AtEnd(); it.Next() )
-            {
-                const wxPGProperty* p = it.GetProperty();
-
-                // Use a trick to ignore wxParentProperty itself, but not its sub-properties.
-                if ( !p->GetChildCount() || p->HasFlag(wxPG_PROP_AGGREGATE) )
-                {
-                    wxVariant variant = p->GetValue();
-                    variant.SetName( p->GetName() );
-                    v.Append( variant );
-                    if ( (flags & wxPG_INC_ATTRIBUTES) && p->m_attributes.GetCount() )
-                        v.Append( p->GetAttributesAsList() );
-                }
-            }
-        }
-    }
-
-    return v;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::DoSetPropertyValues( const wxVariantList& list, wxPGProperty* defaultCategory )
-{
-    unsigned char origFrozen = 1;
-
-    if ( m_pPropGrid->GetState() == this )
-    {
-        origFrozen = m_pPropGrid->m_frozen;
-        if ( !origFrozen ) m_pPropGrid->Freeze();
-    }
-
-    wxPropertyCategory* use_category = (wxPropertyCategory*)defaultCategory;
-
-    if ( !use_category )
-        use_category = (wxPropertyCategory*)m_properties;
-
-    // Let's iterate over the list of variants.
-    wxVariantList::const_iterator node;
-    int numSpecialEntries = 0;
-
-    //
-    // Second pass for special entries
-    for ( node = list.begin(); node != list.end(); ++node )
-    {
-        wxVariant *current = (wxVariant*)*node;
-
-        // Make sure it is wxVariant.
-        wxASSERT( current );
-        wxASSERT( wxStrcmp(current->GetClassInfo()->GetClassName(),wxT("wxVariant")) == 0 );
-
-        const wxString& name = current->GetName();
-        if ( name.length() > 0 )
-        {
-            //
-            // '@' signified a special entry
-            if ( name[0] == wxS('@') )
-            {
-                numSpecialEntries++;
-            }
-            else
-            {
-                wxPGProperty* foundProp = BaseGetPropertyByName(name);
-                if ( foundProp )
-                {
-                    wxPGProperty* p = foundProp;
-
-                    // If it was a list, we still have to go through it.
-                    if ( wxStrcmp(current->GetType(), wxS("list")) == 0 )
-                    {
-                        DoSetPropertyValues( current->GetList(),
-                                p->IsCategory()?p:(NULL)
-                            );
-                    }
-                    else
-                    {
-                        wxASSERT_LEVEL_2_MSG(
-                            wxStrcmp(current->GetType(), p->GetValue().GetType()) == 0,
-                            wxString::Format(
-                                wxS("setting value of property \"%s\" from variant"),
-                                p->GetName().c_str())
-                        );
-
-                        p->SetValue(*current);
-                    }
-                }
-                else
-                {
-                    // Is it list?
-                    if ( current->GetType() != wxS("list") )
-                    {
-                        // Not.
-                    }
-                    else
-                    {
-                        // Yes, it is; create a sub category and append contents there.
-                        wxPGProperty* newCat = DoInsert(use_category,-1,new wxPropertyCategory(current->GetName(),wxPG_LABEL));
-                        DoSetPropertyValues( current->GetList(), newCat );
-                    }
-                }
-            }
-        }
-    }
-
-    if ( numSpecialEntries )
-    {
-        for ( node = list.begin(); node != list.end(); ++node )
-        {
-            wxVariant *current = (wxVariant*)*node;
-
-            const wxString& name = current->GetName();
-            if ( name.length() > 0 )
-            {
-                //
-                // '@' signified a special entry
-                if ( name[0] == wxS('@') )
-                {
-                    numSpecialEntries--;
-
-                    size_t pos2 = name.rfind(wxS('@'));
-                    if ( pos2 > 0 && pos2 < (name.size()-1) )
-                    {
-                        wxString propName = name.substr(1, pos2-1);
-                        wxString entryType = name.substr(pos2+1, wxString::npos);
-
-                        if ( entryType == wxS("attr") )
-                        {
-                            //
-                            // List of attributes
-                            wxPGProperty* foundProp = BaseGetPropertyByName(propName);
-                            if ( foundProp )
-                            {
-                                wxASSERT( current->GetType() == wxPG_VARIANT_TYPE_LIST );
-
-                                wxVariantList& list2 = current->GetList();
-                                wxVariantList::const_iterator node2;
-
-                                for ( node2 = list2.begin(); node2 != list2.end(); ++node2 )
-                                {
-                                    wxVariant *attr = (wxVariant*)*node2;
-                                    foundProp->SetAttribute( attr->GetName(), *attr );
-                                }
-                            }
-                            else
-                            {
-                                // ERROR: No such property: 'propName'
-                            }
-                        }
-                    }
-                    else
-                    {
-                        // ERROR: Special entry requires name of format @<propname>@<entrytype>
-                    }
-                }
-            }
-
-            if ( !numSpecialEntries )
-                break;
-        }
-    }
-
-    if ( !origFrozen )
-    {
-        m_pPropGrid->Thaw();
-
-        if ( this == m_pPropGrid->GetState() )
-            m_pPropGrid->RefreshEditor();
-    }
-
-}
-
-// -----------------------------------------------------------------------
-// wxPropertyGridPageState property adding and removal
-// -----------------------------------------------------------------------
-
-bool wxPropertyGridPageState::PrepareToAddItem( wxPGProperty* property,
-                                                wxPGProperty* scheduledParent )
-{
-    wxPropertyGrid* propGrid = m_pPropGrid;
-
-    // This will allow better behavior.
-    if ( scheduledParent == m_properties )
-        scheduledParent = NULL;
-
-    if ( scheduledParent && !scheduledParent->IsCategory() )
-    {
-        wxASSERT_MSG( property->GetBaseName().length(),
-                      "Property's children must have unique, non-empty names within their scope" );
-    }
-
-    property->m_parentState = this;
-
-    if ( property->IsCategory() )
-    {
-
-        // Parent of a category must be either root or another category
-        // (otherwise Bad Things might happen).
-        wxASSERT_MSG( scheduledParent == NULL ||
-                      scheduledParent == m_properties ||
-                      scheduledParent->IsCategory(),
-                 wxT("Parent of a category must be either root or another category."));
-
-        // If we already have category with same name, delete given property
-        // and use it instead as most recent caption item.
-        wxPGProperty* found_id = BaseGetPropertyByName( property->GetBaseName() );
-        if ( found_id )
-        {
-            wxPropertyCategory* pwc = (wxPropertyCategory*) found_id;
-            if ( pwc->IsCategory() ) // Must be a category.
-            {
-                delete property;
-                m_currentCategory = pwc;
-                return false;
-            }
-        }
-    }
-
-#if wxDEBUG_LEVEL
-    // Warn for identical names in debug mode.
-    if ( BaseGetPropertyByName(property->GetName()) &&
-         (!scheduledParent || scheduledParent->IsCategory()) )
-    {
-        wxFAIL_MSG(wxString::Format(
-            "wxPropertyGrid item with name \"%s\" already exists",
-            property->GetName()));
-
-        wxPGGlobalVars->m_warnings++;
-    }
-#endif // wxDEBUG_LEVEL
-
-    // Make sure nothing is selected.
-    if ( propGrid )
-        propGrid->ClearSelection(false);
-
-    // NULL parent == root parent
-    if ( !scheduledParent )
-        scheduledParent = DoGetRoot();
-
-    property->m_parent = scheduledParent;
-
-    property->InitAfterAdded(this, propGrid);
-
-    if ( property->IsCategory() )
-    {
-        wxPropertyCategory* pc = wxStaticCast(property, wxPropertyCategory);
-
-        m_currentCategory = pc;
-
-        // Calculate text extent for category caption
-        if ( propGrid )
-            pc->CalculateTextExtent(propGrid, propGrid->GetCaptionFont());
-    }
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPageState::DoAppend( wxPGProperty* property )
-{
-    wxPropertyCategory* cur_cat = m_currentCategory;
-    if ( property->IsCategory() )
-        cur_cat = NULL;
-
-    return DoInsert( cur_cat, -1, property );
-}
-
-// -----------------------------------------------------------------------
-
-wxPGProperty* wxPropertyGridPageState::DoInsert( wxPGProperty* parent, int index, wxPGProperty* property )
-{
-    if ( !parent )
-        parent = m_properties;
-
-    wxCHECK_MSG( !parent->HasFlag(wxPG_PROP_AGGREGATE),
-                 wxNullProperty,
-                 wxT("when adding properties to fixed parents, use BeginAddChildren and EndAddChildren.") );
-
-    bool res = PrepareToAddItem( property, (wxPropertyCategory*)parent );
-
-    // PrepareToAddItem() may just decide to use use current category
-    // instead of adding new one.
-    if ( !res )
-        return m_currentCategory;
-
-    bool parentIsRoot = parent->IsRoot();
-    bool parentIsCategory = parent->IsCategory();
-
-    // Note that item must be added into current mode later.
-
-    // If parent is wxParentProperty, just stick it in...
-    // If parent is root (m_properties), then...
-    //   In categoric mode: Add as last item in m_abcArray (if not category).
-    //                      Add to given index in m_regularArray.
-    //   In non-cat mode:   Add as last item in m_regularArray.
-    //                      Add to given index in m_abcArray.
-    // If parent is category, then...
-    //   1) Add to given category in given index.
-    //   2) Add as last item in m_abcArray.
-
-    if ( m_properties == &m_regularArray )
-    {
-        // We are currently in Categorized mode
-
-        // Only add non-categories to m_abcArray.
-        if ( m_abcArray && !property->IsCategory() &&
-             (parentIsCategory || parentIsRoot) )
-        {
-            m_abcArray->DoAddChild( property, -1, false );
-        }
-
-        // Add to current mode.
-        parent->DoAddChild( property, index, true );
-    }
-    else
-    {
-        // We are currently in Non-categorized/Alphabetic mode
-
-        if ( parentIsCategory )
-            // Parent is category.
-            parent->DoAddChild( property, index, false );
-        else if ( parentIsRoot )
-            // Parent is root.
-            m_regularArray.DoAddChild( property, -1, false );
-
-        // Add to current mode
-        if ( !property->IsCategory() )
-            m_abcArray->DoAddChild( property, index, true );
-    }
-
-    // category stuff
-    if ( property->IsCategory() )
-    {
-        // This is a category caption item.
-
-        // Last caption is not the bottom one (this info required by append)
-        m_lastCaptionBottomnest = 0;
-    }
-
-    // Only add name to hashmap if parent is root or category
-    if ( property->m_name.length() &&
-        (parentIsCategory || parentIsRoot) )
-        m_dictName[property->m_name] = (void*) property;
-
-    VirtualHeightChanged();
-
-    property->UpdateParentValues();
-
-    m_itemsAdded = 1;
-
-    return property;
-}
-
-// -----------------------------------------------------------------------
-
-void wxPropertyGridPageState::DoDelete( wxPGProperty* item, bool doDelete )
-{
-    wxCHECK_RET( item->GetParent(),
-        wxT("this property was already deleted") );
-
-    wxCHECK_RET( item != &m_regularArray && item != m_abcArray,
-        wxT("wxPropertyGrid: Do not attempt to remove the root item.") );
-
-    unsigned int indinparent = item->GetIndexInParent();
-
-    wxPGProperty* pwc = (wxPGProperty*)item;
-    wxPGProperty* parent = item->GetParent();
-
-    wxCHECK_RET( !parent->HasFlag(wxPG_PROP_AGGREGATE),
-        wxT("wxPropertyGrid: Do not attempt to remove sub-properties.") );
-
-    // Delete children
-    if ( item->GetChildCount() && !item->HasFlag(wxPG_PROP_AGGREGATE) )
-    {
-        // deleting a category
-        if ( item->IsCategory() )
-        {
-            if ( pwc == m_currentCategory )
-                m_currentCategory = NULL;
-        }
-
-        item->DeleteChildren();
-    }
-
-    if ( !IsInNonCatMode() )
-    {
-        // categorized mode - non-categorized array
-
-        // Remove from non-cat array
-        if ( !item->IsCategory() &&
-             (parent->IsCategory() || parent->IsRoot()) )
-        {
-            if ( m_abcArray )
-                m_abcArray->RemoveChild(item);
-        }
-
-        // categorized mode - categorized array
-        wxArrayPGProperty& parentsChildren = parent->m_children;
-        parentsChildren.erase( parentsChildren.begin() + indinparent );
-        item->m_parent->FixIndicesOfChildren();
-    }
-    else
-    {
-        // non-categorized mode - categorized array
-
-        // We need to find location of item.
-        wxPGProperty* cat_parent = &m_regularArray;
-        int cat_index = m_regularArray.GetChildCount();
-        size_t i;
-        for ( i = 0; i < m_regularArray.GetChildCount(); i++ )
-        {
-            wxPGProperty* p = m_regularArray.Item(i);
-            if ( p == item ) { cat_index = i; break; }
-            if ( p->IsCategory() )
-            {
-                int subind = ((wxPGProperty*)p)->Index(item);
-                if ( subind != wxNOT_FOUND )
-                {
-                    cat_parent = ((wxPGProperty*)p);
-                    cat_index = subind;
-                    break;
-                }
-            }
-        }
-        cat_parent->m_children.erase(cat_parent->m_children.begin()+cat_index);
-
-        // non-categorized mode - non-categorized array
-        if ( !item->IsCategory() )
-        {
-            wxASSERT( item->m_parent == m_abcArray );
-            wxArrayPGProperty& parentsChildren = item->m_parent->m_children;
-            parentsChildren.erase(parentsChildren.begin() + indinparent);
-            item->m_parent->FixIndicesOfChildren(indinparent);
-        }
-    }
-
-    if ( item->GetBaseName().length() && 
-         (parent->IsCategory() || parent->IsRoot()) )
-        m_dictName.erase(item->GetBaseName());
-
-    // We can actually delete it now
-    if ( doDelete )
-        delete item;
-
-    m_itemsAdded = 1; // Not a logical assignment (but required nonetheless).
-
-    VirtualHeightChanged();
-}
-
-// -----------------------------------------------------------------------
-
-#endif  // wxUSE_PROPGRID
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/propgridpagestate.cpp
+// Purpose:     wxPropertyGridPageState class
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2008-08-24
+// RCS-ID:      $Id: propgridpagestate.cpp 59725 2009-03-22 12:53:48Z VZ $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcmemory.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/intl.h"
+    #include "wx/stopwatch.h"
+#endif
+
+// This define is necessary to prevent macro clearing
+#define __wxPG_SOURCE_FILE__
+
+#include "wx/propgrid/propgridpagestate.h"
+#include "wx/propgrid/propgrid.h"
+#include "wx/propgrid/editors.h"
+
+#define wxPG_DEFAULT_SPLITTERX      110
+
+
+// -----------------------------------------------------------------------
+// wxPropertyGridIterator
+// -----------------------------------------------------------------------
+
+void wxPropertyGridIteratorBase::Init( wxPropertyGridPageState* state, int flags, wxPGProperty* property, int dir  )
+{
+    wxASSERT( dir == 1 || dir == -1 );
+
+    m_state = state;
+    m_baseParent = state->DoGetRoot();
+    if ( !property && m_baseParent->GetChildCount() )
+        property = m_baseParent->Item(0);
+
+    m_property = property;
+
+    wxPG_ITERATOR_CREATE_MASKS(flags, m_itemExMask, m_parentExMask)
+
+    // Need to skip first?
+    if ( property && (property->GetFlags() & m_itemExMask) )
+    {
+        if ( dir == 1 )
+            Next();
+        else
+            Prev();
+    }
+}
+
+void wxPropertyGridIteratorBase::Init( wxPropertyGridPageState* state, int flags, int startPos, int dir  )
+{
+    wxPGProperty* property = NULL;
+
+    if ( startPos == wxTOP )
+    {
+        if ( dir == 0 )
+            dir = 1;
+    }
+    else if ( startPos == wxBOTTOM )
+    {
+        property = state->GetLastItem(flags);
+        if ( dir == 0 )
+            dir = -1;
+    }
+    else
+    {
+        wxFAIL_MSG("Only supported starting positions are wxTOP and wxBOTTOM");
+    }
+
+    Init( state, flags, property, dir );
+}
+
+void wxPropertyGridIteratorBase::Assign( const wxPropertyGridIteratorBase& it )
+{
+    m_property = it.m_property;
+    m_state = it.m_state;
+    m_baseParent = it.m_baseParent;
+    m_itemExMask = it.m_itemExMask;
+    m_parentExMask = it.m_parentExMask;
+}
+
+void wxPropertyGridIteratorBase::Prev()
+{
+    wxPGProperty* property = m_property;
+    wxASSERT( property );
+
+    wxPGProperty* parent = property->GetParent();
+    wxASSERT( parent );
+    unsigned int index = property->GetIndexInParent();
+
+    if ( index > 0 )
+    {
+        // Previous sibling
+        index--;
+
+        property = parent->Item(index);
+
+        // Go to last children?
+        if ( property->GetChildCount() &&
+             wxPG_ITERATOR_PARENTEXMASK_TEST(property, m_parentExMask) )
+        {
+            // First child
+            property = property->Last();
+        }
+    }
+    else
+    {
+        // Up to a parent
+        if ( parent == m_baseParent )
+        {
+            m_property = NULL;
+            return;
+        }
+        else
+        {
+            property = parent;
+        }
+    }
+
+    m_property = property;
+
+    // If property does not match our criteria, skip it
+    if ( property->GetFlags() & m_itemExMask )
+        Prev();
+}
+
+void wxPropertyGridIteratorBase::Next( bool iterateChildren )
+{
+    wxPGProperty* property = m_property;
+    wxASSERT( property );
+
+    if ( property->GetChildCount() &&
+         wxPG_ITERATOR_PARENTEXMASK_TEST(property, m_parentExMask) &&
+         iterateChildren )
+    {
+        // First child
+        property = property->Item(0);
+    }
+    else
+    {
+        wxPGProperty* parent = property->GetParent();
+        wxASSERT( parent );
+        unsigned int index = property->GetIndexInParent() + 1;
+
+        if ( index < parent->GetChildCount() )
+        {
+            // Next sibling
+            property = parent->Item(index);
+        }
+        else
+        {
+            // Next sibling of parent
+            if ( parent == m_baseParent )
+            {
+                m_property = NULL;
+            }
+            else
+            {
+                m_property = parent;
+                Next(false);
+            }
+            return;
+        }
+    }
+
+    m_property = property;
+
+    // If property does not match our criteria, skip it
+    if ( property->GetFlags() & m_itemExMask )
+        Next();
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState
+// -----------------------------------------------------------------------
+
+wxPropertyGridPageState::wxPropertyGridPageState()
+{
+    m_pPropGrid = NULL;
+    m_regularArray.SetParentState(this);
+    m_properties = &m_regularArray;
+    m_abcArray = NULL;
+    m_currentCategory = NULL;
+    m_selected = NULL;
+    m_width = 0;
+    m_virtualHeight = 0;
+    m_lastCaptionBottomnest = 1;
+    m_itemsAdded = 0;
+    m_anyModified = 0;
+    m_vhCalcPending = 0;
+    m_colWidths.push_back( wxPG_DEFAULT_SPLITTERX );
+    m_colWidths.push_back( wxPG_DEFAULT_SPLITTERX );
+    m_fSplitterX = wxPG_DEFAULT_SPLITTERX;
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridPageState::~wxPropertyGridPageState()
+{
+    delete m_abcArray;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::InitNonCatMode()
+{
+    if ( !m_abcArray )
+    {
+        m_abcArray = new wxPGRootProperty(wxS("<Root_NonCat>"));
+        m_abcArray->SetParentState(this);
+        m_abcArray->SetFlag(wxPG_PROP_CHILDREN_ARE_COPIES);
+    }
+
+    // Must be called when state::m_properties still points to regularArray.
+    wxPGProperty* oldProperties = m_properties;
+
+    // Must use temp value in state::m_properties for item iteration loop
+    // to run as expected.
+    m_properties = &m_regularArray;
+
+    if ( m_properties->GetChildCount() )
+    {
+        //
+        // Prepare m_abcArray
+        wxPropertyGridIterator it( this, wxPG_ITERATE_PROPERTIES );
+
+        for ( ; !it.AtEnd(); it.Next() )
+        {
+            wxPGProperty* p = it.GetProperty();
+            wxPGProperty* parent = p->GetParent();
+            if ( parent->IsCategory() || parent->IsRoot() )
+            {
+                m_abcArray->DoAddChild(p);
+                p->m_parent = &m_regularArray;
+            }
+        }
+    }
+
+    m_properties = oldProperties;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::DoClear()
+{
+    if ( m_pPropGrid && m_pPropGrid->GetState() == this  )
+    {
+        m_pPropGrid->ClearSelection(false);
+    }
+    else
+    {
+        m_selected = NULL;
+    }
+
+    m_regularArray.Empty();
+    if ( m_abcArray )
+        m_abcArray->Empty();
+
+    m_dictName.clear();
+
+    m_currentCategory = NULL;
+    m_lastCaptionBottomnest = 1;
+    m_itemsAdded = 0;
+
+    m_virtualHeight = 0;
+    m_vhCalcPending = 0;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::CalculateFontAndBitmapStuff( int WXUNUSED(vspacing) )
+{
+    wxPropertyGrid* propGrid = GetGrid();
+
+    VirtualHeightChanged();
+
+    // Recalculate caption text extents.
+    unsigned int i;
+
+    for ( i=0;i<m_regularArray.GetChildCount();i++ )
+    {
+        wxPGProperty* p =m_regularArray.Item(i);
+
+        if ( p->IsCategory() )
+            ((wxPropertyCategory*)p)->CalculateTextExtent(propGrid, propGrid->GetCaptionFont());
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::SetVirtualWidth( int width )
+{
+    //wxASSERT( width >= 0 );
+    wxPropertyGrid* pg = GetGrid();
+    int gw = pg->GetClientSize().x;
+    if ( width < gw )
+        width = gw;
+
+    m_width = width;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::OnClientWidthChange( int newWidth, int widthChange, bool fromOnResize )
+{
+    wxPropertyGrid* pg = GetGrid();
+
+    if ( pg->HasVirtualWidth() )
+    {
+        if ( m_width < newWidth )
+            SetVirtualWidth( newWidth );
+
+        CheckColumnWidths(widthChange);
+    }
+    else
+    {
+        SetVirtualWidth( newWidth );
+
+        // This should be done before splitter auto centering
+        // NOTE: Splitter auto-centering is done in this function.
+        if ( !fromOnResize )
+            widthChange = 0;
+        CheckColumnWidths(widthChange);
+
+        if ( !(GetGrid()->GetInternalFlags() & wxPG_FL_SPLITTER_PRE_SET) &&
+             (GetGrid()->GetInternalFlags() & wxPG_FL_DONT_CENTER_SPLITTER) )
+        {
+            long timeSinceCreation = (::wxGetLocalTimeMillis() - GetGrid()->m_timeCreated).ToLong();
+
+            // If too long, don't set splitter
+            if ( timeSinceCreation < 3000 )
+            {
+                if ( m_properties->GetChildCount() || timeSinceCreation > 750 )
+                {
+                    SetSplitterLeft( false );
+                }
+                else
+                {
+                    DoSetSplitterPosition( newWidth / 2 );
+                    GetGrid()->ClearInternalFlag(wxPG_FL_SPLITTER_PRE_SET);
+                }
+            }
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState item iteration methods
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPageState::GetLastItem( int flags )
+{
+    if ( !m_properties->GetChildCount() )
+        return NULL;
+
+    wxPG_ITERATOR_CREATE_MASKS(flags, int itemExMask, int parentExMask)
+
+    // First, get last child of last parent
+    wxPGProperty* pwc = (wxPGProperty*)m_properties->Last();
+    while ( pwc->GetChildCount() &&
+            wxPG_ITERATOR_PARENTEXMASK_TEST(pwc, parentExMask) )
+        pwc = (wxPGProperty*) pwc->Last();
+
+    // Then, if it doesn't fit our criteria, back up until we find something that does
+    if ( pwc->GetFlags() & itemExMask )
+    {
+        wxPropertyGridIterator it( this, flags, pwc );
+        for ( ; !it.AtEnd(); it.Prev() )
+            ;
+        pwc = (wxPGProperty*) it.GetProperty();
+    }
+
+    return pwc;
+}
+
+wxPropertyCategory* wxPropertyGridPageState::GetPropertyCategory( const wxPGProperty* p ) const
+{
+    const wxPGProperty* parent = (const wxPGProperty*)p;
+    const wxPGProperty* grandparent = (const wxPGProperty*)parent->GetParent();
+    do
+    {
+        parent = grandparent;
+        grandparent = (wxPGProperty*)parent->GetParent();
+        if ( parent->IsCategory() && grandparent )
+            return (wxPropertyCategory*)parent;
+    } while ( grandparent );
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState GetPropertyXXX methods
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPageState::GetPropertyByLabel( const wxString& label,
+                                                           wxPGProperty* parent ) const
+{
+
+    size_t i;
+
+    if ( !parent ) parent = (wxPGProperty*) &m_regularArray;
+
+    for ( i=0; i<parent->GetChildCount(); i++ )
+    {
+        wxPGProperty* p = parent->Item(i);
+        if ( p->m_label == label )
+            return p;
+        // Check children recursively.
+        if ( p->GetChildCount() )
+        {
+            p = GetPropertyByLabel(label,(wxPGProperty*)p);
+            if ( p )
+                return p;
+        }
+    }
+
+    return NULL;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPageState::BaseGetPropertyByName( const wxString& name ) const
+{
+    wxPGHashMapS2P::const_iterator it;
+    it = m_dictName.find(name);
+    if ( it != m_dictName.end() )
+        return (wxPGProperty*) it->second;
+    return NULL;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::DoSetPropertyName( wxPGProperty* p,
+                                                 const wxString& newName )
+{
+    wxCHECK_RET( p, wxT("invalid property id") );
+
+    wxPGProperty* parent = p->GetParent();
+
+    if ( parent->IsCategory() || parent->IsRoot() )
+    {
+        if ( p->GetBaseName().length() )
+            m_dictName.erase( p->GetBaseName() );
+        if ( newName.length() )
+            m_dictName[newName] = (void*) p;
+    }
+
+    p->DoSetName(newName);
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState global operations
+// -----------------------------------------------------------------------
+
+// -----------------------------------------------------------------------
+// Item iteration macros
+//   NB: Nowadays only needed for alphabetic/categoric mode switching.
+// -----------------------------------------------------------------------
+
+//#define II_INVALID_I    0x00FFFFFF
+
+#define ITEM_ITERATION_VARIABLES \
+    wxPGProperty* parent; \
+    unsigned int i; \
+    unsigned int iMax;
+
+#define ITEM_ITERATION_INIT_FROM_THE_TOP \
+    parent = m_properties; \
+    i = 0;
+
+#if 0
+#define ITEM_ITERATION_INIT(startparent, startindex, state) \
+    parent = startparent; \
+    i = (unsigned int)startindex; \
+    if ( parent == NULL ) \
+    { \
+        parent = state->m_properties; \
+        i = 0; \
+    }
+#endif
+
+#define ITEM_ITERATION_LOOP_BEGIN \
+    do \
+    { \
+        iMax = parent->GetChildCount(); \
+        while ( i < iMax ) \
+        {  \
+            wxPGProperty* p = parent->Item(i);
+
+#define ITEM_ITERATION_LOOP_END \
+            if ( p->GetChildCount() ) \
+            { \
+                i = 0; \
+                parent = (wxPGProperty*)p; \
+                iMax = parent->GetChildCount(); \
+            } \
+            else \
+                i++; \
+        } \
+        i = parent->m_arrIndex + 1; \
+        parent = parent->m_parent; \
+    } \
+    while ( parent != NULL );
+
+bool wxPropertyGridPageState::EnableCategories( bool enable )
+{
+    //
+    // NB: We can't use wxPropertyGridIterator in this
+    //     function, since it depends on m_arrIndexes,
+    //     which, among other things, is being fixed here.
+    //
+    ITEM_ITERATION_VARIABLES
+
+    if ( enable )
+    {
+        //
+        // Enable categories
+        //
+
+        if ( !IsInNonCatMode() )
+            return false;
+
+        m_properties = &m_regularArray;
+
+        // fix parents, indexes, and depths
+        ITEM_ITERATION_INIT_FROM_THE_TOP
+
+        ITEM_ITERATION_LOOP_BEGIN
+
+            p->m_arrIndex = i;
+
+            p->m_parent = parent;
+
+            // If parent was category, and this is not,
+            // then the depth stays the same.
+            if ( parent->IsCategory() &&
+                 !p->IsCategory() )
+                p->m_depth = parent->m_depth;
+            else
+                p->m_depth = parent->m_depth + 1;
+
+        ITEM_ITERATION_LOOP_END
+
+    }
+    else
+    {
+        //
+        // Disable categories
+        //
+
+        if ( IsInNonCatMode() )
+            return false;
+
+        // Create array, if necessary.
+        if ( !m_abcArray )
+            InitNonCatMode();
+
+        m_properties = m_abcArray;
+
+        // fix parents, indexes, and depths
+        ITEM_ITERATION_INIT_FROM_THE_TOP
+
+        ITEM_ITERATION_LOOP_BEGIN
+
+            p->m_arrIndex = i;
+
+            p->m_parent = parent;
+
+            p->m_depth = parent->m_depth + 1;
+
+        ITEM_ITERATION_LOOP_END
+    }
+
+    VirtualHeightChanged();
+
+    if ( m_pPropGrid->GetState() == this )
+        m_pPropGrid->RecalculateVirtualSize();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+#if wxUSE_STL
+#include <algorithm>
+
+static bool wxPG_SortFunc_ByFunction(wxPGProperty *p1, wxPGProperty *p2)
+{
+    wxPropertyGrid* pg = p1->GetGrid();
+    wxPGSortCallback sortFunction = pg->GetSortFunction();
+    return sortFunction(pg, p1, p2) < 0;
+}
+
+static bool wxPG_SortFunc_ByLabel(wxPGProperty *p1, wxPGProperty *p2)
+{
+    return p1->GetLabel().CmpNoCase( p2->GetLabel() ) < 0;
+}
+
+#else
+
+static int wxPG_SortFunc_ByFunction(wxPGProperty **pp1, wxPGProperty **pp2)
+{
+    wxPGProperty *p1 = *pp1;
+    wxPGProperty *p2 = *pp2;
+    wxPropertyGrid* pg = p1->GetGrid();
+    wxPGSortCallback sortFunction = pg->GetSortFunction();
+    return sortFunction(pg, p1, p2);
+}
+
+static int wxPG_SortFunc_ByLabel(wxPGProperty **pp1, wxPGProperty **pp2)
+{
+    wxPGProperty *p1 = *pp1;
+    wxPGProperty *p2 = *pp2;
+    return p1->GetLabel().CmpNoCase( p2->GetLabel() );
+}
+
+#endif
+
+void wxPropertyGridPageState::DoSortChildren( wxPGProperty* p,
+                                              int flags )
+{
+    if ( !p )
+        p = m_properties;
+
+    // Can only sort items with children
+    if ( !p->GetChildCount() )
+        return;
+
+    // Never sort children of aggregate properties
+    if ( p->HasFlag(wxPG_PROP_AGGREGATE) )
+        return;
+
+    if ( (flags & wxPG_SORT_TOP_LEVEL_ONLY)
+         && !p->IsCategory() && !p->IsRoot() )
+        return;
+
+#if wxUSE_STL
+    if ( GetGrid()->GetSortFunction() )
+        std::sort(p->m_children.begin(), p->m_children.end(),
+                  wxPG_SortFunc_ByFunction);
+    else
+        std::sort(p->m_children.begin(), p->m_children.end(),
+                  wxPG_SortFunc_ByLabel);
+#else
+    if ( GetGrid()->GetSortFunction() )
+        p->m_children.Sort( wxPG_SortFunc_ByFunction );
+    else
+        p->m_children.Sort( wxPG_SortFunc_ByLabel );
+#endif
+
+    // Fix indices
+    p->FixIndicesOfChildren();
+
+    if ( flags & wxPG_RECURSE )
+    {
+        // Apply sort recursively
+        for ( unsigned int i=0; i<p->GetChildCount(); i++ )
+            DoSortChildren(p->Item(i), flags);
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::DoSort( int flags )
+{
+    DoSortChildren( m_properties, flags | wxPG_RECURSE );
+
+    // We used to sort categories as well here also if in non-categorized
+    // mode, but doing would naturally cause child indices to become
+    // corrupted.
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::PrepareAfterItemsAdded()
+{
+    if ( !m_itemsAdded ) return false;
+
+    wxPropertyGrid* pg = GetGrid();
+
+    m_itemsAdded = 0;
+
+    if ( pg->HasFlag(wxPG_AUTO_SORT) )
+        DoSort(wxPG_SORT_TOP_LEVEL_ONLY);
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState splitter, column and hittest functions
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPageState::DoGetItemAtY( int y ) const
+{
+    // Outside?
+    if ( y < 0 )
+        return NULL;
+
+    unsigned int a = 0;
+    return m_properties->GetItemAtY(y, GetGrid()->m_lineHeight, &a);
+}
+
+// -----------------------------------------------------------------------
+
+wxPropertyGridHitTestResult wxPropertyGridPageState::HitTest( const wxPoint&pt ) const
+{
+    wxPropertyGridHitTestResult result;
+    result.column = HitTestH( pt.x, &result.splitter, &result.splitterHitOffset );
+    result.property = DoGetItemAtY( pt.y );
+    return result;
+}
+
+// -----------------------------------------------------------------------
+
+// Used by SetSplitterLeft() and DotFitColumns()
+int wxPropertyGridPageState::GetColumnFitWidth(wxClientDC& dc,
+                                           wxPGProperty* pwc,
+                                           unsigned int col,
+                                           bool subProps) const
+{
+    wxPropertyGrid* pg = m_pPropGrid;
+    size_t i;
+    int maxW = 0;
+    int w, h;
+
+    for ( i=0; i<pwc->GetChildCount(); i++ )
+    {
+        wxPGProperty* p = pwc->Item(i);
+        if ( !p->IsCategory() )
+        {
+            const wxPGCell* cell = NULL;
+            wxString text;
+            p->GetDisplayInfo(col, -1, 0, &text, &cell);
+            dc.GetTextExtent(text, &w, &h);
+            if ( col == 0 )
+                w += ( ((int)p->m_depth-1) * pg->m_subgroup_extramargin );
+
+            //
+            // TODO: Add bitmap support.
+
+            w += (wxPG_XBEFORETEXT*2);
+
+            if ( w > maxW )
+                maxW = w;
+        }
+
+        if ( p->GetChildCount() &&
+             ( subProps || p->IsCategory() ) )
+        {
+            w = GetColumnFitWidth( dc, p, col, subProps );
+
+            if ( w > maxW )
+                maxW = w;
+        }
+    }
+
+    return maxW;
+}
+
+int wxPropertyGridPageState::DoGetSplitterPosition( int splitterColumn ) const
+{
+    int n = GetGrid()->m_marginWidth;
+    int i;
+    for ( i=0; i<=splitterColumn; i++ )
+        n += m_colWidths[i];
+    return n;
+}
+
+int wxPropertyGridPageState::GetColumnMinWidth( int WXUNUSED(column) ) const
+{
+    return wxPG_DRAG_MARGIN;
+}
+
+void wxPropertyGridPageState::PropagateColSizeDec( int column, int decrease, int dir )
+{
+    int origWidth = m_colWidths[column];
+    m_colWidths[column] -= decrease;
+    int min = GetColumnMinWidth(column);
+    int more = 0;
+    if ( m_colWidths[column] < min )
+    {
+        more = decrease - (origWidth - min);
+        m_colWidths[column] = min;
+    }
+
+    //
+    // FIXME: Causes erratic splitter changing, so as a workaround
+    //        disabled if two or less columns.
+
+    if ( m_colWidths.size() <= 2 )
+        return;
+
+    column += dir;
+    if ( more && column < (int)m_colWidths.size() && column >= 0 )
+        PropagateColSizeDec( column, more, dir );
+}
+
+void wxPropertyGridPageState::DoSetSplitterPosition( int newXPos, int splitterColumn, bool WXUNUSED(allPages), bool fromAutoCenter )
+{
+    wxPropertyGrid* pg = GetGrid();
+
+    int adjust = newXPos - DoGetSplitterPosition(splitterColumn);
+
+    if ( !pg->HasVirtualWidth() )
+    {
+        // No virtual width
+        int otherColumn;
+        if ( adjust > 0 )
+        {
+            otherColumn = splitterColumn + 1;
+            if ( otherColumn == (int)m_colWidths.size() )
+                otherColumn = 0;
+            m_colWidths[splitterColumn] += adjust;
+            PropagateColSizeDec( otherColumn, adjust, 1 );
+        }
+        else
+        {
+            otherColumn = splitterColumn + 1;
+            if ( otherColumn == (int)m_colWidths.size() )
+                otherColumn = 0;
+            m_colWidths[otherColumn] -= adjust;
+            PropagateColSizeDec( splitterColumn, -adjust, -1 );
+        }
+    }
+    else
+    {
+        m_colWidths[splitterColumn] += adjust;
+    }
+
+    if ( splitterColumn == 0 )
+        m_fSplitterX = (double) newXPos;
+
+    if ( !fromAutoCenter )
+    {
+        // Don't allow initial splitter auto-positioning after this.
+        if ( pg->GetState() == this )
+            pg->SetInternalFlag(wxPG_FL_SPLITTER_PRE_SET);
+
+        CheckColumnWidths();
+    }
+}
+
+// Moves splitter so that all labels are visible, but just.
+void wxPropertyGridPageState::SetSplitterLeft( bool subProps )
+{
+    wxPropertyGrid* pg = GetGrid();
+    wxClientDC dc(pg);
+    dc.SetFont(pg->GetFont());
+
+    int maxW = GetColumnFitWidth(dc, m_properties, 0, subProps);
+
+    if ( maxW > 0 )
+    {
+        maxW += pg->m_marginWidth;
+        DoSetSplitterPosition( maxW );
+    }
+
+    pg->SetInternalFlag(wxPG_FL_DONT_CENTER_SPLITTER);
+}
+
+wxSize wxPropertyGridPageState::DoFitColumns( bool WXUNUSED(allowGridResize) )
+{
+    wxPropertyGrid* pg = GetGrid();
+    wxClientDC dc(pg);
+    dc.SetFont(pg->GetFont());
+
+    int marginWidth = pg->m_marginWidth;
+    int accWid = marginWidth;
+    int maxColWidth = 500;
+
+    for ( unsigned int col=0; col < GetColumnCount(); col++ )
+    {
+        int fitWid = GetColumnFitWidth(dc, m_properties, col, true);
+        int colMinWidth = GetColumnMinWidth(col);
+        if ( fitWid < colMinWidth )
+            fitWid = colMinWidth;
+        else if ( fitWid > maxColWidth )
+            fitWid = maxColWidth;
+
+        m_colWidths[col] = fitWid;
+
+        accWid += fitWid;
+    }
+
+    // Expand last one to fill the width
+    int remaining = m_width - accWid;
+    m_colWidths[GetColumnCount()-1] += remaining;
+
+    pg->SetInternalFlag(wxPG_FL_DONT_CENTER_SPLITTER);
+
+    int firstSplitterX = marginWidth + m_colWidths[0];
+    m_fSplitterX = (double) firstSplitterX;
+
+    // Don't allow initial splitter auto-positioning after this.
+    if ( pg->GetState() == this )
+    {
+        pg->SetSplitterPosition(firstSplitterX, false);
+        pg->Refresh();
+    }
+
+    int x, y;
+    pg->GetVirtualSize(&x, &y);
+
+    return wxSize(accWid, y);
+}
+
+void wxPropertyGridPageState::CheckColumnWidths( int widthChange )
+{
+    if ( m_width == 0 )
+        return;
+
+    wxPropertyGrid* pg = GetGrid();
+
+    unsigned int i;
+    unsigned int lastColumn = m_colWidths.size() - 1;
+    int width = m_width;
+    int clientWidth = pg->GetClientSize().x;
+
+    //
+    // Column to reduce, if needed. Take last one that exceeds minimum width.
+    int reduceCol = -1;
+
+    wxLogTrace("propgrid",
+               wxS("ColumnWidthCheck (virtualWidth: %i, clientWidth: %i)"),
+               width, clientWidth);
+
+    //
+    // Check min sizes
+    for ( i=0; i<m_colWidths.size(); i++ )
+    {
+        int min = GetColumnMinWidth(i);
+        if ( m_colWidths[i] <= min )
+        {
+            m_colWidths[i] = min;
+        }
+        else
+        {
+            // Always reduce the last column that is larger than minimum size
+            // (looks nicer, even with auto-centering enabled).
+            reduceCol = i;
+        }
+    }
+
+    int colsWidth = pg->m_marginWidth;
+    for ( i=0; i<m_colWidths.size(); i++ )
+        colsWidth += m_colWidths[i];
+
+    wxLogTrace("propgrid",
+               wxS("  HasVirtualWidth: %i  colsWidth: %i"),
+               (int)pg->HasVirtualWidth(), colsWidth);
+
+    // Then mode-based requirement
+    if ( !pg->HasVirtualWidth() )
+    {
+        int widthHigher = width - colsWidth;
+
+        // Adapt colsWidth to width
+        if ( colsWidth < width )
+        {
+            // Increase column
+            wxLogTrace("propgrid",
+                       wxS("  Adjust last column to %i"),
+                       m_colWidths[lastColumn] + widthHigher);
+            m_colWidths[lastColumn] = m_colWidths[lastColumn] + widthHigher;
+        }
+        else if ( colsWidth > width )
+        {
+            // Reduce column
+            if ( reduceCol != -1 )
+            {
+                wxLogTrace("propgrid",
+                           wxT("  Reduce column %i (by %i)"),
+                           reduceCol, -widthHigher);
+
+                // Reduce widest column, and recheck
+                m_colWidths[reduceCol] = m_colWidths[reduceCol] + widthHigher;
+                CheckColumnWidths();
+            }
+        }
+    }
+    else
+    {
+        // Only check colsWidth against clientWidth
+        if ( colsWidth < clientWidth )
+        {
+            m_colWidths[lastColumn] = m_colWidths[lastColumn] + (clientWidth-colsWidth);
+        }
+
+        m_width = colsWidth;
+
+        // If width changed, recalculate virtual size
+        if ( pg->GetState() == this )
+            pg->RecalculateVirtualSize();
+    }
+
+    for ( i=0; i<m_colWidths.size(); i++ )
+    {
+        wxLogTrace("propgrid", wxS("col%i: %i"), i, m_colWidths[i]);
+    }
+
+    // Auto center splitter
+    if ( !(pg->GetInternalFlags() & wxPG_FL_DONT_CENTER_SPLITTER) &&
+         m_colWidths.size() == 2 )
+    {
+        float centerX = (float)(pg->m_width/2);
+        float splitterX;
+
+        if ( m_fSplitterX < 0.0 )
+        {
+            splitterX = centerX;
+        }
+        else if ( widthChange )
+        {
+            //float centerX = float(pg->GetSize().x) * 0.5;
+
+            // Recenter?
+            splitterX = m_fSplitterX + (float(widthChange) * 0.5);
+            float deviation = fabs(centerX - splitterX);
+
+            // If deviating from center, adjust towards it
+            if ( deviation > 20.0 )
+            {
+                if ( splitterX > centerX)
+                    splitterX -= 2;
+                else
+                    splitterX += 2;
+            }
+        }
+        else
+        {
+            // No width change, just keep sure we keep splitter position intact
+            splitterX = m_fSplitterX;
+            float deviation = fabs(centerX - splitterX);
+            if ( deviation > 50.0 )
+            {
+                splitterX = centerX;
+            }
+        }
+
+        DoSetSplitterPosition((int)splitterX, 0, false, true);
+
+        m_fSplitterX = splitterX; // needed to retain accuracy
+    }
+}
+
+void wxPropertyGridPageState::SetColumnCount( int colCount )
+{
+    wxASSERT( colCount >= 2 );
+    m_colWidths.SetCount( colCount, wxPG_DRAG_MARGIN );
+    if ( m_colWidths.size() > (unsigned int)colCount )
+        m_colWidths.RemoveAt( m_colWidths.size(), m_colWidths.size() - colCount );
+
+    if ( m_pPropGrid->GetState() == this )
+        m_pPropGrid->RecalculateVirtualSize();
+    else
+        CheckColumnWidths();
+}
+
+// Returns column index, -1 for margin
+int wxPropertyGridPageState::HitTestH( int x, int* pSplitterHit, int* pSplitterHitOffset ) const
+{
+    int cx = GetGrid()->m_marginWidth;
+    int col = -1;
+    int prevSplitter = -1;
+
+    while ( x > cx )
+    {
+        col++;
+        if ( col >= (int)m_colWidths.size() )
+        {
+            *pSplitterHit = -1;
+            return col;
+        }
+        prevSplitter = cx;
+        cx += m_colWidths[col];
+    }
+
+    // Near prev. splitter
+    if ( col >= 1 )
+    {
+        int diff = x - prevSplitter;
+        if ( abs(diff) < wxPG_SPLITTERX_DETECTMARGIN1 )
+        {
+            *pSplitterHit = col - 1;
+            *pSplitterHitOffset = diff;
+            return col;
+        }
+    }
+
+    // Near next splitter
+    int nextSplitter = cx;
+    if ( col < (int)(m_colWidths.size()-1) )
+    {
+        int diff = x - nextSplitter;
+        if ( abs(diff) < wxPG_SPLITTERX_DETECTMARGIN1 )
+        {
+            *pSplitterHit = col;
+            *pSplitterHitOffset = diff;
+            return col;
+        }
+    }
+
+    *pSplitterHit = -1;
+    return col;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState property value setting and getting
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoSetPropertyValueString( wxPGProperty* p, const wxString& value )
+{
+    if ( p )
+    {
+        int flags = wxPG_REPORT_ERROR|wxPG_FULL_VALUE|wxPG_PROGRAMMATIC_VALUE;
+
+        wxVariant variant = p->GetValueRef();
+        bool res;
+
+        if ( p->GetMaxLength() <= 0 )
+            res = p->StringToValue( variant, value, flags );
+        else
+            res = p->StringToValue( variant, value.Mid(0,p->GetMaxLength()), flags );
+
+        if ( res )
+        {
+            p->SetValue(variant);
+            if ( m_selected==p && this==m_pPropGrid->GetState() )
+                m_pPropGrid->RefreshEditor();
+        }
+
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoSetPropertyValue( wxPGProperty* p, wxVariant& value )
+{
+    if ( p )
+    {
+        p->SetValue(value);
+        if ( m_selected==p && this==m_pPropGrid->GetState() )
+            m_pPropGrid->RefreshEditor();
+
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoSetPropertyValueWxObjectPtr( wxPGProperty* p, wxObject* value )
+{
+    if ( p )
+    {
+        // wnd_primary has to be given so the control can be updated as well.
+        wxVariant v(value);
+        DoSetPropertyValue(p, v);
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState property operations
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoCollapse( wxPGProperty* p )
+{
+    wxCHECK_MSG( p, false, wxT("invalid property id") );
+
+    if ( !p->GetChildCount() ) return false;
+
+    if ( !p->IsExpanded() ) return false;
+
+    p->SetExpanded(false);
+
+    VirtualHeightChanged();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoExpand( wxPGProperty* p )
+{
+    wxCHECK_MSG( p, false, wxT("invalid property id") );
+
+    if ( !p->GetChildCount() ) return false;
+
+    if ( p->IsExpanded() ) return false;
+
+    p->SetExpanded(true);
+
+    VirtualHeightChanged();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoSelectProperty( wxPGProperty* p, unsigned int flags )
+{
+    if ( this == m_pPropGrid->GetState() )
+        return m_pPropGrid->DoSelectProperty( p, flags );
+
+    m_selected = p;
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoHideProperty( wxPGProperty* p, bool hide, int flags )
+{
+    if ( !hide )
+        p->ClearFlag( wxPG_PROP_HIDDEN );
+    else
+        p->SetFlag( wxPG_PROP_HIDDEN );
+
+    if ( flags & wxPG_RECURSE )
+    {
+        unsigned int i;
+        for ( i = 0; i < p->GetChildCount(); i++ )
+            DoHideProperty(p->Item(i), hide, flags | wxPG_RECURSE_STARTS);
+    }
+
+    VirtualHeightChanged();
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::DoEnableProperty( wxPGProperty* p, bool enable )
+{
+    if ( p )
+    {
+        if ( enable )
+        {
+            if ( !(p->m_flags & wxPG_PROP_DISABLED) )
+                return false;
+
+            // Enabling
+
+            p->m_flags &= ~(wxPG_PROP_DISABLED);
+        }
+        else
+        {
+            if ( p->m_flags & wxPG_PROP_DISABLED )
+                return false;
+
+            // Disabling
+
+            p->m_flags |= wxPG_PROP_DISABLED;
+
+        }
+
+        // Apply same to sub-properties as well
+        unsigned int i;
+        for ( i = 0; i < p->GetChildCount(); i++ )
+            DoEnableProperty( p->Item(i), enable );
+
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState wxVariant related routines
+// -----------------------------------------------------------------------
+
+// Returns list of wxVariant objects (non-categories and non-sub-properties only).
+// Never includes sub-properties (unless they are parented by wxParentProperty).
+wxVariant wxPropertyGridPageState::DoGetPropertyValues( const wxString& listname,
+                                                    wxPGProperty* baseparent,
+                                                    long flags ) const
+{
+    wxPGProperty* pwc = (wxPGProperty*) baseparent;
+
+    // Root is the default base-parent.
+    if ( !pwc )
+        pwc = m_properties;
+
+    wxVariantList tempList;
+    wxVariant v( tempList, listname );
+
+    if ( pwc->GetChildCount() )
+    {
+        if ( flags & wxPG_KEEP_STRUCTURE )
+        {
+            wxASSERT( !pwc->HasFlag(wxPG_PROP_AGGREGATE) );
+
+            size_t i;
+            for ( i=0; i<pwc->GetChildCount(); i++ )
+            {
+                wxPGProperty* p = pwc->Item(i);
+                if ( !p->GetChildCount() || p->HasFlag(wxPG_PROP_AGGREGATE) )
+                {
+                    wxVariant variant = p->GetValue();
+                    variant.SetName( p->GetBaseName() );
+                    v.Append( variant );
+                }
+                else
+                {
+                    v.Append( DoGetPropertyValues(p->m_name,p,flags|wxPG_KEEP_STRUCTURE) );
+                }
+                if ( (flags & wxPG_INC_ATTRIBUTES) && p->m_attributes.GetCount() )
+                    v.Append( p->GetAttributesAsList() );
+            }
+        }
+        else
+        {
+            wxPropertyGridConstIterator it( this, wxPG_ITERATE_DEFAULT, pwc->Item(0) );
+            it.SetBaseParent( pwc );
+
+            for ( ; !it.AtEnd(); it.Next() )
+            {
+                const wxPGProperty* p = it.GetProperty();
+
+                // Use a trick to ignore wxParentProperty itself, but not its sub-properties.
+                if ( !p->GetChildCount() || p->HasFlag(wxPG_PROP_AGGREGATE) )
+                {
+                    wxVariant variant = p->GetValue();
+                    variant.SetName( p->GetName() );
+                    v.Append( variant );
+                    if ( (flags & wxPG_INC_ATTRIBUTES) && p->m_attributes.GetCount() )
+                        v.Append( p->GetAttributesAsList() );
+                }
+            }
+        }
+    }
+
+    return v;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::DoSetPropertyValues( const wxVariantList& list, wxPGProperty* defaultCategory )
+{
+    unsigned char origFrozen = 1;
+
+    if ( m_pPropGrid->GetState() == this )
+    {
+        origFrozen = m_pPropGrid->m_frozen;
+        if ( !origFrozen ) m_pPropGrid->Freeze();
+    }
+
+    wxPropertyCategory* use_category = (wxPropertyCategory*)defaultCategory;
+
+    if ( !use_category )
+        use_category = (wxPropertyCategory*)m_properties;
+
+    // Let's iterate over the list of variants.
+    wxVariantList::const_iterator node;
+    int numSpecialEntries = 0;
+
+    //
+    // Second pass for special entries
+    for ( node = list.begin(); node != list.end(); ++node )
+    {
+        wxVariant *current = (wxVariant*)*node;
+
+        // Make sure it is wxVariant.
+        wxASSERT( current );
+        wxASSERT( wxStrcmp(current->GetClassInfo()->GetClassName(),wxT("wxVariant")) == 0 );
+
+        const wxString& name = current->GetName();
+        if ( name.length() > 0 )
+        {
+            //
+            // '@' signified a special entry
+            if ( name[0] == wxS('@') )
+            {
+                numSpecialEntries++;
+            }
+            else
+            {
+                wxPGProperty* foundProp = BaseGetPropertyByName(name);
+                if ( foundProp )
+                {
+                    wxPGProperty* p = foundProp;
+
+                    // If it was a list, we still have to go through it.
+                    if ( wxStrcmp(current->GetType(), wxS("list")) == 0 )
+                    {
+                        DoSetPropertyValues( current->GetList(),
+                                p->IsCategory()?p:(NULL)
+                            );
+                    }
+                    else
+                    {
+                        wxASSERT_LEVEL_2_MSG(
+                            wxStrcmp(current->GetType(), p->GetValue().GetType()) == 0,
+                            wxString::Format(
+                                wxS("setting value of property \"%s\" from variant"),
+                                p->GetName().c_str())
+                        );
+
+                        p->SetValue(*current);
+                    }
+                }
+                else
+                {
+                    // Is it list?
+                    if ( current->GetType() != wxS("list") )
+                    {
+                        // Not.
+                    }
+                    else
+                    {
+                        // Yes, it is; create a sub category and append contents there.
+                        wxPGProperty* newCat = DoInsert(use_category,-1,new wxPropertyCategory(current->GetName(),wxPG_LABEL));
+                        DoSetPropertyValues( current->GetList(), newCat );
+                    }
+                }
+            }
+        }
+    }
+
+    if ( numSpecialEntries )
+    {
+        for ( node = list.begin(); node != list.end(); ++node )
+        {
+            wxVariant *current = (wxVariant*)*node;
+
+            const wxString& name = current->GetName();
+            if ( name.length() > 0 )
+            {
+                //
+                // '@' signified a special entry
+                if ( name[0] == wxS('@') )
+                {
+                    numSpecialEntries--;
+
+                    size_t pos2 = name.rfind(wxS('@'));
+                    if ( pos2 > 0 && pos2 < (name.size()-1) )
+                    {
+                        wxString propName = name.substr(1, pos2-1);
+                        wxString entryType = name.substr(pos2+1, wxString::npos);
+
+                        if ( entryType == wxS("attr") )
+                        {
+                            //
+                            // List of attributes
+                            wxPGProperty* foundProp = BaseGetPropertyByName(propName);
+                            if ( foundProp )
+                            {
+                                wxASSERT( current->GetType() == wxPG_VARIANT_TYPE_LIST );
+
+                                wxVariantList& list2 = current->GetList();
+                                wxVariantList::const_iterator node2;
+
+                                for ( node2 = list2.begin(); node2 != list2.end(); ++node2 )
+                                {
+                                    wxVariant *attr = (wxVariant*)*node2;
+                                    foundProp->SetAttribute( attr->GetName(), *attr );
+                                }
+                            }
+                            else
+                            {
+                                // ERROR: No such property: 'propName'
+                            }
+                        }
+                    }
+                    else
+                    {
+                        // ERROR: Special entry requires name of format @<propname>@<entrytype>
+                    }
+                }
+            }
+
+            if ( !numSpecialEntries )
+                break;
+        }
+    }
+
+    if ( !origFrozen )
+    {
+        m_pPropGrid->Thaw();
+
+        if ( this == m_pPropGrid->GetState() )
+            m_pPropGrid->RefreshEditor();
+    }
+
+}
+
+// -----------------------------------------------------------------------
+// wxPropertyGridPageState property adding and removal
+// -----------------------------------------------------------------------
+
+bool wxPropertyGridPageState::PrepareToAddItem( wxPGProperty* property,
+                                                wxPGProperty* scheduledParent )
+{
+    wxPropertyGrid* propGrid = m_pPropGrid;
+
+    // This will allow better behavior.
+    if ( scheduledParent == m_properties )
+        scheduledParent = NULL;
+
+    if ( scheduledParent && !scheduledParent->IsCategory() )
+    {
+        wxASSERT_MSG( property->GetBaseName().length(),
+                      "Property's children must have unique, non-empty names within their scope" );
+    }
+
+    property->m_parentState = this;
+
+    if ( property->IsCategory() )
+    {
+
+        // Parent of a category must be either root or another category
+        // (otherwise Bad Things might happen).
+        wxASSERT_MSG( scheduledParent == NULL ||
+                      scheduledParent == m_properties ||
+                      scheduledParent->IsCategory(),
+                 wxT("Parent of a category must be either root or another category."));
+
+        // If we already have category with same name, delete given property
+        // and use it instead as most recent caption item.
+        wxPGProperty* found_id = BaseGetPropertyByName( property->GetBaseName() );
+        if ( found_id )
+        {
+            wxPropertyCategory* pwc = (wxPropertyCategory*) found_id;
+            if ( pwc->IsCategory() ) // Must be a category.
+            {
+                delete property;
+                m_currentCategory = pwc;
+                return false;
+            }
+        }
+    }
+
+#if wxDEBUG_LEVEL
+    // Warn for identical names in debug mode.
+    if ( BaseGetPropertyByName(property->GetName()) &&
+         (!scheduledParent || scheduledParent->IsCategory()) )
+    {
+        wxFAIL_MSG(wxString::Format(
+            "wxPropertyGrid item with name \"%s\" already exists",
+            property->GetName()));
+
+        wxPGGlobalVars->m_warnings++;
+    }
+#endif // wxDEBUG_LEVEL
+
+    // Make sure nothing is selected.
+    if ( propGrid )
+        propGrid->ClearSelection(false);
+
+    // NULL parent == root parent
+    if ( !scheduledParent )
+        scheduledParent = DoGetRoot();
+
+    property->m_parent = scheduledParent;
+
+    property->InitAfterAdded(this, propGrid);
+
+    if ( property->IsCategory() )
+    {
+        wxPropertyCategory* pc = wxStaticCast(property, wxPropertyCategory);
+
+        m_currentCategory = pc;
+
+        // Calculate text extent for category caption
+        if ( propGrid )
+            pc->CalculateTextExtent(propGrid, propGrid->GetCaptionFont());
+    }
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPageState::DoAppend( wxPGProperty* property )
+{
+    wxPropertyCategory* cur_cat = m_currentCategory;
+    if ( property->IsCategory() )
+        cur_cat = NULL;
+
+    return DoInsert( cur_cat, -1, property );
+}
+
+// -----------------------------------------------------------------------
+
+wxPGProperty* wxPropertyGridPageState::DoInsert( wxPGProperty* parent, int index, wxPGProperty* property )
+{
+    if ( !parent )
+        parent = m_properties;
+
+    wxCHECK_MSG( !parent->HasFlag(wxPG_PROP_AGGREGATE),
+                 wxNullProperty,
+                 wxT("when adding properties to fixed parents, use BeginAddChildren and EndAddChildren.") );
+
+    bool res = PrepareToAddItem( property, (wxPropertyCategory*)parent );
+
+    // PrepareToAddItem() may just decide to use use current category
+    // instead of adding new one.
+    if ( !res )
+        return m_currentCategory;
+
+    bool parentIsRoot = parent->IsRoot();
+    bool parentIsCategory = parent->IsCategory();
+
+    // Note that item must be added into current mode later.
+
+    // If parent is wxParentProperty, just stick it in...
+    // If parent is root (m_properties), then...
+    //   In categoric mode: Add as last item in m_abcArray (if not category).
+    //                      Add to given index in m_regularArray.
+    //   In non-cat mode:   Add as last item in m_regularArray.
+    //                      Add to given index in m_abcArray.
+    // If parent is category, then...
+    //   1) Add to given category in given index.
+    //   2) Add as last item in m_abcArray.
+
+    if ( m_properties == &m_regularArray )
+    {
+        // We are currently in Categorized mode
+
+        // Only add non-categories to m_abcArray.
+        if ( m_abcArray && !property->IsCategory() &&
+             (parentIsCategory || parentIsRoot) )
+        {
+            m_abcArray->DoAddChild( property, -1, false );
+        }
+
+        // Add to current mode.
+        parent->DoAddChild( property, index, true );
+    }
+    else
+    {
+        // We are currently in Non-categorized/Alphabetic mode
+
+        if ( parentIsCategory )
+            // Parent is category.
+            parent->DoAddChild( property, index, false );
+        else if ( parentIsRoot )
+            // Parent is root.
+            m_regularArray.DoAddChild( property, -1, false );
+
+        // Add to current mode
+        if ( !property->IsCategory() )
+            m_abcArray->DoAddChild( property, index, true );
+    }
+
+    // category stuff
+    if ( property->IsCategory() )
+    {
+        // This is a category caption item.
+
+        // Last caption is not the bottom one (this info required by append)
+        m_lastCaptionBottomnest = 0;
+    }
+
+    // Only add name to hashmap if parent is root or category
+    if ( property->m_name.length() &&
+        (parentIsCategory || parentIsRoot) )
+        m_dictName[property->m_name] = (void*) property;
+
+    VirtualHeightChanged();
+
+    property->UpdateParentValues();
+
+    m_itemsAdded = 1;
+
+    return property;
+}
+
+// -----------------------------------------------------------------------
+
+void wxPropertyGridPageState::DoDelete( wxPGProperty* item, bool doDelete )
+{
+    wxCHECK_RET( item->GetParent(),
+        wxT("this property was already deleted") );
+
+    wxCHECK_RET( item != &m_regularArray && item != m_abcArray,
+        wxT("wxPropertyGrid: Do not attempt to remove the root item.") );
+
+    unsigned int indinparent = item->GetIndexInParent();
+
+    wxPGProperty* pwc = (wxPGProperty*)item;
+    wxPGProperty* parent = item->GetParent();
+
+    wxCHECK_RET( !parent->HasFlag(wxPG_PROP_AGGREGATE),
+        wxT("wxPropertyGrid: Do not attempt to remove sub-properties.") );
+
+    // Delete children
+    if ( item->GetChildCount() && !item->HasFlag(wxPG_PROP_AGGREGATE) )
+    {
+        // deleting a category
+        if ( item->IsCategory() )
+        {
+            if ( pwc == m_currentCategory )
+                m_currentCategory = NULL;
+        }
+
+        item->DeleteChildren();
+    }
+
+    if ( !IsInNonCatMode() )
+    {
+        // categorized mode - non-categorized array
+
+        // Remove from non-cat array
+        if ( !item->IsCategory() &&
+             (parent->IsCategory() || parent->IsRoot()) )
+        {
+            if ( m_abcArray )
+                m_abcArray->RemoveChild(item);
+        }
+
+        // categorized mode - categorized array
+        wxArrayPGProperty& parentsChildren = parent->m_children;
+        parentsChildren.erase( parentsChildren.begin() + indinparent );
+        item->m_parent->FixIndicesOfChildren();
+    }
+    else
+    {
+        // non-categorized mode - categorized array
+
+        // We need to find location of item.
+        wxPGProperty* cat_parent = &m_regularArray;
+        int cat_index = m_regularArray.GetChildCount();
+        size_t i;
+        for ( i = 0; i < m_regularArray.GetChildCount(); i++ )
+        {
+            wxPGProperty* p = m_regularArray.Item(i);
+            if ( p == item ) { cat_index = i; break; }
+            if ( p->IsCategory() )
+            {
+                int subind = ((wxPGProperty*)p)->Index(item);
+                if ( subind != wxNOT_FOUND )
+                {
+                    cat_parent = ((wxPGProperty*)p);
+                    cat_index = subind;
+                    break;
+                }
+            }
+        }
+        cat_parent->m_children.erase(cat_parent->m_children.begin()+cat_index);
+
+        // non-categorized mode - non-categorized array
+        if ( !item->IsCategory() )
+        {
+            wxASSERT( item->m_parent == m_abcArray );
+            wxArrayPGProperty& parentsChildren = item->m_parent->m_children;
+            parentsChildren.erase(parentsChildren.begin() + indinparent);
+            item->m_parent->FixIndicesOfChildren(indinparent);
+        }
+    }
+
+    if ( item->GetBaseName().length() && 
+         (parent->IsCategory() || parent->IsRoot()) )
+        m_dictName.erase(item->GetBaseName());
+
+    // We can actually delete it now
+    if ( doDelete )
+        delete item;
+
+    m_itemsAdded = 1; // Not a logical assignment (but required nonetheless).
+
+    VirtualHeightChanged();
+}
+
+// -----------------------------------------------------------------------
+
+#endif  // wxUSE_PROPGRID
Index: props.cpp
===================================================================
--- props.cpp	(revision 102)
+++ props.cpp	(working copy)
@@ -1,2611 +1,2611 @@
-/////////////////////////////////////////////////////////////////////////////
-// Name:        src/propgrid/props.cpp
-// Purpose:     Basic Property Classes
-// Author:      Jaakko Salli
-// Modified by:
-// Created:     2005-05-14
-// RCS-ID:      $Id: props.cpp 59497 2009-03-12 18:17:55Z JMS $
-// Copyright:   (c) Jaakko Salli
-// Licence:     wxWindows license
-/////////////////////////////////////////////////////////////////////////////
-
-// For compilers that support precompilation, includes "wx/wx.h".
-#include "wx/wxprec.h"
-
-#ifdef __BORLANDC__
-    #pragma hdrstop
-#endif
-
-#if wxUSE_PROPGRID
-
-#ifndef WX_PRECOMP
-    #include "wx/defs.h"
-    #include "wx/object.h"
-    #include "wx/hash.h"
-    #include "wx/string.h"
-    #include "wx/log.h"
-    #include "wx/event.h"
-    #include "wx/window.h"
-    #include "wx/panel.h"
-    #include "wx/dc.h"
-    #include "wx/dcclient.h"
-    #include "wx/dcmemory.h"
-    #include "wx/button.h"
-    #include "wx/pen.h"
-    #include "wx/brush.h"
-    #include "wx/cursor.h"
-    #include "wx/dialog.h"
-    #include "wx/settings.h"
-    #include "wx/msgdlg.h"
-    #include "wx/choice.h"
-    #include "wx/stattext.h"
-    #include "wx/scrolwin.h"
-    #include "wx/dirdlg.h"
-    #include "wx/combobox.h"
-    #include "wx/layout.h"
-    #include "wx/sizer.h"
-    #include "wx/textdlg.h"
-    #include "wx/filedlg.h"
-    #include "wx/intl.h"
-#endif
-
-#include "wx/filename.h"
-
-#include "wx/propgrid/propgrid.h"
-
-#define wxPG_CUSTOM_IMAGE_WIDTH     20 // for wxColourProperty etc.
-
-
-// -----------------------------------------------------------------------
-// wxStringProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxStringProperty,wxPGProperty,
-                               wxString,const wxString&,TextCtrl)
-
-wxStringProperty::wxStringProperty( const wxString& label,
-                                    const wxString& name,
-                                    const wxString& value )
-    : wxPGProperty(label,name)
-{
-    SetValue(value);
-}
-
-void wxStringProperty::OnSetValue()
-{
-    if ( !m_value.IsNull() && m_value.GetString() == wxS("<composed>") )
-        SetFlag(wxPG_PROP_COMPOSED_VALUE);
-
-    if ( HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-    {
-        wxString s;
-        DoGenerateComposedValue(s);
-        m_value = s;
-    }
-}
-
-wxStringProperty::~wxStringProperty() { }
-
-wxString wxStringProperty::ValueToString( wxVariant& value,
-                                          int argFlags ) const
-{
-    wxString s = value.GetString();
-
-    if ( GetChildCount() && HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-    {
-        // Value stored in m_value is non-editable, non-full value
-        if ( (argFlags & wxPG_FULL_VALUE) || (argFlags & wxPG_EDITABLE_VALUE) )
-        {
-            // Calling this under incorrect conditions will fail
-            wxASSERT_MSG( argFlags & wxPG_VALUE_IS_CURRENT,
-                          "Sorry, currently default wxPGProperty::ValueToString() "
-                          "implementation only works if value is m_value." );
-
-            DoGenerateComposedValue(s, argFlags);
-        }
-
-        return s;
-    }
-
-    // If string is password and value is for visual purposes,
-    // then return asterisks instead the actual string.
-    if ( (m_flags & wxPG_PROP_PASSWORD) && !(argFlags & (wxPG_FULL_VALUE|wxPG_EDITABLE_VALUE)) )
-        return wxString(wxChar('*'), s.Length());
-
-    return s;
-}
-
-bool wxStringProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
-{
-    if ( GetChildCount() && HasFlag(wxPG_PROP_COMPOSED_VALUE) )
-        return wxPGProperty::StringToValue(variant, text, argFlags);
-
-    if ( variant != text )
-    {
-        variant = text;
-        return true;
-    }
-
-    return false;
-}
-
-bool wxStringProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    if ( name == wxPG_STRING_PASSWORD )
-    {
-        m_flags &= ~(wxPG_PROP_PASSWORD);
-        if ( wxPGVariantToInt(value) ) m_flags |= wxPG_PROP_PASSWORD;
-        RecreateEditor();
-        return false;
-    }
-    return true;
-}
-
-// -----------------------------------------------------------------------
-// wxIntProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxIntProperty,wxPGProperty,
-                               long,long,TextCtrl)
-
-wxIntProperty::wxIntProperty( const wxString& label, const wxString& name,
-    long value ) : wxPGProperty(label,name)
-{
-    SetValue(value);
-}
-
-wxIntProperty::wxIntProperty( const wxString& label, const wxString& name,
-    const wxLongLong& value ) : wxPGProperty(label,name)
-{
-    SetValue(WXVARIANT(value));
-}
-
-wxIntProperty::~wxIntProperty() { }
-
-wxString wxIntProperty::ValueToString( wxVariant& value,
-                                       int WXUNUSED(argFlags) ) const
-{
-    if ( value.GetType() == wxPG_VARIANT_TYPE_LONG )
-    {
-        return wxString::Format(wxS("%li"),value.GetLong());
-    }
-    else if ( value.GetType() == wxLongLong_VariantType )
-    {
-	    wxLongLong ll;
-        ll << value;
-	    return ll.ToString();
-    }
-
-    return wxEmptyString;
-}
-
-bool wxIntProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
-{
-    wxString s;
-    long value32;
-
-    if ( text.length() == 0 )
-    {
-        variant.MakeNull();
-        return true;
-    }
-
-    // We know it is a number, but let's still check
-    // the return value.
-    if ( text.IsNumber() )
-    {
-        // Remove leading zeroes, so that the number is not interpreted as octal
-        wxString::const_iterator i = text.begin();
-        wxString::const_iterator iMax = text.end() - 1;  // Let's allow one, last zero though
-
-        int firstNonZeroPos = 0;
-
-        for ( ; i != iMax; ++i )
-        {
-            wxChar c = *i;
-            if ( c != wxS('0') && c != wxS(' ') )
-                break;
-            firstNonZeroPos++;
-        }
-
-        wxString useText = text.substr(firstNonZeroPos, text.length() - firstNonZeroPos);
-
-        wxString variantType = variant.GetType();
-        bool isPrevLong = variantType == wxPG_VARIANT_TYPE_LONG;
-
-        wxLongLong_t value64 = 0;
-
-        if ( useText.ToLongLong(&value64, 10) &&
-             ( value64 >= INT_MAX || value64 <= INT_MIN )
-           )
-        {
-            bool doChangeValue = isPrevLong;
-
-            if ( !isPrevLong && variantType == wxLongLong_VariantType )
-            {
-                wxLongLong oldValue;
-                oldValue << variant;
-                if ( oldValue.GetValue() != value64 )
-                    doChangeValue = true;
-            }
-
-            if ( doChangeValue )
-            {
-                wxLongLong ll(value64);
-                variant << ll;
-                return true;
-            }
-        }
-
-        if ( useText.ToLong( &value32, 0 ) )
-        {
-            if ( !isPrevLong || variant != value32 )
-            {
-                variant = value32;
-                return true;
-            }
-        }
-    }
-    else if ( argFlags & wxPG_REPORT_ERROR )
-    {
-    }
-    return false;
-}
-
-bool wxIntProperty::IntToValue( wxVariant& variant, int value, int WXUNUSED(argFlags) ) const
-{
-    if ( variant.GetType() != wxPG_VARIANT_TYPE_LONG || variant != (long)value )
-    {
-        variant = (long)value;
-        return true;
-    }
-    return false;
-}
-
-bool wxIntProperty::DoValidation( const wxPGProperty* property, wxLongLong_t& value, wxPGValidationInfo* pValidationInfo, int mode )
-{
-    // Check for min/max
-    wxLongLong_t min = wxINT64_MIN;
-    wxLongLong_t max = wxINT64_MAX;
-    wxVariant variant;
-    bool minOk = false;
-    bool maxOk = false;
-
-    variant = property->GetAttribute(wxPGGlobalVars->m_strMin);
-    if ( !variant.IsNull() )
-    {
-        wxPGVariantToLongLong(variant, &min);
-        minOk = true;
-    }
-
-    variant = property->GetAttribute(wxPGGlobalVars->m_strMax);
-    if ( !variant.IsNull() )
-    {
-        wxPGVariantToLongLong(variant, &max);
-        maxOk = true;
-    }
-
-    if ( minOk )
-    {
-        if ( value < min )
-        {
-            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
-                pValidationInfo->SetFailureMessage(
-                    wxString::Format(_("Value must be %lld or higher"),min)
-                    );
-            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
-                value = min;
-            else
-                value = max - (min - value);
-            return false;
-        }
-    }
-
-    if ( maxOk )
-    {
-        if ( value > max )
-        {
-            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
-                pValidationInfo->SetFailureMessage(
-                    wxString::Format(_("Value must be %lld or higher"),min)
-                    );
-            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
-                value = max;
-            else
-                value = min + (value - max);
-            return false;
-        }
-    }
-    return true;
-}
-
-bool wxIntProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& validationInfo ) const
-{
-    wxLongLong_t ll;
-    if ( wxPGVariantToLongLong(value, &ll) )
-        return DoValidation(this, ll, &validationInfo, wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE);
-    return true;
-}
-
-wxValidator* wxIntProperty::GetClassValidator()
-{
-#if wxUSE_VALIDATORS
-    WX_PG_DOGETVALIDATOR_ENTRY()
-
-    // Atleast wxPython 2.6.2.1 required that the string argument is given
-    static wxString v;
-    wxTextValidator* validator = new wxTextValidator(wxFILTER_NUMERIC,&v);
-
-    WX_PG_DOGETVALIDATOR_EXIT(validator)
-#else
-    return NULL;
-#endif
-}
-
-wxValidator* wxIntProperty::DoGetValidator() const
-{
-    return GetClassValidator();
-}
-
-// -----------------------------------------------------------------------
-// wxUIntProperty
-// -----------------------------------------------------------------------
-
-
-#define wxPG_UINT_TEMPLATE_MAX 8
-
-static const wxChar* gs_uintTemplates32[wxPG_UINT_TEMPLATE_MAX] = {
-    wxT("%x"),wxT("0x%x"),wxT("$%x"),
-    wxT("%X"),wxT("0x%X"),wxT("$%X"),
-    wxT("%u"),wxT("%o")
-};
-
-static const wxChar* gs_uintTemplates64[wxPG_UINT_TEMPLATE_MAX] = {
-    wxT("%") wxLongLongFmtSpec wxT("x"),
-    wxT("0x%") wxLongLongFmtSpec wxT("x"),
-    wxT("$%") wxLongLongFmtSpec wxT("x"),
-    wxT("%") wxLongLongFmtSpec wxT("X"),
-    wxT("0x%") wxLongLongFmtSpec wxT("X"),
-    wxT("$%") wxLongLongFmtSpec wxT("X"),
-    wxT("%") wxLongLongFmtSpec wxT("u"),
-    wxT("%") wxLongLongFmtSpec wxT("o")
-};
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxUIntProperty,wxPGProperty,
-                               long,unsigned long,TextCtrl)
-
-void wxUIntProperty::Init()
-{
-    m_base = 6; // This is magic number for dec base (must be same as in setattribute)
-    m_realBase = 10;
-    m_prefix = wxPG_PREFIX_NONE;
-}
-
-wxUIntProperty::wxUIntProperty( const wxString& label, const wxString& name,
-    unsigned long value ) : wxPGProperty(label,name)
-{
-    Init();
-    SetValue((long)value);
-}
-
-wxUIntProperty::wxUIntProperty( const wxString& label, const wxString& name,
-    const wxULongLong& value ) : wxPGProperty(label,name)
-{
-    Init();
-    SetValue(WXVARIANT(value));
-}
-
-wxUIntProperty::~wxUIntProperty() { }
-
-wxString wxUIntProperty::ValueToString( wxVariant& value,
-                                        int WXUNUSED(argFlags) ) const
-{
-    size_t index = m_base + m_prefix;
-    if ( index >= wxPG_UINT_TEMPLATE_MAX )
-        index = wxPG_BASE_DEC;
-
-    if ( value.GetType() == wxPG_VARIANT_TYPE_LONG )
-    {
-        return wxString::Format(gs_uintTemplates32[index], (unsigned long)value.GetLong());
-    }
-
-    wxULongLong ull;
-    ull << value;
-
-    return wxString::Format(gs_uintTemplates64[index], ull.GetValue());
-}
-
-bool wxUIntProperty::StringToValue( wxVariant& variant, const wxString& text, int WXUNUSED(argFlags) ) const
-{
-    wxString variantType = variant.GetType();
-    bool isPrevLong = variantType == wxPG_VARIANT_TYPE_LONG;
-
-    if ( text.length() == 0 )
-    {
-        variant.MakeNull();
-        return true;
-    }
-
-    size_t start = 0;
-    if ( text[0] == wxS('$') )
-        start++;
-
-    wxULongLong_t value64 = 0;
-    wxString s = text.substr(start, text.length() - start);
-
-    if ( s.ToULongLong(&value64, (unsigned int)m_realBase) )
-    {
-        if ( value64 >= LONG_MAX )
-        {
-            bool doChangeValue = isPrevLong;
-
-            if ( !isPrevLong && variantType == wxULongLong_VariantType )
-            {
-                wxULongLong oldValue;
-                oldValue << variant;
-                if ( oldValue.GetValue() != value64 )
-                    doChangeValue = true;
-            }
-
-            if ( doChangeValue )
-            {
-                wxULongLong ull(value64);
-                variant << ull;
-                return true;
-            }
-        }
-        else
-        {
-            unsigned long value32 = wxLongLong(value64).GetLo();
-            if ( !isPrevLong || m_value != (long)value32 )
-            {
-                variant = (long)value32;
-                return true;
-            }
-        }
-
-    }
-    return false;
-}
-
-bool wxUIntProperty::IntToValue( wxVariant& variant, int number, int WXUNUSED(argFlags) ) const
-{
-    if ( variant != (long)number )
-    {
-        variant = (long)number;
-        return true;
-    }
-    return false;
-}
-
-#ifdef ULLONG_MAX
-  #define wxUINT64_MAX ULLONG_MAX
-  #define wxUINT64_MIN wxULL(0)
-#else
-  #define wxUINT64_MAX wxULL(0xFFFFFFFFFFFFFFFF)
-  #define wxUINT64_MIN wxULL(0)
-#endif
-
-bool wxUIntProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& validationInfo ) const
-{
-    // Check for min/max
-    wxULongLong_t ll;
-    if ( wxPGVariantToULongLong(value, &ll) )
-    {
-        wxULongLong_t min = wxUINT64_MIN;
-        wxULongLong_t max = wxUINT64_MAX;
-        wxVariant variant;
-
-        variant = GetAttribute(wxPGGlobalVars->m_strMin);
-        if ( !variant.IsNull() )
-        {
-            wxPGVariantToULongLong(variant, &min);
-            if ( ll < min )
-            {
-                validationInfo.SetFailureMessage(
-                    wxString::Format(_("Value must be %llu or higher"),min)
-                    );
-                return false;
-            }
-        }
-        variant = GetAttribute(wxPGGlobalVars->m_strMax);
-        if ( !variant.IsNull() )
-        {
-            wxPGVariantToULongLong(variant, &max);
-            if ( ll > max )
-            {
-                validationInfo.SetFailureMessage(
-                    wxString::Format(_("Value must be %llu or less"),max)
-                    );
-                return false;
-            }
-        }
-    }
-    return true;
-}
-
-bool wxUIntProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    if ( name == wxPG_UINT_BASE )
-    {
-        int val = value.GetLong();
-
-        m_realBase = (wxByte) val;
-        if ( m_realBase > 16 )
-            m_realBase = 16;
-
-        //
-        // Translate logical base to a template array index
-        m_base = 7; // oct
-        if ( val == wxPG_BASE_HEX )
-            m_base = 3;
-        else if ( val == wxPG_BASE_DEC )
-            m_base = 6;
-        else if ( val == wxPG_BASE_HEXL )
-            m_base = 0;
-        return true;
-    }
-    else if ( name == wxPG_UINT_PREFIX )
-    {
-        m_prefix = (wxByte) value.GetLong();
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxFloatProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxFloatProperty,wxPGProperty,
-                               double,double,TextCtrl)
-
-wxFloatProperty::wxFloatProperty( const wxString& label,
-                                            const wxString& name,
-                                            double value )
-    : wxPGProperty(label,name)
-{
-    m_precision = -1;
-    SetValue(value);
-}
-
-wxFloatProperty::~wxFloatProperty() { }
-
-// This helper method provides standard way for floating point-using
-// properties to convert values to string.
-void wxPropertyGrid::DoubleToString(wxString& target,
-                                    double value,
-                                    int precision,
-                                    bool removeZeroes,
-                                    wxString* precTemplate)
-{
-    if ( precision >= 0 )
-    {
-        wxString text1;
-        if (!precTemplate)
-            precTemplate = &text1;
-
-        if ( !precTemplate->length() )
-        {
-            *precTemplate = wxS("%.");
-            *precTemplate << wxString::Format( wxS("%i"), precision );
-            *precTemplate << wxS('f');
-        }
-
-        target.Printf( precTemplate->c_str(), value );
-    }
-    else
-    {
-        target.Printf( wxS("%f"), value );
-    }
-
-    if ( removeZeroes && precision != 0 && target.length() )
-    {
-        // Remove excess zeroes (do not remove this code just yet,
-        // since sprintf can't do the same consistently across platforms).
-        wxString::const_iterator i = target.end() - 1;
-        size_t new_len = target.length() - 1;
-
-        for ( ; i != target.begin(); --i )
-        {
-            if ( *i != wxS('0') )
-                break;
-            new_len--;
-        }
-
-        wxChar cur_char = *i;
-        if ( cur_char != wxS('.') && cur_char != wxS(',') )
-            new_len++;
-
-        if ( new_len != target.length() )
-            target.resize(new_len);
-    }
-}
-
-wxString wxFloatProperty::ValueToString( wxVariant& value,
-                                         int argFlags ) const
-{
-    wxString text;
-    if ( !value.IsNull() )
-    {
-        wxPropertyGrid::DoubleToString(text,
-                                       value,
-                                       m_precision,
-                                       !(argFlags & wxPG_FULL_VALUE),
-                                       NULL);
-    }
-    return text;
-}
-
-bool wxFloatProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
-{
-    wxString s;
-    double value;
-
-    if ( text.length() == 0 )
-    {
-        variant.MakeNull();
-        return true;
-    }
-
-    bool res = text.ToDouble(&value);
-    if ( res )
-    {
-        if ( variant != value )
-        {
-            variant = value;
-            return true;
-        }
-    }
-    else if ( argFlags & wxPG_REPORT_ERROR )
-    {
-    }
-    return false;
-}
-
-bool wxFloatProperty::DoValidation( const wxPGProperty* property, double& value, wxPGValidationInfo* pValidationInfo, int mode )
-{
-    // Check for min/max
-    double min = (double)wxINT64_MIN;
-    double max = (double)wxINT64_MAX;
-    wxVariant variant;
-    bool minOk = false;
-    bool maxOk = false;
-
-    variant = property->GetAttribute(wxPGGlobalVars->m_strMin);
-    if ( !variant.IsNull() )
-    {
-        wxPGVariantToDouble(variant, &min);
-        minOk = true;
-    }
-
-    variant = property->GetAttribute(wxPGGlobalVars->m_strMax);
-    if ( !variant.IsNull() )
-    {
-        wxPGVariantToDouble(variant, &max);
-        maxOk = true;
-    }
-
-    if ( minOk )
-    {
-        if ( value < min )
-        {
-            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
-                pValidationInfo->SetFailureMessage(
-                    wxString::Format(_("Value must be %f or higher"),min)
-                    );
-            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
-                value = min;
-            else
-                value = max - (min - value);
-            return false;
-        }
-    }
-
-    if ( maxOk )
-    {
-        wxPGVariantToDouble(variant, &max);
-        if ( value > max )
-        {
-            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
-                pValidationInfo->SetFailureMessage(
-                    wxString::Format(_("Value must be %f or less"),max)
-                    );
-            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
-                value = max;
-            else
-                value = min + (value - max);
-            return false;
-        }
-    }
-    return true;
-}
-
-bool wxFloatProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& validationInfo ) const
-{
-    double fpv;
-    if ( wxPGVariantToDouble(value, &fpv) )
-        return DoValidation(this, fpv, &validationInfo, wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE);
-    return true;
-}
-
-bool wxFloatProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    if ( name == wxPG_FLOAT_PRECISION )
-    {
-        m_precision = value.GetLong();
-        return true;
-    }
-    return false;
-}
-
-wxValidator* wxFloatProperty::DoGetValidator() const
-{
-    return wxIntProperty::GetClassValidator();
-}
-
-// -----------------------------------------------------------------------
-// wxBoolProperty
-// -----------------------------------------------------------------------
-
-// We cannot use standard WX_PG_IMPLEMENT_PROPERTY_CLASS macro, since
-// there is a custom GetEditorClass.
-
-IMPLEMENT_DYNAMIC_CLASS(wxBoolProperty, wxPGProperty)
-
-const wxPGEditor* wxBoolProperty::DoGetEditorClass() const
-{
-    // Select correct editor control.
-#if wxPG_INCLUDE_CHECKBOX
-    if ( !(m_flags & wxPG_PROP_USE_CHECKBOX) )
-        return wxPGEditor_Choice;
-    return wxPGEditor_CheckBox;
-#else
-    return wxPGEditor_Choice;
-#endif
-}
-
-wxBoolProperty::wxBoolProperty( const wxString& label, const wxString& name, bool value ) :
-    wxPGProperty(label,name)
-{
-    m_choices.Assign(wxPGGlobalVars->m_boolChoices);
-
-    SetValue(wxPGVariant_Bool(value));
-
-    m_flags |= wxPG_PROP_USE_DCC;
-}
-
-wxBoolProperty::~wxBoolProperty() { }
-
-wxString wxBoolProperty::ValueToString( wxVariant& value,
-                                        int argFlags ) const
-{
-    bool boolValue = value.GetBool();
-
-    // As a fragment of composite string value,
-    // make it a little more readable.
-    if ( argFlags & wxPG_COMPOSITE_FRAGMENT )
-    {
-        if ( boolValue )
-        {
-            return m_label;
-        }
-        else
-        {
-            if ( argFlags & wxPG_UNEDITABLE_COMPOSITE_FRAGMENT )
-                return wxEmptyString;
-
-            wxString notFmt;
-            if ( wxPGGlobalVars->m_autoGetTranslation )
-                notFmt = _("Not %s");
-            else
-                notFmt = wxS("Not %s");
-
-            return wxString::Format(notFmt.c_str(), m_label.c_str());
-        }
-    }
-
-    if ( !(argFlags & wxPG_FULL_VALUE) )
-    {
-        return wxPGGlobalVars->m_boolChoices[boolValue?1:0].GetText();
-    }
-
-    wxString text;
-
-    if ( boolValue ) text = wxS("true");
-    else text = wxS("false");
-
-    return text;
-}
-
-bool wxBoolProperty::StringToValue( wxVariant& variant, const wxString& text, int WXUNUSED(argFlags) ) const
-{
-    bool boolValue = false;
-    if ( text.CmpNoCase(wxPGGlobalVars->m_boolChoices[1].GetText()) == 0 ||
-         text.CmpNoCase(wxS("true")) == 0 ||
-         text.CmpNoCase(m_label) == 0 )
-        boolValue = true;
-
-    if ( text.length() == 0 )
-    {
-        variant.MakeNull();
-        return true;
-    }
-
-    if ( variant != boolValue )
-    {
-        variant = wxPGVariant_Bool(boolValue);
-        return true;
-    }
-    return false;
-}
-
-bool wxBoolProperty::IntToValue( wxVariant& variant, int value, int ) const
-{
-    bool boolValue = value ? true : false;
-
-    if ( variant != boolValue )
-    {
-        variant = wxPGVariant_Bool(boolValue);
-        return true;
-    }
-    return false;
-}
-
-bool wxBoolProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-#if wxPG_INCLUDE_CHECKBOX
-    if ( name == wxPG_BOOL_USE_CHECKBOX )
-    {
-        int ival = wxPGVariantToInt(value);
-        if ( ival )
-            m_flags |= wxPG_PROP_USE_CHECKBOX;
-        else
-            m_flags &= ~(wxPG_PROP_USE_CHECKBOX);
-        return true;
-    }
-#endif
-    if ( name == wxPG_BOOL_USE_DOUBLE_CLICK_CYCLING )
-    {
-        int ival = wxPGVariantToInt(value);
-        if ( ival )
-            m_flags |= wxPG_PROP_USE_DCC;
-        else
-            m_flags &= ~(wxPG_PROP_USE_DCC);
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxEnumProperty
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxEnumProperty, wxPGProperty)
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxEnumProperty,long,Choice)
-
-wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
-    const long* values, int value ) : wxPGProperty(label,name)
-{
-    SetIndex(0);
-
-    if ( labels )
-    {
-        m_choices.Add(labels,values);
-
-        if ( GetItemCount() )
-            SetValue( (long)value );
-    }
-}
-
-wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
-    const long* values, wxPGChoices* choicesCache, int value )
-    : wxPGProperty(label,name)
-{
-    SetIndex(0);
-
-    wxASSERT( choicesCache );
-
-    if ( choicesCache->IsOk() )
-    {
-        m_choices.Assign( *choicesCache );
-        m_value = wxPGVariant_Zero;
-    }
-    else if ( labels )
-    {
-        m_choices.Add(labels,values);
-
-        if ( GetItemCount() )
-            SetValue( (long)value );
-    }
-}
-
-wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name,
-    const wxArrayString& labels, const wxArrayInt& values, int value )
-    : wxPGProperty(label,name)
-{
-    SetIndex(0);
-
-    if ( &labels && labels.size() )
-    {
-        m_choices.Set(labels, values);
-
-        if ( GetItemCount() )
-            SetValue( (long)value );
-    }
-}
-
-wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name,
-    wxPGChoices& choices, int value )
-    : wxPGProperty(label,name)
-{
-    m_choices.Assign( choices );
-
-    if ( GetItemCount() )
-        SetValue( (long)value );
-}
-
-int wxEnumProperty::GetIndexForValue( int value ) const
-{
-    if ( !m_choices.IsOk() )
-        return -1;
-
-    int intVal = m_choices.Index(value);
-    if ( intVal >= 0 )
-        return intVal;
-
-    return value;
-}
-
-wxEnumProperty::~wxEnumProperty ()
-{
-}
-
-int wxEnumProperty::ms_nextIndex = -2;
-
-void wxEnumProperty::OnSetValue()
-{
-    wxString variantType = m_value.GetType();
-
-    if ( variantType == wxPG_VARIANT_TYPE_LONG )
-        ValueFromInt_( m_value, m_value.GetLong(), wxPG_FULL_VALUE );
-    else if ( variantType == wxPG_VARIANT_TYPE_STRING )
-        ValueFromString_( m_value, m_value.GetString(), 0 );
-    else
-        wxFAIL;
-
-    if ( ms_nextIndex != -2 )
-    {
-        m_index = ms_nextIndex;
-        ms_nextIndex = -2;
-    }
-}
-
-bool wxEnumProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& WXUNUSED(validationInfo) ) const
-{
-    // Make sure string value is in the list,
-    // unless property has string as preferred value type
-    // To reduce code size, use conversion here as well
-    if ( value.GetType() == wxPG_VARIANT_TYPE_STRING &&
-         !this->IsKindOf(CLASSINFO(wxEditEnumProperty)) )
-        return ValueFromString_( value, value.GetString(), wxPG_PROPERTY_SPECIFIC );
-
-    return true;
-}
-
-wxString wxEnumProperty::ValueToString( wxVariant& value,
-                                            int WXUNUSED(argFlags) ) const
-{
-    if ( value.GetType() == wxPG_VARIANT_TYPE_STRING )
-        return value.GetString();
-
-    int index = m_choices.Index(value.GetLong());
-    if ( index < 0 )
-        return wxEmptyString;
-
-    return m_choices.GetLabel(index);
-}
-
-bool wxEnumProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
-{
-    return ValueFromString_( variant, text, argFlags );
-}
-
-bool wxEnumProperty::IntToValue( wxVariant& variant, int intVal, int argFlags ) const
-{
-    return ValueFromInt_( variant, intVal, argFlags );
-}
-
-bool wxEnumProperty::ValueFromString_( wxVariant& value, const wxString& text, int argFlags ) const
-{
-    int useIndex = -1;
-    long useValue = 0;
-
-    for ( unsigned int i=0; i<m_choices.GetCount(); i++ )
-    {
-        const wxString& entryLabel = m_choices.GetLabel(i);
-        if ( text.CmpNoCase(entryLabel) == 0 )
-        {
-            useIndex = (int)i;
-            useValue = m_choices.GetValue(i);
-            break;
-        }
-    }
-
-    bool asText = false;
-
-    bool isEdit = this->IsKindOf(CLASSINFO(wxEditEnumProperty));
-
-    // If text not any of the choices, store as text instead
-    // (but only if we are wxEditEnumProperty)
-    if ( useIndex == -1 &&
-         (value.GetType() != wxPG_VARIANT_TYPE_STRING || (m_value.GetString() != text)) &&
-         isEdit )
-    {
-        asText = true;
-    }
-
-    int setAsNextIndex = -2;
-
-    if ( asText )
-    {
-        setAsNextIndex = -1;
-        value = text;
-    }
-    else if ( useIndex != GetIndex() )
-    {
-        if ( useIndex != -1 )
-        {
-            setAsNextIndex = useIndex;
-            value = (long)useValue;
-        }
-        else
-        {
-            setAsNextIndex = -1;
-            value = wxPGVariant_MinusOne;
-        }
-    }
-
-    if ( setAsNextIndex != -2 )
-    {
-        // If wxPG_PROPERTY_SPECIFIC is set, then this is done for
-        // validation purposes only, and index must not be changed
-        if ( !(argFlags & wxPG_PROPERTY_SPECIFIC) )
-            ms_nextIndex = setAsNextIndex;
-
-        if ( isEdit || setAsNextIndex != -1 )
-            return true;
-        else
-            return false;
-    }
-    return false;
-}
-
-bool wxEnumProperty::ValueFromInt_( wxVariant& variant, int intVal, int argFlags ) const
-{
-    // If wxPG_FULL_VALUE is *not* in argFlags, then intVal is index from combo box.
-    //
-    ms_nextIndex = -2;
-
-    if ( argFlags & wxPG_FULL_VALUE )
-    {
-        ms_nextIndex = GetIndexForValue( intVal );
-    }
-    else
-    {
-        if ( intVal != GetIndex() )
-        {
-            ms_nextIndex = intVal;
-        }
-    }
-
-    if ( ms_nextIndex != -2 )
-    {
-        if ( !(argFlags & wxPG_FULL_VALUE) )
-            intVal = m_choices.GetValue(intVal);
-
-        variant = (long)intVal;
-
-        return true;
-    }
-
-    return false;
-}
-
-void
-wxEnumProperty::OnValidationFailure( wxVariant& WXUNUSED(pendingValue) )
-{
-    // Revert index
-    ResetNextIndex();
-}
-
-void wxEnumProperty::SetIndex( int index )
-{
-    ms_nextIndex = -2;
-    m_index = index;
-}
-
-int wxEnumProperty::GetIndex() const
-{
-    if ( m_value.IsNull() )
-        return -1;
-
-    if ( ms_nextIndex != -2 )
-        return ms_nextIndex;
-
-    return m_index;
-}
-
-// -----------------------------------------------------------------------
-// wxEditEnumProperty
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxEditEnumProperty, wxPGProperty)
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxEditEnumProperty,wxString,ComboBox)
-
-wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
-    const long* values, const wxString& value )
-    : wxEnumProperty(label,name,labels,values,0)
-{
-    SetValue( value );
-}
-
-wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
-    const long* values, wxPGChoices* choicesCache, const wxString& value )
-    : wxEnumProperty(label,name,labels,values,choicesCache,0)
-{
-    SetValue( value );
-}
-
-wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name,
-    const wxArrayString& labels, const wxArrayInt& values, const wxString& value )
-    : wxEnumProperty(label,name,labels,values,0)
-{
-    SetValue( value );
-}
-
-wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name,
-    wxPGChoices& choices, const wxString& value )
-    : wxEnumProperty(label,name,choices,0)
-{
-    SetValue( value );
-}
-
-wxEditEnumProperty::~wxEditEnumProperty()
-{
-}
-
-// -----------------------------------------------------------------------
-// wxFlagsProperty
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxFlagsProperty,wxPGProperty)
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxFlagsProperty,long,TextCtrl)
-
-void wxFlagsProperty::Init()
-{
-    long value = m_value;
-
-    //
-    // Generate children
-    //
-    unsigned int i;
-
-    unsigned int prevChildCount = m_children.size();
-
-    int oldSel = -1;
-    if ( prevChildCount )
-    {
-        wxPropertyGridPageState* state = GetParentState();
-
-        // State safety check (it may be NULL in immediate parent)
-        wxASSERT( state );
-
-        if ( state )
-        {
-            wxPGProperty* selected = state->GetSelection();
-            if ( selected )
-            {
-                if ( selected->GetParent() == this )
-                    oldSel = selected->GetIndexInParent();
-                else if ( selected == this )
-                    oldSel = -2;
-            }
-        }
-        state->DoClearSelection();
-    }
-
-    // Delete old children
-    for ( i=0; i<prevChildCount; i++ )
-        delete m_children[i];
-
-    m_children.clear();
-
-    if ( m_choices.IsOk() )
-    {
-        const wxPGChoices& choices = m_choices;
-
-        for ( i=0; i<GetItemCount(); i++ )
-        {
-            bool child_val;
-            child_val = ( value & choices.GetValue(i) )?true:false;
-
-            wxPGProperty* boolProp;
-            wxString label = GetLabel(i);
-
-        #if wxUSE_INTL
-            if ( wxPGGlobalVars->m_autoGetTranslation )
-            {
-                boolProp = new wxBoolProperty( ::wxGetTranslation(label), label, child_val );
-            }
-            else
-        #endif
-            {
-                boolProp = new wxBoolProperty( label, label, child_val );
-            }
-            AddPrivateChild(boolProp);
-        }
-
-        m_oldChoicesData = m_choices.GetDataPtr();
-    }
-
-    m_oldValue = m_value;
-
-    if ( prevChildCount )
-        SubPropsChanged(oldSel);
-}
-
-wxFlagsProperty::wxFlagsProperty( const wxString& label, const wxString& name,
-    const wxChar** labels, const long* values, long value ) : wxPGProperty(label,name)
-{
-    m_oldChoicesData = NULL;
-
-    if ( labels )
-    {
-        m_choices.Set(labels,values);
-
-        wxASSERT( GetItemCount() );
-
-        SetValue( value );
-    }
-    else
-    {
-        m_value = wxPGVariant_Zero;
-    }
-}
-
-wxFlagsProperty::wxFlagsProperty( const wxString& label, const wxString& name,
-        const wxArrayString& labels, const wxArrayInt& values, int value )
-    : wxPGProperty(label,name)
-{
-    m_oldChoicesData = NULL;
-
-    if ( &labels && labels.size() )
-    {
-        m_choices.Set(labels,values);
-
-        wxASSERT( GetItemCount() );
-
-        SetValue( (long)value );
-    }
-    else
-    {
-        m_value = wxPGVariant_Zero;
-    }
-}
-
-wxFlagsProperty::wxFlagsProperty( const wxString& label, const wxString& name,
-    wxPGChoices& choices, long value )
-    : wxPGProperty(label,name)
-{
-    m_oldChoicesData = NULL;
-
-    if ( choices.IsOk() )
-    {
-        m_choices.Assign(choices);
-
-        wxASSERT( GetItemCount() );
-
-        SetValue( value );
-    }
-    else
-    {
-        m_value = wxPGVariant_Zero;
-    }
-}
-
-wxFlagsProperty::~wxFlagsProperty()
-{
-}
-
-void wxFlagsProperty::OnSetValue()
-{
-    if ( !m_choices.IsOk() || !GetItemCount() )
-    {
-        m_value = wxPGVariant_Zero;
-    }
-    else
-    {
-        long val = m_value.GetLong();
-
-        long fullFlags = 0;
-
-        // normalize the value (i.e. remove extra flags)
-        unsigned int i;
-        const wxPGChoices& choices = m_choices;
-        for ( i = 0; i < GetItemCount(); i++ )
-        {
-            fullFlags |= choices.GetValue(i);
-        }
-
-        val &= fullFlags;
-
-        m_value = val;
-
-        // Need to (re)init now?
-        if ( GetChildCount() != GetItemCount() ||
-             m_choices.GetDataPtr() != m_oldChoicesData )
-        {
-            Init();
-        }
-    }
-
-    long newFlags = m_value;
-
-    if ( newFlags != m_oldValue )
-    {
-        // Set child modified states
-        unsigned int i;
-        const wxPGChoices& choices = m_choices;
-        for ( i = 0; i<GetItemCount(); i++ )
-        {
-            int flag;
-
-            flag = choices.GetValue(i);
-
-            if ( (newFlags & flag) != (m_oldValue & flag) )
-                Item(i)->SetFlag( wxPG_PROP_MODIFIED );
-        }
-
-        m_oldValue = newFlags;
-    }
-}
-
-wxString wxFlagsProperty::ValueToString( wxVariant& value,
-                                         int WXUNUSED(argFlags) ) const
-{
-    wxString text;
-
-    if ( !m_choices.IsOk() )
-        return text;
-
-    long flags = value;
-    unsigned int i;
-    const wxPGChoices& choices = m_choices;
-
-    for ( i = 0; i < GetItemCount(); i++ )
-    {
-        int doAdd;
-        doAdd = ( flags & choices.GetValue(i) );
-
-        if ( doAdd )
-        {
-            text += choices.GetLabel(i);
-            text += wxS(", ");
-        }
-    }
-
-    // remove last comma
-    if ( text.Len() > 1 )
-        text.Truncate ( text.Len() - 2 );
-
-    return text;
-}
-
-// Translate string into flag tokens
-bool wxFlagsProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
-{
-    if ( !m_choices.IsOk() )
-        return false;
-
-    long newFlags = 0;
-
-    // semicolons are no longer valid delimeters
-    WX_PG_TOKENIZER1_BEGIN(text,wxS(','))
-
-        if ( token.length() )
-        {
-            // Determine which one it is
-            long bit = IdToBit( token );
-
-            if ( bit != -1 )
-            {
-                // Changed?
-                newFlags |= bit;
-            }
-            else
-            {
-                break;
-            }
-        }
-
-    WX_PG_TOKENIZER1_END()
-
-    if ( variant != (long)newFlags )
-    {
-        variant = (long)newFlags;
-        return true;
-    }
-
-    return false;
-}
-
-// Converts string id to a relevant bit.
-long wxFlagsProperty::IdToBit( const wxString& id ) const
-{
-    unsigned int i;
-    for ( i = 0; i < GetItemCount(); i++ )
-    {
-        if ( id == GetLabel(i) )
-        {
-            return m_choices.GetValue(i);
-        }
-    }
-    return -1;
-}
-
-void wxFlagsProperty::RefreshChildren()
-{
-    if ( !m_choices.IsOk() || !GetChildCount() ) return;
-
-    int flags = m_value.GetLong();
-
-    const wxPGChoices& choices = m_choices;
-    unsigned int i;
-    for ( i = 0; i < GetItemCount(); i++ )
-    {
-        long flag;
-
-        flag = choices.GetValue(i);
-
-        long subVal = flags & flag;
-        wxPGProperty* p = Item(i);
-
-        if ( subVal != (m_oldValue & flag) )
-            p->SetFlag( wxPG_PROP_MODIFIED );
-
-        p->SetValue( subVal?true:false );
-    }
-
-    m_oldValue = flags;
-}
-
-void wxFlagsProperty::ChildChanged( wxVariant& thisValue, int childIndex, wxVariant& childValue ) const
-{
-    long oldValue = thisValue.GetLong();
-    long val = childValue.GetLong();
-    unsigned long vi = m_choices.GetValue(childIndex);
-    if ( val )
-        thisValue = (long)(oldValue | vi);
-    else
-        thisValue = (long)(oldValue & ~(vi));
-}
-
-// -----------------------------------------------------------------------
-// wxDirProperty
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxDirProperty, wxLongStringProperty)
-
-wxDirProperty::wxDirProperty( const wxString& name, const wxString& label, const wxString& value )
-  : wxLongStringProperty(name,label,value)
-{
-    m_flags |= wxPG_PROP_NO_ESCAPE;
-}
-
-wxDirProperty::~wxDirProperty() { }
-
-wxValidator* wxDirProperty::DoGetValidator() const
-{
-    return wxFileProperty::GetClassValidator();
-}
-
-bool wxDirProperty::OnButtonClick( wxPropertyGrid* propGrid, wxString& value )
-{
-    // Update property value from editor, if necessary
-    wxSize dlg_sz(300,400);
-
-    wxString dlgMessage(m_dlgMessage);
-    if ( dlgMessage.empty() )
-        dlgMessage = _("Choose a directory:");
-    wxDirDialog dlg( propGrid,
-                     dlgMessage,
-                     value,
-                     0,
-#if !wxPG_SMALL_SCREEN
-                     propGrid->GetGoodEditorDialogPosition(this,dlg_sz),
-                     dlg_sz
-#else
-                     wxDefaultPosition,
-                     wxDefaultSize
-#endif
-                    );
-
-    if ( dlg.ShowModal() == wxID_OK )
-    {
-        value = dlg.GetPath();
-        return true;
-    }
-    return false;
-}
-
-bool wxDirProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    if ( name == wxPG_DIR_DIALOG_MESSAGE )
-    {
-        m_dlgMessage = value.GetString();
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPGFileDialogAdapter
-// -----------------------------------------------------------------------
-
-bool wxPGFileDialogAdapter::DoShowDialog( wxPropertyGrid* propGrid, wxPGProperty* property )
-{
-    wxFileProperty* fileProp = NULL;
-    wxString path;
-    int indFilter = -1;
-
-    if ( property->IsKindOf(CLASSINFO(wxFileProperty)) )
-    {
-        fileProp = ((wxFileProperty*)property);
-        wxFileName filename = fileProp->GetValue().GetString();
-        path = filename.GetPath();
-        indFilter = fileProp->m_indFilter;
-
-        if ( !path.length() && fileProp->m_basePath.length() )
-            path = fileProp->m_basePath;
-    }
-    else
-    {
-        wxFileName fn(property->GetValue().GetString());
-        path = fn.GetPath();
-    }
-
-    wxFileDialog dlg( propGrid->GetPanel(),
-                      property->GetAttribute(wxS("DialogTitle"), _("Choose a file")),
-                      property->GetAttribute(wxS("InitialPath"), path),
-                      wxEmptyString,
-                      property->GetAttribute(wxPG_FILE_WILDCARD, _("All files (*.*)|*.*")),
-                      0,
-                      wxDefaultPosition );
-
-    if ( indFilter >= 0 )
-        dlg.SetFilterIndex( indFilter );
-
-    if ( dlg.ShowModal() == wxID_OK )
-    {
-        if ( fileProp )
-            fileProp->m_indFilter = dlg.GetFilterIndex();
-        SetValue( dlg.GetPath() );
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxFileProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxFileProperty,wxPGProperty,
-                               wxString,const wxString&,TextCtrlAndButton)
-
-wxFileProperty::wxFileProperty( const wxString& label, const wxString& name,
-    const wxString& value ) : wxPGProperty(label,name)
-{
-    m_flags |= wxPG_PROP_SHOW_FULL_FILENAME;
-    m_indFilter = -1;
-    SetAttribute( wxPG_FILE_WILDCARD, _("All files (*.*)|*.*") );
-
-    SetValue(value);
-}
-
-wxFileProperty::~wxFileProperty() {}
-
-#if wxUSE_VALIDATORS
-
-wxValidator* wxFileProperty::GetClassValidator()
-{
-    WX_PG_DOGETVALIDATOR_ENTRY()
-
-    // Atleast wxPython 2.6.2.1 required that the string argument is given
-    static wxString v;
-    wxTextValidator* validator = new wxTextValidator(wxFILTER_EXCLUDE_CHAR_LIST,&v);
-
-    wxArrayString exChars;
-    exChars.Add(wxS("?"));
-    exChars.Add(wxS("*"));
-    exChars.Add(wxS("|"));
-    exChars.Add(wxS("<"));
-    exChars.Add(wxS(">"));
-    exChars.Add(wxS("\""));
-
-    validator->SetExcludes(exChars);
-
-    WX_PG_DOGETVALIDATOR_EXIT(validator)
-}
-
-wxValidator* wxFileProperty::DoGetValidator() const
-{
-    return GetClassValidator();
-}
-
-#endif
-
-void wxFileProperty::OnSetValue()
-{
-    const wxString& fnstr = m_value.GetString();
-
-    wxFileName filename = fnstr;
-
-    if ( !filename.HasName() )
-    {
-        m_value = wxPGVariant_EmptyString;
-    }
-
-    // Find index for extension.
-    if ( m_indFilter < 0 && fnstr.length() )
-    {
-        wxString ext = filename.GetExt();
-        int curind = 0;
-        size_t pos = 0;
-        size_t len = m_wildcard.length();
-
-        pos = m_wildcard.find(wxS("|"), pos);
-        while ( pos != wxString::npos && pos < (len-3) )
-        {
-            size_t ext_begin = pos + 3;
-
-            pos = m_wildcard.find(wxS("|"), ext_begin);
-            if ( pos == wxString::npos )
-                pos = len;
-            wxString found_ext = m_wildcard.substr(ext_begin, pos-ext_begin);
-
-            if ( found_ext.length() > 0 )
-            {
-                if ( found_ext[0] == wxS('*') )
-                {
-                    m_indFilter = curind;
-                    break;
-                }
-                if ( ext.CmpNoCase(found_ext) == 0 )
-                {
-                    m_indFilter = curind;
-                    break;
-                }
-            }
-
-            if ( pos != len )
-                pos = m_wildcard.find(wxS("|"), pos+1);
-
-            curind++;
-        }
-    }
-}
-
-wxFileName wxFileProperty::GetFileName() const
-{
-    wxFileName filename;
-
-    if ( !m_value.IsNull() )
-        filename = m_value.GetString();
-
-    return filename;
-}
-
-wxString wxFileProperty::ValueToString( wxVariant& value,
-                                        int argFlags ) const
-{
-    wxFileName filename = value.GetString();
-
-    if ( !filename.HasName() )
-        return wxEmptyString;
-
-    wxString fullName = filename.GetFullName();
-    if ( !fullName.length() )
-        return wxEmptyString;
-
-    if ( argFlags & wxPG_FULL_VALUE )
-    {
-        return filename.GetFullPath();
-    }
-    else if ( m_flags & wxPG_PROP_SHOW_FULL_FILENAME )
-    {
-        if ( m_basePath.Length() )
-        {
-            wxFileName fn2(filename);
-            fn2.MakeRelativeTo(m_basePath);
-            return fn2.GetFullPath();
-        }
-        return filename.GetFullPath();
-    }
-
-    return filename.GetFullName();
-}
-
-wxPGEditorDialogAdapter* wxFileProperty::GetEditorDialog() const
-{
-    return new wxPGFileDialogAdapter();
-}
-
-bool wxFileProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
-{
-    wxFileName filename = variant.GetString();
-
-    if ( (m_flags & wxPG_PROP_SHOW_FULL_FILENAME) || (argFlags & wxPG_FULL_VALUE) )
-    {
-        if ( filename != text )
-        {
-            variant = text;
-            return true;
-        }
-    }
-    else
-    {
-        if ( filename.GetFullName() != text )
-        {
-            wxFileName fn = filename;
-            fn.SetFullName(text);
-            variant = fn.GetFullPath();
-            return true;
-        }
-    }
-
-    return false;
-}
-
-bool wxFileProperty::DoSetAttribute( const wxString& name, wxVariant& value )
-{
-    // Return false on some occasions to make sure those attribs will get
-    // stored in m_attributes.
-    if ( name == wxPG_FILE_SHOW_FULL_PATH )
-    {
-        if ( wxPGVariantToInt(value) )
-            m_flags |= wxPG_PROP_SHOW_FULL_FILENAME;
-        else
-            m_flags &= ~(wxPG_PROP_SHOW_FULL_FILENAME);
-        return true;
-    }
-    else if ( name == wxPG_FILE_WILDCARD )
-    {
-        m_wildcard = value.GetString();
-    }
-    else if ( name == wxPG_FILE_SHOW_RELATIVE_PATH )
-    {
-        m_basePath = value.GetString();
-
-        // Make sure wxPG_FILE_SHOW_FULL_PATH is also set
-        m_flags |= wxPG_PROP_SHOW_FULL_FILENAME;
-    }
-    else if ( name == wxPG_FILE_INITIAL_PATH )
-    {
-        m_initialPath = value.GetString();
-        return true;
-    }
-    else if ( name == wxPG_FILE_DIALOG_TITLE )
-    {
-        m_dlgTitle = value.GetString();
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxPGLongStringDialogAdapter
-// -----------------------------------------------------------------------
-
-bool wxPGLongStringDialogAdapter::DoShowDialog( wxPropertyGrid* propGrid, wxPGProperty* property )
-{
-    wxString val1 = property->GetValueAsString(0);
-    wxString val_orig = val1;
-
-    wxString value;
-    if ( !property->HasFlag(wxPG_PROP_NO_ESCAPE) )
-        wxPropertyGrid::ExpandEscapeSequences(value, val1);
-    else
-        value = wxString(val1);
-
-    // Run editor dialog.
-    if ( wxLongStringProperty::DisplayEditorDialog(property, propGrid, value) )
-    {
-        if ( !property->HasFlag(wxPG_PROP_NO_ESCAPE) )
-            wxPropertyGrid::CreateEscapeSequences(val1,value);
-        else
-            val1 = value;
-
-        if ( val1 != val_orig )
-        {
-            SetValue( val1 );
-            return true;
-        }
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxLongStringProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxLongStringProperty,wxPGProperty,
-                               wxString,const wxString&,TextCtrlAndButton)
-
-wxLongStringProperty::wxLongStringProperty( const wxString& label, const wxString& name,
-    const wxString& value ) : wxPGProperty(label,name)
-{
-    SetValue(value);
-}
-
-wxLongStringProperty::~wxLongStringProperty() {}
-
-wxString wxLongStringProperty::ValueToString( wxVariant& value,
-                                              int WXUNUSED(argFlags) ) const
-{
-    return value;
-}
-
-bool wxLongStringProperty::OnEvent( wxPropertyGrid* propGrid, wxWindow* WXUNUSED(primary),
-                                    wxEvent& event )
-{
-    if ( propGrid->IsMainButtonEvent(event) )
-    {
-        // Update the value
-        wxVariant useValue = propGrid->GetUncommittedPropertyValue();
-
-        wxString val1 = useValue.GetString();
-        wxString val_orig = val1;
-
-        wxString value;
-        if ( !(m_flags & wxPG_PROP_NO_ESCAPE) )
-            wxPropertyGrid::ExpandEscapeSequences(value,val1);
-        else
-            value = wxString(val1);
-
-        // Run editor dialog.
-        if ( OnButtonClick(propGrid,value) )
-        {
-            if ( !(m_flags & wxPG_PROP_NO_ESCAPE) )
-                wxPropertyGrid::CreateEscapeSequences(val1,value);
-            else
-                val1 = value;
-
-            if ( val1 != val_orig )
-            {
-                SetValueInEvent( val1 );
-                return true;
-            }
-        }
-    }
-    return false;
-}
-
-bool wxLongStringProperty::OnButtonClick( wxPropertyGrid* propGrid, wxString& value )
-{
-    return DisplayEditorDialog(this, propGrid, value);
-}
-
-bool wxLongStringProperty::DisplayEditorDialog( wxPGProperty* prop, wxPropertyGrid* propGrid, wxString& value )
-
-{
-    // launch editor dialog
-    wxDialog* dlg = new wxDialog(propGrid,-1,prop->GetLabel(),wxDefaultPosition,wxDefaultSize,
-                                 wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER|wxCLIP_CHILDREN);
-
-    dlg->SetFont(propGrid->GetFont()); // To allow entering chars of the same set as the propGrid
-
-    // Multi-line text editor dialog.
-#if !wxPG_SMALL_SCREEN
-    const int spacing = 8;
-#else
-    const int spacing = 4;
-#endif
-    wxBoxSizer* topsizer = new wxBoxSizer( wxVERTICAL );
-    wxBoxSizer* rowsizer = new wxBoxSizer( wxHORIZONTAL );
-    wxTextCtrl* ed = new wxTextCtrl(dlg,11,value,
-        wxDefaultPosition,wxDefaultSize,wxTE_MULTILINE);
-
-    rowsizer->Add( ed, 1, wxEXPAND|wxALL, spacing );
-    topsizer->Add( rowsizer, 1, wxEXPAND, 0 );
-    rowsizer = new wxBoxSizer( wxHORIZONTAL );
-    const int but_sz_flags =
-        wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL|wxBOTTOM|wxLEFT|wxRIGHT;
-    rowsizer->Add( new wxButton(dlg,wxID_OK,_("Ok")),
-        0, but_sz_flags, spacing );
-    rowsizer->Add( new wxButton(dlg,wxID_CANCEL,_("Cancel")),
-        0, but_sz_flags, spacing );
-    topsizer->Add( rowsizer, 0, wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL, 0 );
-
-    dlg->SetSizer( topsizer );
-    topsizer->SetSizeHints( dlg );
-
-#if !wxPG_SMALL_SCREEN
-    dlg->SetSize(400,300);
-
-    dlg->Move( propGrid->GetGoodEditorDialogPosition(prop,dlg->GetSize()) );
-#endif
-
-    int res = dlg->ShowModal();
-
-    if ( res == wxID_OK )
-    {
-        value = ed->GetValue();
-        dlg->Destroy();
-        return true;
-    }
-    dlg->Destroy();
-    return false;
-}
-
-bool wxLongStringProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
-{
-    if ( variant != text )
-    {
-        variant = text;
-        return true;
-    }
-    return false;
-}
-
-// -----------------------------------------------------------------------
-// wxArrayEditorDialog
-// -----------------------------------------------------------------------
-
-BEGIN_EVENT_TABLE(wxArrayEditorDialog, wxDialog)
-    EVT_IDLE(wxArrayEditorDialog::OnIdle)
-    EVT_LISTBOX(24, wxArrayEditorDialog::OnListBoxClick)
-    EVT_TEXT_ENTER(21, wxArrayEditorDialog::OnAddClick)
-    EVT_BUTTON(22, wxArrayEditorDialog::OnAddClick)
-    EVT_BUTTON(23, wxArrayEditorDialog::OnDeleteClick)
-    EVT_BUTTON(25, wxArrayEditorDialog::OnUpClick)
-    EVT_BUTTON(26, wxArrayEditorDialog::OnDownClick)
-    EVT_BUTTON(27, wxArrayEditorDialog::OnUpdateClick)
-    //EVT_BUTTON(28, wxArrayEditorDialog::OnCustomEditClick)
-END_EVENT_TABLE()
-
-IMPLEMENT_ABSTRACT_CLASS(wxArrayEditorDialog, wxDialog)
-
-#include "wx/statline.h"
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnIdle(wxIdleEvent& event)
-{
-    //
-    // Do control focus detection here.
-    //
-
-    wxWindow* focused = FindFocus();
-
-    // This strange focus thing is a workaround for wxGTK wxListBox focus
-    // reporting bug.
-    if ( m_curFocus == 0 && focused != m_edValue &&
-         focused != m_butAdd && focused != m_butUpdate &&
-         m_lbStrings->GetSelection() >= 0 )
-    {
-        // ListBox was just focused.
-        m_butAdd->Enable(false);
-        m_butUpdate->Enable(false);
-        m_butRemove->Enable(true);
-        m_butUp->Enable(true);
-        m_butDown->Enable(true);
-        m_curFocus = 1;
-    }
-    else if ( (m_curFocus == 1 && focused == m_edValue) /*|| m_curFocus == 2*/ )
-    {
-        // TextCtrl was just focused.
-        m_butAdd->Enable(true);
-        bool upd_enable = false;
-        if ( m_lbStrings->GetCount() && m_lbStrings->GetSelection() >= 0 )
-            upd_enable = true;
-        m_butUpdate->Enable(upd_enable);
-        m_butRemove->Enable(false);
-        m_butUp->Enable(false);
-        m_butDown->Enable(false);
-        m_curFocus = 0;
-    }
-
-    event.Skip();
-}
-
-// -----------------------------------------------------------------------
-
-wxArrayEditorDialog::wxArrayEditorDialog()
-    : wxDialog()
-{
-    Init();
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::Init()
-{
-    m_custBtText = (const wxChar*) NULL;
-}
-
-// -----------------------------------------------------------------------
-
-wxArrayEditorDialog::wxArrayEditorDialog( wxWindow *parent,
-                                          const wxString& message,
-                                          const wxString& caption,
-                                          long style,
-                                          const wxPoint& pos,
-                                          const wxSize& sz )
-    : wxDialog()
-{
-    Init();
-    Create(parent,message,caption,style,pos,sz);
-}
-
-// -----------------------------------------------------------------------
-
-bool wxArrayEditorDialog::Create( wxWindow *parent,
-                                  const wxString& message,
-                                  const wxString& caption,
-                                  long style,
-                                  const wxPoint& pos,
-                                  const wxSize& sz )
-{
-    // On wxMAC the dialog shows incorrectly if style is not exactly wxCAPTION
-    // FIXME: This should be only a temporary fix.
-#ifdef __WXMAC__
-    wxUnusedVar(style);
-    int useStyle = wxCAPTION;
-#else
-    int useStyle = style;
-#endif
-
-    bool res = wxDialog::Create(parent, wxID_ANY, caption, pos, sz, useStyle);
-
-    SetFont(parent->GetFont()); // To allow entering chars of the same set as the propGrid
-
-#if !wxPG_SMALL_SCREEN
-    const int spacing = 4;
-#else
-    const int spacing = 3;
-#endif
-
-    m_modified = false;
-
-    m_curFocus = 1;
-
-    const int but_sz_flags =
-        wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL|wxALL; //wxBOTTOM|wxLEFT|wxRIGHT;
-
-    wxBoxSizer* topsizer = new wxBoxSizer( wxVERTICAL );
-
-    // Message
-    if ( message.length() )
-        topsizer->Add( new wxStaticText(this,-1,message),
-            0, wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxALL, spacing );
-
-    // String editor
-    wxBoxSizer* rowsizer = new wxBoxSizer( wxHORIZONTAL );
-    m_edValue = new wxTextCtrl(this,21,wxEmptyString,
-        wxDefaultPosition,wxDefaultSize,wxTE_PROCESS_ENTER);
-    wxValidator* validator = GetTextCtrlValidator();
-    if ( validator )
-    {
-        m_edValue->SetValidator( *validator );
-        delete validator;
-    }
-    rowsizer->Add( m_edValue,
-        1, wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxALL, spacing );
-
-    // Add button
-    m_butAdd = new wxButton(this,22,_("Add"));
-    rowsizer->Add( m_butAdd,
-        0, wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxTOP|wxBOTTOM|wxRIGHT, spacing );
-    topsizer->Add( rowsizer, 0, wxEXPAND, spacing );
-
-    // Separator line
-    topsizer->Add( new wxStaticLine(this,-1),
-        0, wxEXPAND|wxBOTTOM|wxLEFT|wxRIGHT, spacing );
-
-    rowsizer = new wxBoxSizer( wxHORIZONTAL );
-
-    // list box
-    m_lbStrings = new wxListBox(this, 24, wxDefaultPosition, wxDefaultSize);
-    unsigned int i;
-    for ( i=0; i<ArrayGetCount(); i++ )
-        m_lbStrings->Append( ArrayGet(i) );
-    rowsizer->Add( m_lbStrings, 1, wxEXPAND|wxRIGHT, spacing );
-
-    // Manipulator buttons
-    wxBoxSizer* colsizer = new wxBoxSizer( wxVERTICAL );
-    m_butCustom = NULL;
-    if ( m_custBtText )
-    {
-        m_butCustom = new wxButton(this,28,::wxGetTranslation(m_custBtText));
-        colsizer->Add( m_butCustom,
-            0, wxALIGN_CENTER|wxTOP/*wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxTOP|wxBOTTOM|wxRIGHT*/,
-            spacing );
-    }
-    m_butUpdate = new wxButton(this,27,_("Update"));
-    colsizer->Add( m_butUpdate,
-        0, wxALIGN_CENTER|wxTOP, spacing );
-    m_butRemove = new wxButton(this,23,_("Remove"));
-    colsizer->Add( m_butRemove,
-        0, wxALIGN_CENTER|wxTOP, spacing );
-    m_butUp = new wxButton(this,25,_("Up"));
-    colsizer->Add( m_butUp,
-        0, wxALIGN_CENTER|wxTOP, spacing );
-    m_butDown = new wxButton(this,26,_("Down"));
-    colsizer->Add( m_butDown,
-        0, wxALIGN_CENTER|wxTOP, spacing );
-    rowsizer->Add( colsizer, 0, 0, spacing );
-
-    topsizer->Add( rowsizer, 1, wxLEFT|wxRIGHT|wxEXPAND, spacing );
-
-    // Separator line
-    topsizer->Add( new wxStaticLine(this,-1),
-        0, wxEXPAND|wxTOP|wxLEFT|wxRIGHT, spacing );
-
-    // buttons
-    rowsizer = new wxBoxSizer( wxHORIZONTAL );
-    /*
-    const int but_sz_flags =
-        wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL|wxBOTTOM|wxLEFT|wxRIGHT;
-    */
-    rowsizer->Add( new wxButton(this,wxID_OK,_("Ok")),
-        0, but_sz_flags, spacing );
-    rowsizer->Add( new wxButton(this,wxID_CANCEL,_("Cancel")),
-        0, but_sz_flags, spacing );
-    topsizer->Add( rowsizer, 0, wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL, 0 );
-
-    m_edValue->SetFocus();
-
-    SetSizer( topsizer );
-    topsizer->SetSizeHints( this );
-
-#if !wxPG_SMALL_SCREEN
-    if ( sz.x == wxDefaultSize.x &&
-         sz.y == wxDefaultSize.y )
-        SetSize( wxSize(275,360) );
-    else
-        SetSize(sz);
-#endif
-
-    return res;
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnAddClick(wxCommandEvent& )
-{
-    wxString text = m_edValue->GetValue();
-    if ( text.length() )
-    {
-        if ( ArrayInsert( text, -1 ) )
-        {
-            m_lbStrings->Append( text );
-            m_modified = true;
-            m_edValue->Clear();
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnDeleteClick(wxCommandEvent& )
-{
-    int index = m_lbStrings->GetSelection();
-    if ( index >= 0 )
-    {
-        ArrayRemoveAt( index );
-        m_lbStrings->Delete ( index );
-        m_modified = true;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnUpClick(wxCommandEvent& )
-{
-    int index = m_lbStrings->GetSelection();
-    if ( index > 0 )
-    {
-        ArraySwap(index-1,index);
-        /*wxString old_str = m_array[index-1];
-        wxString new_str = m_array[index];
-        m_array[index-1] = new_str;
-        m_array[index] = old_str;*/
-        m_lbStrings->SetString ( index-1, ArrayGet(index-1) );
-        m_lbStrings->SetString ( index, ArrayGet(index) );
-        m_lbStrings->SetSelection ( index-1 );
-        m_modified = true;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnDownClick(wxCommandEvent& )
-{
-    int index = m_lbStrings->GetSelection();
-    int lastStringIndex = ((int) m_lbStrings->GetCount()) - 1;
-    if ( index >= 0 && index < lastStringIndex )
-    {
-        ArraySwap(index,index+1);
-        /*wxString old_str = m_array[index+1];
-        wxString new_str = m_array[index];
-        m_array[index+1] = new_str;
-        m_array[index] = old_str;*/
-        m_lbStrings->SetString ( index+1, ArrayGet(index+1) );
-        m_lbStrings->SetString ( index, ArrayGet(index) );
-        m_lbStrings->SetSelection ( index+1 );
-        m_modified = true;
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnUpdateClick(wxCommandEvent& )
-{
-    int index = m_lbStrings->GetSelection();
-    if ( index >= 0 )
-    {
-        wxString str = m_edValue->GetValue();
-        if ( ArraySet(index,str) )
-        {
-            m_lbStrings->SetString ( index, str );
-            //m_array[index] = str;
-            m_modified = true;
-        }
-    }
-}
-
-// -----------------------------------------------------------------------
-
-void wxArrayEditorDialog::OnListBoxClick(wxCommandEvent& )
-{
-    int index = m_lbStrings->GetSelection();
-    if ( index >= 0 )
-    {
-        m_edValue->SetValue( m_lbStrings->GetString(index) );
-    }
-}
-
-// -----------------------------------------------------------------------
-// wxPGArrayStringEditorDialog
-// -----------------------------------------------------------------------
-
-IMPLEMENT_DYNAMIC_CLASS(wxPGArrayStringEditorDialog, wxArrayEditorDialog)
-
-BEGIN_EVENT_TABLE(wxPGArrayStringEditorDialog, wxArrayEditorDialog)
-    EVT_BUTTON(28, wxPGArrayStringEditorDialog::OnCustomEditClick)
-END_EVENT_TABLE()
-
-// -----------------------------------------------------------------------
-
-wxString wxPGArrayStringEditorDialog::ArrayGet( size_t index )
-{
-    return m_array[index];
-}
-
-size_t wxPGArrayStringEditorDialog::ArrayGetCount()
-{
-    return m_array.size();
-}
-
-bool wxPGArrayStringEditorDialog::ArrayInsert( const wxString& str, int index )
-{
-    if (index<0)
-        m_array.Add(str);
-    else
-        m_array.Insert(str,index);
-    return true;
-}
-
-bool wxPGArrayStringEditorDialog::ArraySet( size_t index, const wxString& str )
-{
-    m_array[index] = str;
-    return true;
-}
-
-void wxPGArrayStringEditorDialog::ArrayRemoveAt( int index )
-{
-    m_array.RemoveAt(index);
-}
-
-void wxPGArrayStringEditorDialog::ArraySwap( size_t first, size_t second )
-{
-    wxString old_str = m_array[first];
-    wxString new_str = m_array[second];
-    m_array[first] = new_str;
-    m_array[second] = old_str;
-}
-
-wxPGArrayStringEditorDialog::wxPGArrayStringEditorDialog()
-    : wxArrayEditorDialog()
-{
-    Init();
-}
-
-void wxPGArrayStringEditorDialog::Init()
-{
-    m_pCallingClass = NULL;
-}
-
-void wxPGArrayStringEditorDialog::OnCustomEditClick(wxCommandEvent& )
-{
-    wxASSERT( m_pCallingClass );
-    wxString str = m_edValue->GetValue();
-    if ( m_pCallingClass->OnCustomStringEdit(m_parent,str) )
-    {
-        //m_edValue->SetValue ( str );
-        m_lbStrings->Append ( str );
-        m_array.Add ( str );
-        m_modified = true;
-    }
-}
-
-// -----------------------------------------------------------------------
-// wxArrayStringProperty
-// -----------------------------------------------------------------------
-
-WX_PG_IMPLEMENT_PROPERTY_CLASS(wxArrayStringProperty,  // Property name
-                               wxPGProperty,  // Property we inherit from
-                               wxArrayString,  // Value type name
-                               const wxArrayString&,  // Value type, as given in constructor
-                               TextCtrlAndButton)  // Initial editor
-
-wxArrayStringProperty::wxArrayStringProperty( const wxString& label,
-                                                        const wxString& name,
-                                                        const wxArrayString& array )
-    : wxPGProperty(label,name)
-{
-    SetValue( array );
-}
-
-wxArrayStringProperty::~wxArrayStringProperty() { }
-
-void wxArrayStringProperty::OnSetValue()
-{
-    GenerateValueAsString();
-}
-
-#define ARRSTRPROP_ARRAY_TO_STRING(STRING,ARRAY) \
-    wxPropertyGrid::ArrayStringToString(STRING,ARRAY,wxS('"'),wxS('"'),1)
-
-wxString wxArrayStringProperty::ValueToString( wxVariant& WXUNUSED(value),
-                                               int argFlags ) const
-{
-    //
-    // If this is called from GetValueAsString(), return cached string
-    if ( argFlags & wxPG_VALUE_IS_CURRENT )
-    {
-        return m_display;
-    }
-
-    wxArrayString arr = m_value.GetArrayString();
-    wxString s;
-    ARRSTRPROP_ARRAY_TO_STRING(s, arr);
-    return s;
-}
-
-// Converts wxArrayString to a string separated by delimeters and spaces.
-// preDelim is useful for "str1" "str2" style. Set flags to 1 to do slash
-// conversion.
-void wxPropertyGrid::ArrayStringToString( wxString& dst, const wxArrayString& src,
-                                          wxChar preDelim, wxChar postDelim,
-                                          int flags )
-{
-    wxString pdr;
-
-    unsigned int i;
-    unsigned int itemCount = src.size();
-
-    wxChar preas[2] = { 0, 0 };
-
-    dst.Empty();
-
-    if ( flags & 1 )
-    {
-        preas[0] = preDelim;
-        pdr = wxS("\\");
-        pdr += preDelim;
-    }
-
-    if ( itemCount )
-        dst.append( preas );
-
-    wxASSERT( postDelim );
-    wxString postDelimStr(postDelim);
-    //wxString preDelimStr(preDelim);
-
-    for ( i = 0; i < itemCount; i++ )
-    {
-        wxString str( src.Item(i) );
-
-        // Do some character conversion.
-        // Convertes \ to \\ and <preDelim> to \<preDelim>
-        // Useful when preDelim and postDelim are "\"".
-        if ( flags & 1 )
-        {
-            str.Replace( wxS("\\"), wxS("\\\\"), true );
-            if ( pdr.length() )
-                str.Replace( preas, pdr, true );
-        }
-
-        dst.append( str );
-
-        if ( i < (itemCount-1) )
-        {
-            dst.append( postDelimStr );
-            dst.append( wxS(" ") );
-            dst.append( preas );
-        }
-        else if ( preDelim )
-            dst.append( postDelimStr );
-    }
-}
-
-void wxArrayStringProperty::GenerateValueAsString()
-{
-    wxArrayString arr = m_value.GetArrayString();
-    ARRSTRPROP_ARRAY_TO_STRING(m_display, arr);
-}
-
-// Default implementation doesn't do anything.
-bool wxArrayStringProperty::OnCustomStringEdit( wxWindow*, wxString& )
-{
-    return false;
-}
-
-wxArrayEditorDialog* wxArrayStringProperty::CreateEditorDialog()
-{
-    return new wxPGArrayStringEditorDialog();
-}
-
-bool wxArrayStringProperty::OnButtonClick( wxPropertyGrid* propGrid,
-                                           wxWindow* WXUNUSED(primaryCtrl),
-                                           const wxChar* cbt )
-{
-    // Update the value
-    wxVariant useValue = propGrid->GetUncommittedPropertyValue();
-
-    if ( !propGrid->EditorValidate() )
-        return false;
-
-    // Create editor dialog.
-    wxArrayEditorDialog* dlg = CreateEditorDialog();
-#if wxUSE_VALIDATORS
-    wxValidator* validator = GetValidator();
-    wxPGInDialogValidator dialogValidator;
-#endif
-
-    wxPGArrayStringEditorDialog* strEdDlg = wxDynamicCast(dlg, wxPGArrayStringEditorDialog);
-
-    if ( strEdDlg )
-        strEdDlg->SetCustomButton(cbt, this);
-
-    dlg->SetDialogValue( useValue );
-    dlg->Create(propGrid, wxEmptyString, m_label);
-
-#if !wxPG_SMALL_SCREEN
-    dlg->Move( propGrid->GetGoodEditorDialogPosition(this,dlg->GetSize()) );
-#endif
-
-    bool retVal;
-
-    for (;;)
-    {
-        retVal = false;
-
-        int res = dlg->ShowModal();
-
-        if ( res == wxID_OK && dlg->IsModified() )
-        {
-            wxVariant value = dlg->GetDialogValue();
-            if ( !value.IsNull() )
-            {
-                wxArrayString actualValue = value.GetArrayString();
-                wxString tempStr;
-                ARRSTRPROP_ARRAY_TO_STRING(tempStr, actualValue);
-            #if wxUSE_VALIDATORS
-                if ( dialogValidator.DoValidate( propGrid, validator, tempStr ) )
-            #endif
-                {
-                    SetValueInEvent( actualValue );
-                    retVal = true;
-                    break;
-                }
-            }
-            else
-                break;
-        }
-        else
-            break;
-    }
-
-    delete dlg;
-
-    return retVal;
-}
-
-bool wxArrayStringProperty::OnEvent( wxPropertyGrid* propGrid,
-                                     wxWindow* primary,
-                                     wxEvent& event )
-{
-    if ( propGrid->IsMainButtonEvent(event) )
-        return OnButtonClick(propGrid,primary,(const wxChar*) NULL);
-    return false;
-}
-
-bool wxArrayStringProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
-{
-    wxArrayString arr;
-
-    WX_PG_TOKENIZER2_BEGIN(text,wxS('"'))
-
-        // Need to replace backslashes with empty characters
-        // (opposite what is done in GenerateValueString).
-        token.Replace ( wxS("\\"), wxEmptyString, true );
-
-        arr.Add( token );
-
-    WX_PG_TOKENIZER2_END()
-
-    variant = arr;
-
-    return true;
-}
-
-// -----------------------------------------------------------------------
-// wxPGInDialogValidator
-// -----------------------------------------------------------------------
-
-#if wxUSE_VALIDATORS
-bool wxPGInDialogValidator::DoValidate( wxPropertyGrid* propGrid,
-                                        wxValidator* validator,
-                                        const wxString& value )
-{
-    if ( !validator )
-        return true;
-
-    wxTextCtrl* tc = m_textCtrl;
-
-    if ( !tc )
-    {
-        {
-            tc = new wxTextCtrl( propGrid, wxPG_SUBID_TEMP1, wxEmptyString,
-                                 wxPoint(30000,30000));
-            tc->Hide();
-        }
-
-        m_textCtrl = tc;
-    }
-
-    tc->SetValue(value);
-
-    validator->SetWindow(tc);
-    bool res = validator->Validate(propGrid);
-
-    return res;
-}
-#else
-bool wxPGInDialogValidator::DoValidate( wxPropertyGrid* WXUNUSED(propGrid),
-                                        wxValidator* WXUNUSED(validator),
-                                        const wxString& WXUNUSED(value) )
-{
-    return true;
-}
-#endif
-
-// -----------------------------------------------------------------------
-
-#endif  // wxUSE_PROPGRID
+/////////////////////////////////////////////////////////////////////////////
+// Name:        src/propgrid/props.cpp
+// Purpose:     Basic Property Classes
+// Author:      Jaakko Salli
+// Modified by:
+// Created:     2005-05-14
+// RCS-ID:      $Id: props.cpp 59497 2009-03-12 18:17:55Z JMS $
+// Copyright:   (c) Jaakko Salli
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_PROPGRID
+
+#ifndef WX_PRECOMP
+    #include "wx/defs.h"
+    #include "wx/object.h"
+    #include "wx/hash.h"
+    #include "wx/string.h"
+    #include "wx/log.h"
+    #include "wx/event.h"
+    #include "wx/window.h"
+    #include "wx/panel.h"
+    #include "wx/dc.h"
+    #include "wx/dcclient.h"
+    #include "wx/dcmemory.h"
+    #include "wx/button.h"
+    #include "wx/pen.h"
+    #include "wx/brush.h"
+    #include "wx/cursor.h"
+    #include "wx/dialog.h"
+    #include "wx/settings.h"
+    #include "wx/msgdlg.h"
+    #include "wx/choice.h"
+    #include "wx/stattext.h"
+    #include "wx/scrolwin.h"
+    #include "wx/dirdlg.h"
+    #include "wx/combobox.h"
+    #include "wx/layout.h"
+    #include "wx/sizer.h"
+    #include "wx/textdlg.h"
+    #include "wx/filedlg.h"
+    #include "wx/intl.h"
+#endif
+
+#include "wx/filename.h"
+
+#include "wx/propgrid/propgrid.h"
+
+#define wxPG_CUSTOM_IMAGE_WIDTH     20 // for wxColourProperty etc.
+
+
+// -----------------------------------------------------------------------
+// wxStringProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxStringProperty,wxPGProperty,
+                               wxString,const wxString&,TextCtrl)
+
+wxStringProperty::wxStringProperty( const wxString& label,
+                                    const wxString& name,
+                                    const wxString& value )
+    : wxPGProperty(label,name)
+{
+    SetValue(value);
+}
+
+void wxStringProperty::OnSetValue()
+{
+    if ( !m_value.IsNull() && m_value.GetString() == wxS("<composed>") )
+        SetFlag(wxPG_PROP_COMPOSED_VALUE);
+
+    if ( HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+    {
+        wxString s;
+        DoGenerateComposedValue(s);
+        m_value = s;
+    }
+}
+
+wxStringProperty::~wxStringProperty() { }
+
+wxString wxStringProperty::ValueToString( wxVariant& value,
+                                          int argFlags ) const
+{
+    wxString s = value.GetString();
+
+    if ( GetChildCount() && HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+    {
+        // Value stored in m_value is non-editable, non-full value
+        if ( (argFlags & wxPG_FULL_VALUE) || (argFlags & wxPG_EDITABLE_VALUE) )
+        {
+            // Calling this under incorrect conditions will fail
+            wxASSERT_MSG( argFlags & wxPG_VALUE_IS_CURRENT,
+                          "Sorry, currently default wxPGProperty::ValueToString() "
+                          "implementation only works if value is m_value." );
+
+            DoGenerateComposedValue(s, argFlags);
+        }
+
+        return s;
+    }
+
+    // If string is password and value is for visual purposes,
+    // then return asterisks instead the actual string.
+    if ( (m_flags & wxPG_PROP_PASSWORD) && !(argFlags & (wxPG_FULL_VALUE|wxPG_EDITABLE_VALUE)) )
+        return wxString(wxChar('*'), s.Length());
+
+    return s;
+}
+
+bool wxStringProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
+{
+    if ( GetChildCount() && HasFlag(wxPG_PROP_COMPOSED_VALUE) )
+        return wxPGProperty::StringToValue(variant, text, argFlags);
+
+    if ( variant != text )
+    {
+        variant = text;
+        return true;
+    }
+
+    return false;
+}
+
+bool wxStringProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    if ( name == wxPG_STRING_PASSWORD )
+    {
+        m_flags &= ~(wxPG_PROP_PASSWORD);
+        if ( wxPGVariantToInt(value) ) m_flags |= wxPG_PROP_PASSWORD;
+        RecreateEditor();
+        return false;
+    }
+    return true;
+}
+
+// -----------------------------------------------------------------------
+// wxIntProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxIntProperty,wxPGProperty,
+                               long,long,TextCtrl)
+
+wxIntProperty::wxIntProperty( const wxString& label, const wxString& name,
+    long value ) : wxPGProperty(label,name)
+{
+    SetValue(value);
+}
+
+wxIntProperty::wxIntProperty( const wxString& label, const wxString& name,
+    const wxLongLong& value ) : wxPGProperty(label,name)
+{
+    SetValue(WXVARIANT(value));
+}
+
+wxIntProperty::~wxIntProperty() { }
+
+wxString wxIntProperty::ValueToString( wxVariant& value,
+                                       int WXUNUSED(argFlags) ) const
+{
+    if ( value.GetType() == wxPG_VARIANT_TYPE_LONG )
+    {
+        return wxString::Format(wxS("%li"),value.GetLong());
+    }
+    else if ( value.GetType() == wxLongLong_VariantType )
+    {
+	    wxLongLong ll;
+        ll << value;
+	    return ll.ToString();
+    }
+
+    return wxEmptyString;
+}
+
+bool wxIntProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
+{
+    wxString s;
+    long value32;
+
+    if ( text.length() == 0 )
+    {
+        variant.MakeNull();
+        return true;
+    }
+
+    // We know it is a number, but let's still check
+    // the return value.
+    if ( text.IsNumber() )
+    {
+        // Remove leading zeroes, so that the number is not interpreted as octal
+        wxString::const_iterator i = text.begin();
+        wxString::const_iterator iMax = text.end() - 1;  // Let's allow one, last zero though
+
+        int firstNonZeroPos = 0;
+
+        for ( ; i != iMax; ++i )
+        {
+            wxChar c = *i;
+            if ( c != wxS('0') && c != wxS(' ') )
+                break;
+            firstNonZeroPos++;
+        }
+
+        wxString useText = text.substr(firstNonZeroPos, text.length() - firstNonZeroPos);
+
+        wxString variantType = variant.GetType();
+        bool isPrevLong = variantType == wxPG_VARIANT_TYPE_LONG;
+
+        wxLongLong_t value64 = 0;
+
+        if ( useText.ToLongLong(&value64, 10) &&
+             ( value64 >= INT_MAX || value64 <= INT_MIN )
+           )
+        {
+            bool doChangeValue = isPrevLong;
+
+            if ( !isPrevLong && variantType == wxLongLong_VariantType )
+            {
+                wxLongLong oldValue;
+                oldValue << variant;
+                if ( oldValue.GetValue() != value64 )
+                    doChangeValue = true;
+            }
+
+            if ( doChangeValue )
+            {
+                wxLongLong ll(value64);
+                variant << ll;
+                return true;
+            }
+        }
+
+        if ( useText.ToLong( &value32, 0 ) )
+        {
+            if ( !isPrevLong || variant != value32 )
+            {
+                variant = value32;
+                return true;
+            }
+        }
+    }
+    else if ( argFlags & wxPG_REPORT_ERROR )
+    {
+    }
+    return false;
+}
+
+bool wxIntProperty::IntToValue( wxVariant& variant, int value, int WXUNUSED(argFlags) ) const
+{
+    if ( variant.GetType() != wxPG_VARIANT_TYPE_LONG || variant != (long)value )
+    {
+        variant = (long)value;
+        return true;
+    }
+    return false;
+}
+
+bool wxIntProperty::DoValidation( const wxPGProperty* property, wxLongLong_t& value, wxPGValidationInfo* pValidationInfo, int mode )
+{
+    // Check for min/max
+    wxLongLong_t min = wxINT64_MIN;
+    wxLongLong_t max = wxINT64_MAX;
+    wxVariant variant;
+    bool minOk = false;
+    bool maxOk = false;
+
+    variant = property->GetAttribute(wxPGGlobalVars->m_strMin);
+    if ( !variant.IsNull() )
+    {
+        wxPGVariantToLongLong(variant, &min);
+        minOk = true;
+    }
+
+    variant = property->GetAttribute(wxPGGlobalVars->m_strMax);
+    if ( !variant.IsNull() )
+    {
+        wxPGVariantToLongLong(variant, &max);
+        maxOk = true;
+    }
+
+    if ( minOk )
+    {
+        if ( value < min )
+        {
+            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
+                pValidationInfo->SetFailureMessage(
+                    wxString::Format(_("Value must be %lld or higher"),min)
+                    );
+            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
+                value = min;
+            else
+                value = max - (min - value);
+            return false;
+        }
+    }
+
+    if ( maxOk )
+    {
+        if ( value > max )
+        {
+            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
+                pValidationInfo->SetFailureMessage(
+                    wxString::Format(_("Value must be %lld or higher"),min)
+                    );
+            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
+                value = max;
+            else
+                value = min + (value - max);
+            return false;
+        }
+    }
+    return true;
+}
+
+bool wxIntProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& validationInfo ) const
+{
+    wxLongLong_t ll;
+    if ( wxPGVariantToLongLong(value, &ll) )
+        return DoValidation(this, ll, &validationInfo, wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE);
+    return true;
+}
+
+wxValidator* wxIntProperty::GetClassValidator()
+{
+#if wxUSE_VALIDATORS
+    WX_PG_DOGETVALIDATOR_ENTRY()
+
+    // Atleast wxPython 2.6.2.1 required that the string argument is given
+    static wxString v;
+    wxTextValidator* validator = new wxTextValidator(wxFILTER_NUMERIC,&v);
+
+    WX_PG_DOGETVALIDATOR_EXIT(validator)
+#else
+    return NULL;
+#endif
+}
+
+wxValidator* wxIntProperty::DoGetValidator() const
+{
+    return GetClassValidator();
+}
+
+// -----------------------------------------------------------------------
+// wxUIntProperty
+// -----------------------------------------------------------------------
+
+
+#define wxPG_UINT_TEMPLATE_MAX 8
+
+static const wxChar* gs_uintTemplates32[wxPG_UINT_TEMPLATE_MAX] = {
+    wxT("%x"),wxT("0x%x"),wxT("$%x"),
+    wxT("%X"),wxT("0x%X"),wxT("$%X"),
+    wxT("%u"),wxT("%o")
+};
+
+static const wxChar* gs_uintTemplates64[wxPG_UINT_TEMPLATE_MAX] = {
+    wxT("%") wxLongLongFmtSpec wxT("x"),
+    wxT("0x%") wxLongLongFmtSpec wxT("x"),
+    wxT("$%") wxLongLongFmtSpec wxT("x"),
+    wxT("%") wxLongLongFmtSpec wxT("X"),
+    wxT("0x%") wxLongLongFmtSpec wxT("X"),
+    wxT("$%") wxLongLongFmtSpec wxT("X"),
+    wxT("%") wxLongLongFmtSpec wxT("u"),
+    wxT("%") wxLongLongFmtSpec wxT("o")
+};
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxUIntProperty,wxPGProperty,
+                               long,unsigned long,TextCtrl)
+
+void wxUIntProperty::Init()
+{
+    m_base = 6; // This is magic number for dec base (must be same as in setattribute)
+    m_realBase = 10;
+    m_prefix = wxPG_PREFIX_NONE;
+}
+
+wxUIntProperty::wxUIntProperty( const wxString& label, const wxString& name,
+    unsigned long value ) : wxPGProperty(label,name)
+{
+    Init();
+    SetValue((long)value);
+}
+
+wxUIntProperty::wxUIntProperty( const wxString& label, const wxString& name,
+    const wxULongLong& value ) : wxPGProperty(label,name)
+{
+    Init();
+    SetValue(WXVARIANT(value));
+}
+
+wxUIntProperty::~wxUIntProperty() { }
+
+wxString wxUIntProperty::ValueToString( wxVariant& value,
+                                        int WXUNUSED(argFlags) ) const
+{
+    size_t index = m_base + m_prefix;
+    if ( index >= wxPG_UINT_TEMPLATE_MAX )
+        index = wxPG_BASE_DEC;
+
+    if ( value.GetType() == wxPG_VARIANT_TYPE_LONG )
+    {
+        return wxString::Format(gs_uintTemplates32[index], (unsigned long)value.GetLong());
+    }
+
+    wxULongLong ull;
+    ull << value;
+
+    return wxString::Format(gs_uintTemplates64[index], ull.GetValue());
+}
+
+bool wxUIntProperty::StringToValue( wxVariant& variant, const wxString& text, int WXUNUSED(argFlags) ) const
+{
+    wxString variantType = variant.GetType();
+    bool isPrevLong = variantType == wxPG_VARIANT_TYPE_LONG;
+
+    if ( text.length() == 0 )
+    {
+        variant.MakeNull();
+        return true;
+    }
+
+    size_t start = 0;
+    if ( text[0] == wxS('$') )
+        start++;
+
+    wxULongLong_t value64 = 0;
+    wxString s = text.substr(start, text.length() - start);
+
+    if ( s.ToULongLong(&value64, (unsigned int)m_realBase) )
+    {
+        if ( value64 >= LONG_MAX )
+        {
+            bool doChangeValue = isPrevLong;
+
+            if ( !isPrevLong && variantType == wxULongLong_VariantType )
+            {
+                wxULongLong oldValue;
+                oldValue << variant;
+                if ( oldValue.GetValue() != value64 )
+                    doChangeValue = true;
+            }
+
+            if ( doChangeValue )
+            {
+                wxULongLong ull(value64);
+                variant << ull;
+                return true;
+            }
+        }
+        else
+        {
+            unsigned long value32 = wxLongLong(value64).GetLo();
+            if ( !isPrevLong || m_value != (long)value32 )
+            {
+                variant = (long)value32;
+                return true;
+            }
+        }
+
+    }
+    return false;
+}
+
+bool wxUIntProperty::IntToValue( wxVariant& variant, int number, int WXUNUSED(argFlags) ) const
+{
+    if ( variant != (long)number )
+    {
+        variant = (long)number;
+        return true;
+    }
+    return false;
+}
+
+#ifdef ULLONG_MAX
+  #define wxUINT64_MAX ULLONG_MAX
+  #define wxUINT64_MIN wxULL(0)
+#else
+  #define wxUINT64_MAX wxULL(0xFFFFFFFFFFFFFFFF)
+  #define wxUINT64_MIN wxULL(0)
+#endif
+
+bool wxUIntProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& validationInfo ) const
+{
+    // Check for min/max
+    wxULongLong_t ll;
+    if ( wxPGVariantToULongLong(value, &ll) )
+    {
+        wxULongLong_t min = wxUINT64_MIN;
+        wxULongLong_t max = wxUINT64_MAX;
+        wxVariant variant;
+
+        variant = GetAttribute(wxPGGlobalVars->m_strMin);
+        if ( !variant.IsNull() )
+        {
+            wxPGVariantToULongLong(variant, &min);
+            if ( ll < min )
+            {
+                validationInfo.SetFailureMessage(
+                    wxString::Format(_("Value must be %llu or higher"),min)
+                    );
+                return false;
+            }
+        }
+        variant = GetAttribute(wxPGGlobalVars->m_strMax);
+        if ( !variant.IsNull() )
+        {
+            wxPGVariantToULongLong(variant, &max);
+            if ( ll > max )
+            {
+                validationInfo.SetFailureMessage(
+                    wxString::Format(_("Value must be %llu or less"),max)
+                    );
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+bool wxUIntProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    if ( name == wxPG_UINT_BASE )
+    {
+        int val = value.GetLong();
+
+        m_realBase = (wxByte) val;
+        if ( m_realBase > 16 )
+            m_realBase = 16;
+
+        //
+        // Translate logical base to a template array index
+        m_base = 7; // oct
+        if ( val == wxPG_BASE_HEX )
+            m_base = 3;
+        else if ( val == wxPG_BASE_DEC )
+            m_base = 6;
+        else if ( val == wxPG_BASE_HEXL )
+            m_base = 0;
+        return true;
+    }
+    else if ( name == wxPG_UINT_PREFIX )
+    {
+        m_prefix = (wxByte) value.GetLong();
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxFloatProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxFloatProperty,wxPGProperty,
+                               double,double,TextCtrl)
+
+wxFloatProperty::wxFloatProperty( const wxString& label,
+                                            const wxString& name,
+                                            double value )
+    : wxPGProperty(label,name)
+{
+    m_precision = -1;
+    SetValue(value);
+}
+
+wxFloatProperty::~wxFloatProperty() { }
+
+// This helper method provides standard way for floating point-using
+// properties to convert values to string.
+void wxPropertyGrid::DoubleToString(wxString& target,
+                                    double value,
+                                    int precision,
+                                    bool removeZeroes,
+                                    wxString* precTemplate)
+{
+    if ( precision >= 0 )
+    {
+        wxString text1;
+        if (!precTemplate)
+            precTemplate = &text1;
+
+        if ( !precTemplate->length() )
+        {
+            *precTemplate = wxS("%.");
+            *precTemplate << wxString::Format( wxS("%i"), precision );
+            *precTemplate << wxS('f');
+        }
+
+        target.Printf( precTemplate->c_str(), value );
+    }
+    else
+    {
+        target.Printf( wxS("%f"), value );
+    }
+
+    if ( removeZeroes && precision != 0 && target.length() )
+    {
+        // Remove excess zeroes (do not remove this code just yet,
+        // since sprintf can't do the same consistently across platforms).
+        wxString::const_iterator i = target.end() - 1;
+        size_t new_len = target.length() - 1;
+
+        for ( ; i != target.begin(); --i )
+        {
+            if ( *i != wxS('0') )
+                break;
+            new_len--;
+        }
+
+        wxChar cur_char = *i;
+        if ( cur_char != wxS('.') && cur_char != wxS(',') )
+            new_len++;
+
+        if ( new_len != target.length() )
+            target.resize(new_len);
+    }
+}
+
+wxString wxFloatProperty::ValueToString( wxVariant& value,
+                                         int argFlags ) const
+{
+    wxString text;
+    if ( !value.IsNull() )
+    {
+        wxPropertyGrid::DoubleToString(text,
+                                       value,
+                                       m_precision,
+                                       !(argFlags & wxPG_FULL_VALUE),
+                                       NULL);
+    }
+    return text;
+}
+
+bool wxFloatProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
+{
+    wxString s;
+    double value;
+
+    if ( text.length() == 0 )
+    {
+        variant.MakeNull();
+        return true;
+    }
+
+    bool res = text.ToDouble(&value);
+    if ( res )
+    {
+        if ( variant != value )
+        {
+            variant = value;
+            return true;
+        }
+    }
+    else if ( argFlags & wxPG_REPORT_ERROR )
+    {
+    }
+    return false;
+}
+
+bool wxFloatProperty::DoValidation( const wxPGProperty* property, double& value, wxPGValidationInfo* pValidationInfo, int mode )
+{
+    // Check for min/max
+    double min = (double)wxINT64_MIN;
+    double max = (double)wxINT64_MAX;
+    wxVariant variant;
+    bool minOk = false;
+    bool maxOk = false;
+
+    variant = property->GetAttribute(wxPGGlobalVars->m_strMin);
+    if ( !variant.IsNull() )
+    {
+        wxPGVariantToDouble(variant, &min);
+        minOk = true;
+    }
+
+    variant = property->GetAttribute(wxPGGlobalVars->m_strMax);
+    if ( !variant.IsNull() )
+    {
+        wxPGVariantToDouble(variant, &max);
+        maxOk = true;
+    }
+
+    if ( minOk )
+    {
+        if ( value < min )
+        {
+            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
+                pValidationInfo->SetFailureMessage(
+                    wxString::Format(_("Value must be %f or higher"),min)
+                    );
+            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
+                value = min;
+            else
+                value = max - (min - value);
+            return false;
+        }
+    }
+
+    if ( maxOk )
+    {
+        wxPGVariantToDouble(variant, &max);
+        if ( value > max )
+        {
+            if ( mode == wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE )
+                pValidationInfo->SetFailureMessage(
+                    wxString::Format(_("Value must be %f or less"),max)
+                    );
+            else if ( mode == wxPG_PROPERTY_VALIDATION_SATURATE )
+                value = max;
+            else
+                value = min + (value - max);
+            return false;
+        }
+    }
+    return true;
+}
+
+bool wxFloatProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& validationInfo ) const
+{
+    double fpv;
+    if ( wxPGVariantToDouble(value, &fpv) )
+        return DoValidation(this, fpv, &validationInfo, wxPG_PROPERTY_VALIDATION_ERROR_MESSAGE);
+    return true;
+}
+
+bool wxFloatProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    if ( name == wxPG_FLOAT_PRECISION )
+    {
+        m_precision = value.GetLong();
+        return true;
+    }
+    return false;
+}
+
+wxValidator* wxFloatProperty::DoGetValidator() const
+{
+    return wxIntProperty::GetClassValidator();
+}
+
+// -----------------------------------------------------------------------
+// wxBoolProperty
+// -----------------------------------------------------------------------
+
+// We cannot use standard WX_PG_IMPLEMENT_PROPERTY_CLASS macro, since
+// there is a custom GetEditorClass.
+
+IMPLEMENT_DYNAMIC_CLASS(wxBoolProperty, wxPGProperty)
+
+const wxPGEditor* wxBoolProperty::DoGetEditorClass() const
+{
+    // Select correct editor control.
+#if wxPG_INCLUDE_CHECKBOX
+    if ( !(m_flags & wxPG_PROP_USE_CHECKBOX) )
+        return wxPGEditor_Choice;
+    return wxPGEditor_CheckBox;
+#else
+    return wxPGEditor_Choice;
+#endif
+}
+
+wxBoolProperty::wxBoolProperty( const wxString& label, const wxString& name, bool value ) :
+    wxPGProperty(label,name)
+{
+    m_choices.Assign(wxPGGlobalVars->m_boolChoices);
+
+    SetValue(wxPGVariant_Bool(value));
+
+    m_flags |= wxPG_PROP_USE_DCC;
+}
+
+wxBoolProperty::~wxBoolProperty() { }
+
+wxString wxBoolProperty::ValueToString( wxVariant& value,
+                                        int argFlags ) const
+{
+    bool boolValue = value.GetBool();
+
+    // As a fragment of composite string value,
+    // make it a little more readable.
+    if ( argFlags & wxPG_COMPOSITE_FRAGMENT )
+    {
+        if ( boolValue )
+        {
+            return m_label;
+        }
+        else
+        {
+            if ( argFlags & wxPG_UNEDITABLE_COMPOSITE_FRAGMENT )
+                return wxEmptyString;
+
+            wxString notFmt;
+            if ( wxPGGlobalVars->m_autoGetTranslation )
+                notFmt = _("Not %s");
+            else
+                notFmt = wxS("Not %s");
+
+            return wxString::Format(notFmt.c_str(), m_label.c_str());
+        }
+    }
+
+    if ( !(argFlags & wxPG_FULL_VALUE) )
+    {
+        return wxPGGlobalVars->m_boolChoices[boolValue?1:0].GetText();
+    }
+
+    wxString text;
+
+    if ( boolValue ) text = wxS("true");
+    else text = wxS("false");
+
+    return text;
+}
+
+bool wxBoolProperty::StringToValue( wxVariant& variant, const wxString& text, int WXUNUSED(argFlags) ) const
+{
+    bool boolValue = false;
+    if ( text.CmpNoCase(wxPGGlobalVars->m_boolChoices[1].GetText()) == 0 ||
+         text.CmpNoCase(wxS("true")) == 0 ||
+         text.CmpNoCase(m_label) == 0 )
+        boolValue = true;
+
+    if ( text.length() == 0 )
+    {
+        variant.MakeNull();
+        return true;
+    }
+
+    if ( variant != boolValue )
+    {
+        variant = wxPGVariant_Bool(boolValue);
+        return true;
+    }
+    return false;
+}
+
+bool wxBoolProperty::IntToValue( wxVariant& variant, int value, int ) const
+{
+    bool boolValue = value ? true : false;
+
+    if ( variant != boolValue )
+    {
+        variant = wxPGVariant_Bool(boolValue);
+        return true;
+    }
+    return false;
+}
+
+bool wxBoolProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+#if wxPG_INCLUDE_CHECKBOX
+    if ( name == wxPG_BOOL_USE_CHECKBOX )
+    {
+        int ival = wxPGVariantToInt(value);
+        if ( ival )
+            m_flags |= wxPG_PROP_USE_CHECKBOX;
+        else
+            m_flags &= ~(wxPG_PROP_USE_CHECKBOX);
+        return true;
+    }
+#endif
+    if ( name == wxPG_BOOL_USE_DOUBLE_CLICK_CYCLING )
+    {
+        int ival = wxPGVariantToInt(value);
+        if ( ival )
+            m_flags |= wxPG_PROP_USE_DCC;
+        else
+            m_flags &= ~(wxPG_PROP_USE_DCC);
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxEnumProperty
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxEnumProperty, wxPGProperty)
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxEnumProperty,long,Choice)
+
+wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
+    const long* values, int value ) : wxPGProperty(label,name)
+{
+    SetIndex(0);
+
+    if ( labels )
+    {
+        m_choices.Add(labels,values);
+
+        if ( GetItemCount() )
+            SetValue( (long)value );
+    }
+}
+
+wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
+    const long* values, wxPGChoices* choicesCache, int value )
+    : wxPGProperty(label,name)
+{
+    SetIndex(0);
+
+    wxASSERT( choicesCache );
+
+    if ( choicesCache->IsOk() )
+    {
+        m_choices.Assign( *choicesCache );
+        m_value = wxPGVariant_Zero;
+    }
+    else if ( labels )
+    {
+        m_choices.Add(labels,values);
+
+        if ( GetItemCount() )
+            SetValue( (long)value );
+    }
+}
+
+wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name,
+    const wxArrayString& labels, const wxArrayInt& values, int value )
+    : wxPGProperty(label,name)
+{
+    SetIndex(0);
+
+    if ( &labels && labels.size() )
+    {
+        m_choices.Set(labels, values);
+
+        if ( GetItemCount() )
+            SetValue( (long)value );
+    }
+}
+
+wxEnumProperty::wxEnumProperty( const wxString& label, const wxString& name,
+    wxPGChoices& choices, int value )
+    : wxPGProperty(label,name)
+{
+    m_choices.Assign( choices );
+
+    if ( GetItemCount() )
+        SetValue( (long)value );
+}
+
+int wxEnumProperty::GetIndexForValue( int value ) const
+{
+    if ( !m_choices.IsOk() )
+        return -1;
+
+    int intVal = m_choices.Index(value);
+    if ( intVal >= 0 )
+        return intVal;
+
+    return value;
+}
+
+wxEnumProperty::~wxEnumProperty ()
+{
+}
+
+int wxEnumProperty::ms_nextIndex = -2;
+
+void wxEnumProperty::OnSetValue()
+{
+    wxString variantType = m_value.GetType();
+
+    if ( variantType == wxPG_VARIANT_TYPE_LONG )
+        ValueFromInt_( m_value, m_value.GetLong(), wxPG_FULL_VALUE );
+    else if ( variantType == wxPG_VARIANT_TYPE_STRING )
+        ValueFromString_( m_value, m_value.GetString(), 0 );
+    else
+        wxFAIL;
+
+    if ( ms_nextIndex != -2 )
+    {
+        m_index = ms_nextIndex;
+        ms_nextIndex = -2;
+    }
+}
+
+bool wxEnumProperty::ValidateValue( wxVariant& value, wxPGValidationInfo& WXUNUSED(validationInfo) ) const
+{
+    // Make sure string value is in the list,
+    // unless property has string as preferred value type
+    // To reduce code size, use conversion here as well
+    if ( value.GetType() == wxPG_VARIANT_TYPE_STRING &&
+         !this->IsKindOf(CLASSINFO(wxEditEnumProperty)) )
+        return ValueFromString_( value, value.GetString(), wxPG_PROPERTY_SPECIFIC );
+
+    return true;
+}
+
+wxString wxEnumProperty::ValueToString( wxVariant& value,
+                                            int WXUNUSED(argFlags) ) const
+{
+    if ( value.GetType() == wxPG_VARIANT_TYPE_STRING )
+        return value.GetString();
+
+    int index = m_choices.Index(value.GetLong());
+    if ( index < 0 )
+        return wxEmptyString;
+
+    return m_choices.GetLabel(index);
+}
+
+bool wxEnumProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
+{
+    return ValueFromString_( variant, text, argFlags );
+}
+
+bool wxEnumProperty::IntToValue( wxVariant& variant, int intVal, int argFlags ) const
+{
+    return ValueFromInt_( variant, intVal, argFlags );
+}
+
+bool wxEnumProperty::ValueFromString_( wxVariant& value, const wxString& text, int argFlags ) const
+{
+    int useIndex = -1;
+    long useValue = 0;
+
+    for ( unsigned int i=0; i<m_choices.GetCount(); i++ )
+    {
+        const wxString& entryLabel = m_choices.GetLabel(i);
+        if ( text.CmpNoCase(entryLabel) == 0 )
+        {
+            useIndex = (int)i;
+            useValue = m_choices.GetValue(i);
+            break;
+        }
+    }
+
+    bool asText = false;
+
+    bool isEdit = this->IsKindOf(CLASSINFO(wxEditEnumProperty));
+
+    // If text not any of the choices, store as text instead
+    // (but only if we are wxEditEnumProperty)
+    if ( useIndex == -1 &&
+         (value.GetType() != wxPG_VARIANT_TYPE_STRING || (m_value.GetString() != text)) &&
+         isEdit )
+    {
+        asText = true;
+    }
+
+    int setAsNextIndex = -2;
+
+    if ( asText )
+    {
+        setAsNextIndex = -1;
+        value = text;
+    }
+    else if ( useIndex != GetIndex() )
+    {
+        if ( useIndex != -1 )
+        {
+            setAsNextIndex = useIndex;
+            value = (long)useValue;
+        }
+        else
+        {
+            setAsNextIndex = -1;
+            value = wxPGVariant_MinusOne;
+        }
+    }
+
+    if ( setAsNextIndex != -2 )
+    {
+        // If wxPG_PROPERTY_SPECIFIC is set, then this is done for
+        // validation purposes only, and index must not be changed
+        if ( !(argFlags & wxPG_PROPERTY_SPECIFIC) )
+            ms_nextIndex = setAsNextIndex;
+
+        if ( isEdit || setAsNextIndex != -1 )
+            return true;
+        else
+            return false;
+    }
+    return false;
+}
+
+bool wxEnumProperty::ValueFromInt_( wxVariant& variant, int intVal, int argFlags ) const
+{
+    // If wxPG_FULL_VALUE is *not* in argFlags, then intVal is index from combo box.
+    //
+    ms_nextIndex = -2;
+
+    if ( argFlags & wxPG_FULL_VALUE )
+    {
+        ms_nextIndex = GetIndexForValue( intVal );
+    }
+    else
+    {
+        if ( intVal != GetIndex() )
+        {
+            ms_nextIndex = intVal;
+        }
+    }
+
+    if ( ms_nextIndex != -2 )
+    {
+        if ( !(argFlags & wxPG_FULL_VALUE) )
+            intVal = m_choices.GetValue(intVal);
+
+        variant = (long)intVal;
+
+        return true;
+    }
+
+    return false;
+}
+
+void
+wxEnumProperty::OnValidationFailure( wxVariant& WXUNUSED(pendingValue) )
+{
+    // Revert index
+    ResetNextIndex();
+}
+
+void wxEnumProperty::SetIndex( int index )
+{
+    ms_nextIndex = -2;
+    m_index = index;
+}
+
+int wxEnumProperty::GetIndex() const
+{
+    if ( m_value.IsNull() )
+        return -1;
+
+    if ( ms_nextIndex != -2 )
+        return ms_nextIndex;
+
+    return m_index;
+}
+
+// -----------------------------------------------------------------------
+// wxEditEnumProperty
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxEditEnumProperty, wxPGProperty)
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxEditEnumProperty,wxString,ComboBox)
+
+wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
+    const long* values, const wxString& value )
+    : wxEnumProperty(label,name,labels,values,0)
+{
+    SetValue( value );
+}
+
+wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name, const wxChar** labels,
+    const long* values, wxPGChoices* choicesCache, const wxString& value )
+    : wxEnumProperty(label,name,labels,values,choicesCache,0)
+{
+    SetValue( value );
+}
+
+wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name,
+    const wxArrayString& labels, const wxArrayInt& values, const wxString& value )
+    : wxEnumProperty(label,name,labels,values,0)
+{
+    SetValue( value );
+}
+
+wxEditEnumProperty::wxEditEnumProperty( const wxString& label, const wxString& name,
+    wxPGChoices& choices, const wxString& value )
+    : wxEnumProperty(label,name,choices,0)
+{
+    SetValue( value );
+}
+
+wxEditEnumProperty::~wxEditEnumProperty()
+{
+}
+
+// -----------------------------------------------------------------------
+// wxFlagsProperty
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxFlagsProperty,wxPGProperty)
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS_PLAIN(wxFlagsProperty,long,TextCtrl)
+
+void wxFlagsProperty::Init()
+{
+    long value = m_value;
+
+    //
+    // Generate children
+    //
+    unsigned int i;
+
+    unsigned int prevChildCount = m_children.size();
+
+    int oldSel = -1;
+    if ( prevChildCount )
+    {
+        wxPropertyGridPageState* state = GetParentState();
+
+        // State safety check (it may be NULL in immediate parent)
+        wxASSERT( state );
+
+        if ( state )
+        {
+            wxPGProperty* selected = state->GetSelection();
+            if ( selected )
+            {
+                if ( selected->GetParent() == this )
+                    oldSel = selected->GetIndexInParent();
+                else if ( selected == this )
+                    oldSel = -2;
+            }
+        }
+        state->DoClearSelection();
+    }
+
+    // Delete old children
+    for ( i=0; i<prevChildCount; i++ )
+        delete m_children[i];
+
+    m_children.clear();
+
+    if ( m_choices.IsOk() )
+    {
+        const wxPGChoices& choices = m_choices;
+
+        for ( i=0; i<GetItemCount(); i++ )
+        {
+            bool child_val;
+            child_val = ( value & choices.GetValue(i) )?true:false;
+
+            wxPGProperty* boolProp;
+            wxString label = GetLabel(i);
+
+        #if wxUSE_INTL
+            if ( wxPGGlobalVars->m_autoGetTranslation )
+            {
+                boolProp = new wxBoolProperty( ::wxGetTranslation(label), label, child_val );
+            }
+            else
+        #endif
+            {
+                boolProp = new wxBoolProperty( label, label, child_val );
+            }
+            AddPrivateChild(boolProp);
+        }
+
+        m_oldChoicesData = m_choices.GetDataPtr();
+    }
+
+    m_oldValue = m_value;
+
+    if ( prevChildCount )
+        SubPropsChanged(oldSel);
+}
+
+wxFlagsProperty::wxFlagsProperty( const wxString& label, const wxString& name,
+    const wxChar** labels, const long* values, long value ) : wxPGProperty(label,name)
+{
+    m_oldChoicesData = NULL;
+
+    if ( labels )
+    {
+        m_choices.Set(labels,values);
+
+        wxASSERT( GetItemCount() );
+
+        SetValue( value );
+    }
+    else
+    {
+        m_value = wxPGVariant_Zero;
+    }
+}
+
+wxFlagsProperty::wxFlagsProperty( const wxString& label, const wxString& name,
+        const wxArrayString& labels, const wxArrayInt& values, int value )
+    : wxPGProperty(label,name)
+{
+    m_oldChoicesData = NULL;
+
+    if ( &labels && labels.size() )
+    {
+        m_choices.Set(labels,values);
+
+        wxASSERT( GetItemCount() );
+
+        SetValue( (long)value );
+    }
+    else
+    {
+        m_value = wxPGVariant_Zero;
+    }
+}
+
+wxFlagsProperty::wxFlagsProperty( const wxString& label, const wxString& name,
+    wxPGChoices& choices, long value )
+    : wxPGProperty(label,name)
+{
+    m_oldChoicesData = NULL;
+
+    if ( choices.IsOk() )
+    {
+        m_choices.Assign(choices);
+
+        wxASSERT( GetItemCount() );
+
+        SetValue( value );
+    }
+    else
+    {
+        m_value = wxPGVariant_Zero;
+    }
+}
+
+wxFlagsProperty::~wxFlagsProperty()
+{
+}
+
+void wxFlagsProperty::OnSetValue()
+{
+    if ( !m_choices.IsOk() || !GetItemCount() )
+    {
+        m_value = wxPGVariant_Zero;
+    }
+    else
+    {
+        long val = m_value.GetLong();
+
+        long fullFlags = 0;
+
+        // normalize the value (i.e. remove extra flags)
+        unsigned int i;
+        const wxPGChoices& choices = m_choices;
+        for ( i = 0; i < GetItemCount(); i++ )
+        {
+            fullFlags |= choices.GetValue(i);
+        }
+
+        val &= fullFlags;
+
+        m_value = val;
+
+        // Need to (re)init now?
+        if ( GetChildCount() != GetItemCount() ||
+             m_choices.GetDataPtr() != m_oldChoicesData )
+        {
+            Init();
+        }
+    }
+
+    long newFlags = m_value;
+
+    if ( newFlags != m_oldValue )
+    {
+        // Set child modified states
+        unsigned int i;
+        const wxPGChoices& choices = m_choices;
+        for ( i = 0; i<GetItemCount(); i++ )
+        {
+            int flag;
+
+            flag = choices.GetValue(i);
+
+            if ( (newFlags & flag) != (m_oldValue & flag) )
+                Item(i)->SetFlag( wxPG_PROP_MODIFIED );
+        }
+
+        m_oldValue = newFlags;
+    }
+}
+
+wxString wxFlagsProperty::ValueToString( wxVariant& value,
+                                         int WXUNUSED(argFlags) ) const
+{
+    wxString text;
+
+    if ( !m_choices.IsOk() )
+        return text;
+
+    long flags = value;
+    unsigned int i;
+    const wxPGChoices& choices = m_choices;
+
+    for ( i = 0; i < GetItemCount(); i++ )
+    {
+        int doAdd;
+        doAdd = ( flags & choices.GetValue(i) );
+
+        if ( doAdd )
+        {
+            text += choices.GetLabel(i);
+            text += wxS(", ");
+        }
+    }
+
+    // remove last comma
+    if ( text.Len() > 1 )
+        text.Truncate ( text.Len() - 2 );
+
+    return text;
+}
+
+// Translate string into flag tokens
+bool wxFlagsProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
+{
+    if ( !m_choices.IsOk() )
+        return false;
+
+    long newFlags = 0;
+
+    // semicolons are no longer valid delimeters
+    WX_PG_TOKENIZER1_BEGIN(text,wxS(','))
+
+        if ( token.length() )
+        {
+            // Determine which one it is
+            long bit = IdToBit( token );
+
+            if ( bit != -1 )
+            {
+                // Changed?
+                newFlags |= bit;
+            }
+            else
+            {
+                break;
+            }
+        }
+
+    WX_PG_TOKENIZER1_END()
+
+    if ( variant != (long)newFlags )
+    {
+        variant = (long)newFlags;
+        return true;
+    }
+
+    return false;
+}
+
+// Converts string id to a relevant bit.
+long wxFlagsProperty::IdToBit( const wxString& id ) const
+{
+    unsigned int i;
+    for ( i = 0; i < GetItemCount(); i++ )
+    {
+        if ( id == GetLabel(i) )
+        {
+            return m_choices.GetValue(i);
+        }
+    }
+    return -1;
+}
+
+void wxFlagsProperty::RefreshChildren()
+{
+    if ( !m_choices.IsOk() || !GetChildCount() ) return;
+
+    int flags = m_value.GetLong();
+
+    const wxPGChoices& choices = m_choices;
+    unsigned int i;
+    for ( i = 0; i < GetItemCount(); i++ )
+    {
+        long flag;
+
+        flag = choices.GetValue(i);
+
+        long subVal = flags & flag;
+        wxPGProperty* p = Item(i);
+
+        if ( subVal != (m_oldValue & flag) )
+            p->SetFlag( wxPG_PROP_MODIFIED );
+
+        p->SetValue( subVal?true:false );
+    }
+
+    m_oldValue = flags;
+}
+
+void wxFlagsProperty::ChildChanged( wxVariant& thisValue, int childIndex, wxVariant& childValue ) const
+{
+    long oldValue = thisValue.GetLong();
+    long val = childValue.GetLong();
+    unsigned long vi = m_choices.GetValue(childIndex);
+    if ( val )
+        thisValue = (long)(oldValue | vi);
+    else
+        thisValue = (long)(oldValue & ~(vi));
+}
+
+// -----------------------------------------------------------------------
+// wxDirProperty
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxDirProperty, wxLongStringProperty)
+
+wxDirProperty::wxDirProperty( const wxString& name, const wxString& label, const wxString& value )
+  : wxLongStringProperty(name,label,value)
+{
+    m_flags |= wxPG_PROP_NO_ESCAPE;
+}
+
+wxDirProperty::~wxDirProperty() { }
+
+wxValidator* wxDirProperty::DoGetValidator() const
+{
+    return wxFileProperty::GetClassValidator();
+}
+
+bool wxDirProperty::OnButtonClick( wxPropertyGrid* propGrid, wxString& value )
+{
+    // Update property value from editor, if necessary
+    wxSize dlg_sz(300,400);
+
+    wxString dlgMessage(m_dlgMessage);
+    if ( dlgMessage.empty() )
+        dlgMessage = _("Choose a directory:");
+    wxDirDialog dlg( propGrid,
+                     dlgMessage,
+                     value,
+                     0,
+#if !wxPG_SMALL_SCREEN
+                     propGrid->GetGoodEditorDialogPosition(this,dlg_sz),
+                     dlg_sz
+#else
+                     wxDefaultPosition,
+                     wxDefaultSize
+#endif
+                    );
+
+    if ( dlg.ShowModal() == wxID_OK )
+    {
+        value = dlg.GetPath();
+        return true;
+    }
+    return false;
+}
+
+bool wxDirProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    if ( name == wxPG_DIR_DIALOG_MESSAGE )
+    {
+        m_dlgMessage = value.GetString();
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPGFileDialogAdapter
+// -----------------------------------------------------------------------
+
+bool wxPGFileDialogAdapter::DoShowDialog( wxPropertyGrid* propGrid, wxPGProperty* property )
+{
+    wxFileProperty* fileProp = NULL;
+    wxString path;
+    int indFilter = -1;
+
+    if ( property->IsKindOf(CLASSINFO(wxFileProperty)) )
+    {
+        fileProp = ((wxFileProperty*)property);
+        wxFileName filename = fileProp->GetValue().GetString();
+        path = filename.GetPath();
+        indFilter = fileProp->m_indFilter;
+
+        if ( !path.length() && fileProp->m_basePath.length() )
+            path = fileProp->m_basePath;
+    }
+    else
+    {
+        wxFileName fn(property->GetValue().GetString());
+        path = fn.GetPath();
+    }
+
+    wxFileDialog dlg( propGrid->GetPanel(),
+                      property->GetAttribute(wxS("DialogTitle"), _("Choose a file")),
+                      property->GetAttribute(wxS("InitialPath"), path),
+                      wxEmptyString,
+                      property->GetAttribute(wxPG_FILE_WILDCARD, _("All files (*.*)|*.*")),
+                      0,
+                      wxDefaultPosition );
+
+    if ( indFilter >= 0 )
+        dlg.SetFilterIndex( indFilter );
+
+    if ( dlg.ShowModal() == wxID_OK )
+    {
+        if ( fileProp )
+            fileProp->m_indFilter = dlg.GetFilterIndex();
+        SetValue( dlg.GetPath() );
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxFileProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxFileProperty,wxPGProperty,
+                               wxString,const wxString&,TextCtrlAndButton)
+
+wxFileProperty::wxFileProperty( const wxString& label, const wxString& name,
+    const wxString& value ) : wxPGProperty(label,name)
+{
+    m_flags |= wxPG_PROP_SHOW_FULL_FILENAME;
+    m_indFilter = -1;
+    SetAttribute( wxPG_FILE_WILDCARD, _("All files (*.*)|*.*") );
+
+    SetValue(value);
+}
+
+wxFileProperty::~wxFileProperty() {}
+
+#if wxUSE_VALIDATORS
+
+wxValidator* wxFileProperty::GetClassValidator()
+{
+    WX_PG_DOGETVALIDATOR_ENTRY()
+
+    // Atleast wxPython 2.6.2.1 required that the string argument is given
+    static wxString v;
+    wxTextValidator* validator = new wxTextValidator(wxFILTER_EXCLUDE_CHAR_LIST,&v);
+
+    wxArrayString exChars;
+    exChars.Add(wxS("?"));
+    exChars.Add(wxS("*"));
+    exChars.Add(wxS("|"));
+    exChars.Add(wxS("<"));
+    exChars.Add(wxS(">"));
+    exChars.Add(wxS("\""));
+
+    validator->SetExcludes(exChars);
+
+    WX_PG_DOGETVALIDATOR_EXIT(validator)
+}
+
+wxValidator* wxFileProperty::DoGetValidator() const
+{
+    return GetClassValidator();
+}
+
+#endif
+
+void wxFileProperty::OnSetValue()
+{
+    const wxString& fnstr = m_value.GetString();
+
+    wxFileName filename = fnstr;
+
+    if ( !filename.HasName() )
+    {
+        m_value = wxPGVariant_EmptyString;
+    }
+
+    // Find index for extension.
+    if ( m_indFilter < 0 && fnstr.length() )
+    {
+        wxString ext = filename.GetExt();
+        int curind = 0;
+        size_t pos = 0;
+        size_t len = m_wildcard.length();
+
+        pos = m_wildcard.find(wxS("|"), pos);
+        while ( pos != wxString::npos && pos < (len-3) )
+        {
+            size_t ext_begin = pos + 3;
+
+            pos = m_wildcard.find(wxS("|"), ext_begin);
+            if ( pos == wxString::npos )
+                pos = len;
+            wxString found_ext = m_wildcard.substr(ext_begin, pos-ext_begin);
+
+            if ( found_ext.length() > 0 )
+            {
+                if ( found_ext[0] == wxS('*') )
+                {
+                    m_indFilter = curind;
+                    break;
+                }
+                if ( ext.CmpNoCase(found_ext) == 0 )
+                {
+                    m_indFilter = curind;
+                    break;
+                }
+            }
+
+            if ( pos != len )
+                pos = m_wildcard.find(wxS("|"), pos+1);
+
+            curind++;
+        }
+    }
+}
+
+wxFileName wxFileProperty::GetFileName() const
+{
+    wxFileName filename;
+
+    if ( !m_value.IsNull() )
+        filename = m_value.GetString();
+
+    return filename;
+}
+
+wxString wxFileProperty::ValueToString( wxVariant& value,
+                                        int argFlags ) const
+{
+    wxFileName filename = value.GetString();
+
+    if ( !filename.HasName() )
+        return wxEmptyString;
+
+    wxString fullName = filename.GetFullName();
+    if ( !fullName.length() )
+        return wxEmptyString;
+
+    if ( argFlags & wxPG_FULL_VALUE )
+    {
+        return filename.GetFullPath();
+    }
+    else if ( m_flags & wxPG_PROP_SHOW_FULL_FILENAME )
+    {
+        if ( m_basePath.Length() )
+        {
+            wxFileName fn2(filename);
+            fn2.MakeRelativeTo(m_basePath);
+            return fn2.GetFullPath();
+        }
+        return filename.GetFullPath();
+    }
+
+    return filename.GetFullName();
+}
+
+wxPGEditorDialogAdapter* wxFileProperty::GetEditorDialog() const
+{
+    return new wxPGFileDialogAdapter();
+}
+
+bool wxFileProperty::StringToValue( wxVariant& variant, const wxString& text, int argFlags ) const
+{
+    wxFileName filename = variant.GetString();
+
+    if ( (m_flags & wxPG_PROP_SHOW_FULL_FILENAME) || (argFlags & wxPG_FULL_VALUE) )
+    {
+        if ( filename != text )
+        {
+            variant = text;
+            return true;
+        }
+    }
+    else
+    {
+        if ( filename.GetFullName() != text )
+        {
+            wxFileName fn = filename;
+            fn.SetFullName(text);
+            variant = fn.GetFullPath();
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool wxFileProperty::DoSetAttribute( const wxString& name, wxVariant& value )
+{
+    // Return false on some occasions to make sure those attribs will get
+    // stored in m_attributes.
+    if ( name == wxPG_FILE_SHOW_FULL_PATH )
+    {
+        if ( wxPGVariantToInt(value) )
+            m_flags |= wxPG_PROP_SHOW_FULL_FILENAME;
+        else
+            m_flags &= ~(wxPG_PROP_SHOW_FULL_FILENAME);
+        return true;
+    }
+    else if ( name == wxPG_FILE_WILDCARD )
+    {
+        m_wildcard = value.GetString();
+    }
+    else if ( name == wxPG_FILE_SHOW_RELATIVE_PATH )
+    {
+        m_basePath = value.GetString();
+
+        // Make sure wxPG_FILE_SHOW_FULL_PATH is also set
+        m_flags |= wxPG_PROP_SHOW_FULL_FILENAME;
+    }
+    else if ( name == wxPG_FILE_INITIAL_PATH )
+    {
+        m_initialPath = value.GetString();
+        return true;
+    }
+    else if ( name == wxPG_FILE_DIALOG_TITLE )
+    {
+        m_dlgTitle = value.GetString();
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxPGLongStringDialogAdapter
+// -----------------------------------------------------------------------
+
+bool wxPGLongStringDialogAdapter::DoShowDialog( wxPropertyGrid* propGrid, wxPGProperty* property )
+{
+    wxString val1 = property->GetValueAsString(0);
+    wxString val_orig = val1;
+
+    wxString value;
+    if ( !property->HasFlag(wxPG_PROP_NO_ESCAPE) )
+        wxPropertyGrid::ExpandEscapeSequences(value, val1);
+    else
+        value = wxString(val1);
+
+    // Run editor dialog.
+    if ( wxLongStringProperty::DisplayEditorDialog(property, propGrid, value) )
+    {
+        if ( !property->HasFlag(wxPG_PROP_NO_ESCAPE) )
+            wxPropertyGrid::CreateEscapeSequences(val1,value);
+        else
+            val1 = value;
+
+        if ( val1 != val_orig )
+        {
+            SetValue( val1 );
+            return true;
+        }
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxLongStringProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxLongStringProperty,wxPGProperty,
+                               wxString,const wxString&,TextCtrlAndButton)
+
+wxLongStringProperty::wxLongStringProperty( const wxString& label, const wxString& name,
+    const wxString& value ) : wxPGProperty(label,name)
+{
+    SetValue(value);
+}
+
+wxLongStringProperty::~wxLongStringProperty() {}
+
+wxString wxLongStringProperty::ValueToString( wxVariant& value,
+                                              int WXUNUSED(argFlags) ) const
+{
+    return value;
+}
+
+bool wxLongStringProperty::OnEvent( wxPropertyGrid* propGrid, wxWindow* WXUNUSED(primary),
+                                    wxEvent& event )
+{
+    if ( propGrid->IsMainButtonEvent(event) )
+    {
+        // Update the value
+        wxVariant useValue = propGrid->GetUncommittedPropertyValue();
+
+        wxString val1 = useValue.GetString();
+        wxString val_orig = val1;
+
+        wxString value;
+        if ( !(m_flags & wxPG_PROP_NO_ESCAPE) )
+            wxPropertyGrid::ExpandEscapeSequences(value,val1);
+        else
+            value = wxString(val1);
+
+        // Run editor dialog.
+        if ( OnButtonClick(propGrid,value) )
+        {
+            if ( !(m_flags & wxPG_PROP_NO_ESCAPE) )
+                wxPropertyGrid::CreateEscapeSequences(val1,value);
+            else
+                val1 = value;
+
+            if ( val1 != val_orig )
+            {
+                SetValueInEvent( val1 );
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+bool wxLongStringProperty::OnButtonClick( wxPropertyGrid* propGrid, wxString& value )
+{
+    return DisplayEditorDialog(this, propGrid, value);
+}
+
+bool wxLongStringProperty::DisplayEditorDialog( wxPGProperty* prop, wxPropertyGrid* propGrid, wxString& value )
+
+{
+    // launch editor dialog
+    wxDialog* dlg = new wxDialog(propGrid,-1,prop->GetLabel(),wxDefaultPosition,wxDefaultSize,
+                                 wxDEFAULT_DIALOG_STYLE|wxRESIZE_BORDER|wxCLIP_CHILDREN);
+
+    dlg->SetFont(propGrid->GetFont()); // To allow entering chars of the same set as the propGrid
+
+    // Multi-line text editor dialog.
+#if !wxPG_SMALL_SCREEN
+    const int spacing = 8;
+#else
+    const int spacing = 4;
+#endif
+    wxBoxSizer* topsizer = new wxBoxSizer( wxVERTICAL );
+    wxBoxSizer* rowsizer = new wxBoxSizer( wxHORIZONTAL );
+    wxTextCtrl* ed = new wxTextCtrl(dlg,11,value,
+        wxDefaultPosition,wxDefaultSize,wxTE_MULTILINE);
+
+    rowsizer->Add( ed, 1, wxEXPAND|wxALL, spacing );
+    topsizer->Add( rowsizer, 1, wxEXPAND, 0 );
+    rowsizer = new wxBoxSizer( wxHORIZONTAL );
+    const int but_sz_flags =
+        wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL|wxBOTTOM|wxLEFT|wxRIGHT;
+    rowsizer->Add( new wxButton(dlg,wxID_OK,_("Ok")),
+        0, but_sz_flags, spacing );
+    rowsizer->Add( new wxButton(dlg,wxID_CANCEL,_("Cancel")),
+        0, but_sz_flags, spacing );
+    topsizer->Add( rowsizer, 0, wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL, 0 );
+
+    dlg->SetSizer( topsizer );
+    topsizer->SetSizeHints( dlg );
+
+#if !wxPG_SMALL_SCREEN
+    dlg->SetSize(400,300);
+
+    dlg->Move( propGrid->GetGoodEditorDialogPosition(prop,dlg->GetSize()) );
+#endif
+
+    int res = dlg->ShowModal();
+
+    if ( res == wxID_OK )
+    {
+        value = ed->GetValue();
+        dlg->Destroy();
+        return true;
+    }
+    dlg->Destroy();
+    return false;
+}
+
+bool wxLongStringProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
+{
+    if ( variant != text )
+    {
+        variant = text;
+        return true;
+    }
+    return false;
+}
+
+// -----------------------------------------------------------------------
+// wxArrayEditorDialog
+// -----------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(wxArrayEditorDialog, wxDialog)
+    EVT_IDLE(wxArrayEditorDialog::OnIdle)
+    EVT_LISTBOX(24, wxArrayEditorDialog::OnListBoxClick)
+    EVT_TEXT_ENTER(21, wxArrayEditorDialog::OnAddClick)
+    EVT_BUTTON(22, wxArrayEditorDialog::OnAddClick)
+    EVT_BUTTON(23, wxArrayEditorDialog::OnDeleteClick)
+    EVT_BUTTON(25, wxArrayEditorDialog::OnUpClick)
+    EVT_BUTTON(26, wxArrayEditorDialog::OnDownClick)
+    EVT_BUTTON(27, wxArrayEditorDialog::OnUpdateClick)
+    //EVT_BUTTON(28, wxArrayEditorDialog::OnCustomEditClick)
+END_EVENT_TABLE()
+
+IMPLEMENT_ABSTRACT_CLASS(wxArrayEditorDialog, wxDialog)
+
+#include "wx/statline.h"
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnIdle(wxIdleEvent& event)
+{
+    //
+    // Do control focus detection here.
+    //
+
+    wxWindow* focused = FindFocus();
+
+    // This strange focus thing is a workaround for wxGTK wxListBox focus
+    // reporting bug.
+    if ( m_curFocus == 0 && focused != m_edValue &&
+         focused != m_butAdd && focused != m_butUpdate &&
+         m_lbStrings->GetSelection() >= 0 )
+    {
+        // ListBox was just focused.
+        m_butAdd->Enable(false);
+        m_butUpdate->Enable(false);
+        m_butRemove->Enable(true);
+        m_butUp->Enable(true);
+        m_butDown->Enable(true);
+        m_curFocus = 1;
+    }
+    else if ( (m_curFocus == 1 && focused == m_edValue) /*|| m_curFocus == 2*/ )
+    {
+        // TextCtrl was just focused.
+        m_butAdd->Enable(true);
+        bool upd_enable = false;
+        if ( m_lbStrings->GetCount() && m_lbStrings->GetSelection() >= 0 )
+            upd_enable = true;
+        m_butUpdate->Enable(upd_enable);
+        m_butRemove->Enable(false);
+        m_butUp->Enable(false);
+        m_butDown->Enable(false);
+        m_curFocus = 0;
+    }
+
+    event.Skip();
+}
+
+// -----------------------------------------------------------------------
+
+wxArrayEditorDialog::wxArrayEditorDialog()
+    : wxDialog()
+{
+    Init();
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::Init()
+{
+    m_custBtText = (const wxChar*) NULL;
+}
+
+// -----------------------------------------------------------------------
+
+wxArrayEditorDialog::wxArrayEditorDialog( wxWindow *parent,
+                                          const wxString& message,
+                                          const wxString& caption,
+                                          long style,
+                                          const wxPoint& pos,
+                                          const wxSize& sz )
+    : wxDialog()
+{
+    Init();
+    Create(parent,message,caption,style,pos,sz);
+}
+
+// -----------------------------------------------------------------------
+
+bool wxArrayEditorDialog::Create( wxWindow *parent,
+                                  const wxString& message,
+                                  const wxString& caption,
+                                  long style,
+                                  const wxPoint& pos,
+                                  const wxSize& sz )
+{
+    // On wxMAC the dialog shows incorrectly if style is not exactly wxCAPTION
+    // FIXME: This should be only a temporary fix.
+#ifdef __WXMAC__
+    wxUnusedVar(style);
+    int useStyle = wxCAPTION;
+#else
+    int useStyle = style;
+#endif
+
+    bool res = wxDialog::Create(parent, wxID_ANY, caption, pos, sz, useStyle);
+
+    SetFont(parent->GetFont()); // To allow entering chars of the same set as the propGrid
+
+#if !wxPG_SMALL_SCREEN
+    const int spacing = 4;
+#else
+    const int spacing = 3;
+#endif
+
+    m_modified = false;
+
+    m_curFocus = 1;
+
+    const int but_sz_flags =
+        wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL|wxALL; //wxBOTTOM|wxLEFT|wxRIGHT;
+
+    wxBoxSizer* topsizer = new wxBoxSizer( wxVERTICAL );
+
+    // Message
+    if ( message.length() )
+        topsizer->Add( new wxStaticText(this,-1,message),
+            0, wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxALL, spacing );
+
+    // String editor
+    wxBoxSizer* rowsizer = new wxBoxSizer( wxHORIZONTAL );
+    m_edValue = new wxTextCtrl(this,21,wxEmptyString,
+        wxDefaultPosition,wxDefaultSize,wxTE_PROCESS_ENTER);
+    wxValidator* validator = GetTextCtrlValidator();
+    if ( validator )
+    {
+        m_edValue->SetValidator( *validator );
+        delete validator;
+    }
+    rowsizer->Add( m_edValue,
+        1, wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxALL, spacing );
+
+    // Add button
+    m_butAdd = new wxButton(this,22,_("Add"));
+    rowsizer->Add( m_butAdd,
+        0, wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxTOP|wxBOTTOM|wxRIGHT, spacing );
+    topsizer->Add( rowsizer, 0, wxEXPAND, spacing );
+
+    // Separator line
+    topsizer->Add( new wxStaticLine(this,-1),
+        0, wxEXPAND|wxBOTTOM|wxLEFT|wxRIGHT, spacing );
+
+    rowsizer = new wxBoxSizer( wxHORIZONTAL );
+
+    // list box
+    m_lbStrings = new wxListBox(this, 24, wxDefaultPosition, wxDefaultSize);
+    unsigned int i;
+    for ( i=0; i<ArrayGetCount(); i++ )
+        m_lbStrings->Append( ArrayGet(i) );
+    rowsizer->Add( m_lbStrings, 1, wxEXPAND|wxRIGHT, spacing );
+
+    // Manipulator buttons
+    wxBoxSizer* colsizer = new wxBoxSizer( wxVERTICAL );
+    m_butCustom = NULL;
+    if ( m_custBtText )
+    {
+        m_butCustom = new wxButton(this,28,::wxGetTranslation(m_custBtText));
+        colsizer->Add( m_butCustom,
+            0, wxALIGN_CENTER|wxTOP/*wxALIGN_LEFT|wxALIGN_CENTRE_VERTICAL|wxTOP|wxBOTTOM|wxRIGHT*/,
+            spacing );
+    }
+    m_butUpdate = new wxButton(this,27,_("Update"));
+    colsizer->Add( m_butUpdate,
+        0, wxALIGN_CENTER|wxTOP, spacing );
+    m_butRemove = new wxButton(this,23,_("Remove"));
+    colsizer->Add( m_butRemove,
+        0, wxALIGN_CENTER|wxTOP, spacing );
+    m_butUp = new wxButton(this,25,_("Up"));
+    colsizer->Add( m_butUp,
+        0, wxALIGN_CENTER|wxTOP, spacing );
+    m_butDown = new wxButton(this,26,_("Down"));
+    colsizer->Add( m_butDown,
+        0, wxALIGN_CENTER|wxTOP, spacing );
+    rowsizer->Add( colsizer, 0, 0, spacing );
+
+    topsizer->Add( rowsizer, 1, wxLEFT|wxRIGHT|wxEXPAND, spacing );
+
+    // Separator line
+    topsizer->Add( new wxStaticLine(this,-1),
+        0, wxEXPAND|wxTOP|wxLEFT|wxRIGHT, spacing );
+
+    // buttons
+    rowsizer = new wxBoxSizer( wxHORIZONTAL );
+    /*
+    const int but_sz_flags =
+        wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL|wxBOTTOM|wxLEFT|wxRIGHT;
+    */
+    rowsizer->Add( new wxButton(this,wxID_OK,_("Ok")),
+        0, but_sz_flags, spacing );
+    rowsizer->Add( new wxButton(this,wxID_CANCEL,_("Cancel")),
+        0, but_sz_flags, spacing );
+    topsizer->Add( rowsizer, 0, wxALIGN_RIGHT|wxALIGN_CENTRE_VERTICAL, 0 );
+
+    m_edValue->SetFocus();
+
+    SetSizer( topsizer );
+    topsizer->SetSizeHints( this );
+
+#if !wxPG_SMALL_SCREEN
+    if ( sz.x == wxDefaultSize.x &&
+         sz.y == wxDefaultSize.y )
+        SetSize( wxSize(275,360) );
+    else
+        SetSize(sz);
+#endif
+
+    return res;
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnAddClick(wxCommandEvent& )
+{
+    wxString text = m_edValue->GetValue();
+    if ( text.length() )
+    {
+        if ( ArrayInsert( text, -1 ) )
+        {
+            m_lbStrings->Append( text );
+            m_modified = true;
+            m_edValue->Clear();
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnDeleteClick(wxCommandEvent& )
+{
+    int index = m_lbStrings->GetSelection();
+    if ( index >= 0 )
+    {
+        ArrayRemoveAt( index );
+        m_lbStrings->Delete ( index );
+        m_modified = true;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnUpClick(wxCommandEvent& )
+{
+    int index = m_lbStrings->GetSelection();
+    if ( index > 0 )
+    {
+        ArraySwap(index-1,index);
+        /*wxString old_str = m_array[index-1];
+        wxString new_str = m_array[index];
+        m_array[index-1] = new_str;
+        m_array[index] = old_str;*/
+        m_lbStrings->SetString ( index-1, ArrayGet(index-1) );
+        m_lbStrings->SetString ( index, ArrayGet(index) );
+        m_lbStrings->SetSelection ( index-1 );
+        m_modified = true;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnDownClick(wxCommandEvent& )
+{
+    int index = m_lbStrings->GetSelection();
+    int lastStringIndex = ((int) m_lbStrings->GetCount()) - 1;
+    if ( index >= 0 && index < lastStringIndex )
+    {
+        ArraySwap(index,index+1);
+        /*wxString old_str = m_array[index+1];
+        wxString new_str = m_array[index];
+        m_array[index+1] = new_str;
+        m_array[index] = old_str;*/
+        m_lbStrings->SetString ( index+1, ArrayGet(index+1) );
+        m_lbStrings->SetString ( index, ArrayGet(index) );
+        m_lbStrings->SetSelection ( index+1 );
+        m_modified = true;
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnUpdateClick(wxCommandEvent& )
+{
+    int index = m_lbStrings->GetSelection();
+    if ( index >= 0 )
+    {
+        wxString str = m_edValue->GetValue();
+        if ( ArraySet(index,str) )
+        {
+            m_lbStrings->SetString ( index, str );
+            //m_array[index] = str;
+            m_modified = true;
+        }
+    }
+}
+
+// -----------------------------------------------------------------------
+
+void wxArrayEditorDialog::OnListBoxClick(wxCommandEvent& )
+{
+    int index = m_lbStrings->GetSelection();
+    if ( index >= 0 )
+    {
+        m_edValue->SetValue( m_lbStrings->GetString(index) );
+    }
+}
+
+// -----------------------------------------------------------------------
+// wxPGArrayStringEditorDialog
+// -----------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxPGArrayStringEditorDialog, wxArrayEditorDialog)
+
+BEGIN_EVENT_TABLE(wxPGArrayStringEditorDialog, wxArrayEditorDialog)
+    EVT_BUTTON(28, wxPGArrayStringEditorDialog::OnCustomEditClick)
+END_EVENT_TABLE()
+
+// -----------------------------------------------------------------------
+
+wxString wxPGArrayStringEditorDialog::ArrayGet( size_t index )
+{
+    return m_array[index];
+}
+
+size_t wxPGArrayStringEditorDialog::ArrayGetCount()
+{
+    return m_array.size();
+}
+
+bool wxPGArrayStringEditorDialog::ArrayInsert( const wxString& str, int index )
+{
+    if (index<0)
+        m_array.Add(str);
+    else
+        m_array.Insert(str,index);
+    return true;
+}
+
+bool wxPGArrayStringEditorDialog::ArraySet( size_t index, const wxString& str )
+{
+    m_array[index] = str;
+    return true;
+}
+
+void wxPGArrayStringEditorDialog::ArrayRemoveAt( int index )
+{
+    m_array.RemoveAt(index);
+}
+
+void wxPGArrayStringEditorDialog::ArraySwap( size_t first, size_t second )
+{
+    wxString old_str = m_array[first];
+    wxString new_str = m_array[second];
+    m_array[first] = new_str;
+    m_array[second] = old_str;
+}
+
+wxPGArrayStringEditorDialog::wxPGArrayStringEditorDialog()
+    : wxArrayEditorDialog()
+{
+    Init();
+}
+
+void wxPGArrayStringEditorDialog::Init()
+{
+    m_pCallingClass = NULL;
+}
+
+void wxPGArrayStringEditorDialog::OnCustomEditClick(wxCommandEvent& )
+{
+    wxASSERT( m_pCallingClass );
+    wxString str = m_edValue->GetValue();
+    if ( m_pCallingClass->OnCustomStringEdit(m_parent,str) )
+    {
+        //m_edValue->SetValue ( str );
+        m_lbStrings->Append ( str );
+        m_array.Add ( str );
+        m_modified = true;
+    }
+}
+
+// -----------------------------------------------------------------------
+// wxArrayStringProperty
+// -----------------------------------------------------------------------
+
+WX_PG_IMPLEMENT_PROPERTY_CLASS(wxArrayStringProperty,  // Property name
+                               wxPGProperty,  // Property we inherit from
+                               wxArrayString,  // Value type name
+                               const wxArrayString&,  // Value type, as given in constructor
+                               TextCtrlAndButton)  // Initial editor
+
+wxArrayStringProperty::wxArrayStringProperty( const wxString& label,
+                                                        const wxString& name,
+                                                        const wxArrayString& array )
+    : wxPGProperty(label,name)
+{
+    SetValue( array );
+}
+
+wxArrayStringProperty::~wxArrayStringProperty() { }
+
+void wxArrayStringProperty::OnSetValue()
+{
+    GenerateValueAsString();
+}
+
+#define ARRSTRPROP_ARRAY_TO_STRING(STRING,ARRAY) \
+    wxPropertyGrid::ArrayStringToString(STRING,ARRAY,wxS('"'),wxS('"'),1)
+
+wxString wxArrayStringProperty::ValueToString( wxVariant& WXUNUSED(value),
+                                               int argFlags ) const
+{
+    //
+    // If this is called from GetValueAsString(), return cached string
+    if ( argFlags & wxPG_VALUE_IS_CURRENT )
+    {
+        return m_display;
+    }
+
+    wxArrayString arr = m_value.GetArrayString();
+    wxString s;
+    ARRSTRPROP_ARRAY_TO_STRING(s, arr);
+    return s;
+}
+
+// Converts wxArrayString to a string separated by delimeters and spaces.
+// preDelim is useful for "str1" "str2" style. Set flags to 1 to do slash
+// conversion.
+void wxPropertyGrid::ArrayStringToString( wxString& dst, const wxArrayString& src,
+                                          wxChar preDelim, wxChar postDelim,
+                                          int flags )
+{
+    wxString pdr;
+
+    unsigned int i;
+    unsigned int itemCount = src.size();
+
+    wxChar preas[2] = { 0, 0 };
+
+    dst.Empty();
+
+    if ( flags & 1 )
+    {
+        preas[0] = preDelim;
+        pdr = wxS("\\");
+        pdr += preDelim;
+    }
+
+    if ( itemCount )
+        dst.append( preas );
+
+    wxASSERT( postDelim );
+    wxString postDelimStr(postDelim);
+    //wxString preDelimStr(preDelim);
+
+    for ( i = 0; i < itemCount; i++ )
+    {
+        wxString str( src.Item(i) );
+
+        // Do some character conversion.
+        // Convertes \ to \\ and <preDelim> to \<preDelim>
+        // Useful when preDelim and postDelim are "\"".
+        if ( flags & 1 )
+        {
+            str.Replace( wxS("\\"), wxS("\\\\"), true );
+            if ( pdr.length() )
+                str.Replace( preas, pdr, true );
+        }
+
+        dst.append( str );
+
+        if ( i < (itemCount-1) )
+        {
+            dst.append( postDelimStr );
+            dst.append( wxS(" ") );
+            dst.append( preas );
+        }
+        else if ( preDelim )
+            dst.append( postDelimStr );
+    }
+}
+
+void wxArrayStringProperty::GenerateValueAsString()
+{
+    wxArrayString arr = m_value.GetArrayString();
+    ARRSTRPROP_ARRAY_TO_STRING(m_display, arr);
+}
+
+// Default implementation doesn't do anything.
+bool wxArrayStringProperty::OnCustomStringEdit( wxWindow*, wxString& )
+{
+    return false;
+}
+
+wxArrayEditorDialog* wxArrayStringProperty::CreateEditorDialog()
+{
+    return new wxPGArrayStringEditorDialog();
+}
+
+bool wxArrayStringProperty::OnButtonClick( wxPropertyGrid* propGrid,
+                                           wxWindow* WXUNUSED(primaryCtrl),
+                                           const wxChar* cbt )
+{
+    // Update the value
+    wxVariant useValue = propGrid->GetUncommittedPropertyValue();
+
+    if ( !propGrid->EditorValidate() )
+        return false;
+
+    // Create editor dialog.
+    wxArrayEditorDialog* dlg = CreateEditorDialog();
+#if wxUSE_VALIDATORS
+    wxValidator* validator = GetValidator();
+    wxPGInDialogValidator dialogValidator;
+#endif
+
+    wxPGArrayStringEditorDialog* strEdDlg = wxDynamicCast(dlg, wxPGArrayStringEditorDialog);
+
+    if ( strEdDlg )
+        strEdDlg->SetCustomButton(cbt, this);
+
+    dlg->SetDialogValue( useValue );
+    dlg->Create(propGrid, wxEmptyString, m_label);
+
+#if !wxPG_SMALL_SCREEN
+    dlg->Move( propGrid->GetGoodEditorDialogPosition(this,dlg->GetSize()) );
+#endif
+
+    bool retVal;
+
+    for (;;)
+    {
+        retVal = false;
+
+        int res = dlg->ShowModal();
+
+        if ( res == wxID_OK && dlg->IsModified() )
+        {
+            wxVariant value = dlg->GetDialogValue();
+            if ( !value.IsNull() )
+            {
+                wxArrayString actualValue = value.GetArrayString();
+                wxString tempStr;
+                ARRSTRPROP_ARRAY_TO_STRING(tempStr, actualValue);
+            #if wxUSE_VALIDATORS
+                if ( dialogValidator.DoValidate( propGrid, validator, tempStr ) )
+            #endif
+                {
+                    SetValueInEvent( actualValue );
+                    retVal = true;
+                    break;
+                }
+            }
+            else
+                break;
+        }
+        else
+            break;
+    }
+
+    delete dlg;
+
+    return retVal;
+}
+
+bool wxArrayStringProperty::OnEvent( wxPropertyGrid* propGrid,
+                                     wxWindow* primary,
+                                     wxEvent& event )
+{
+    if ( propGrid->IsMainButtonEvent(event) )
+        return OnButtonClick(propGrid,primary,(const wxChar*) NULL);
+    return false;
+}
+
+bool wxArrayStringProperty::StringToValue( wxVariant& variant, const wxString& text, int ) const
+{
+    wxArrayString arr;
+
+    WX_PG_TOKENIZER2_BEGIN(text,wxS('"'))
+
+        // Need to replace backslashes with empty characters
+        // (opposite what is done in GenerateValueString).
+        token.Replace ( wxS("\\"), wxEmptyString, true );
+
+        arr.Add( token );
+
+    WX_PG_TOKENIZER2_END()
+
+    variant = arr;
+
+    return true;
+}
+
+// -----------------------------------------------------------------------
+// wxPGInDialogValidator
+// -----------------------------------------------------------------------
+
+#if wxUSE_VALIDATORS
+bool wxPGInDialogValidator::DoValidate( wxPropertyGrid* propGrid,
+                                        wxValidator* validator,
+                                        const wxString& value )
+{
+    if ( !validator )
+        return true;
+
+    wxTextCtrl* tc = m_textCtrl;
+
+    if ( !tc )
+    {
+        {
+            tc = new wxTextCtrl( propGrid, wxPG_SUBID_TEMP1, wxEmptyString,
+                                 wxPoint(30000,30000));
+            tc->Hide();
+        }
+
+        m_textCtrl = tc;
+    }
+
+    tc->SetValue(value);
+
+    validator->SetWindow(tc);
+    bool res = validator->Validate(propGrid);
+
+    return res;
+}
+#else
+bool wxPGInDialogValidator::DoValidate( wxPropertyGrid* WXUNUSED(propGrid),
+                                        wxValidator* WXUNUSED(validator),
+                                        const wxString& WXUNUSED(value) )
+{
+    return true;
+}
+#endif
+
+// -----------------------------------------------------------------------
+
+#endif  // wxUSE_PROPGRID
