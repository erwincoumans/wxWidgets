static const char* radixSort32KernelsCL= \
"\n"
"\n"
"#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable\n"
"#pragma OPENCL EXTENSION cl_khr_global_int32_base_atomics : enable\n"
"\n"
"typedef unsigned int u32;\n"
"#define GET_GROUP_IDX get_group_id(0)\n"
"#define GET_LOCAL_IDX get_local_id(0)\n"
"#define GET_GLOBAL_IDX get_global_id(0)\n"
"#define GET_GROUP_SIZE get_local_size(0)\n"
"#define GROUP_LDS_BARRIER barrier(CLK_LOCAL_MEM_FENCE)\n"
"#define GROUP_MEM_FENCE mem_fence(CLK_LOCAL_MEM_FENCE)\n"
"#define AtomInc(x) atom_inc(&(x))\n"
"#define AtomInc1(x, out) out = atom_inc(&(x))\n"
"#define AtomAdd(x, value) atom_add(&(x), value)\n"
"\n"
"#define SELECT_UINT4( b, a, condition ) select( b,a,condition )\n"
"\n"
"\n"
"#define make_uint4 (uint4)\n"
"#define make_uint2 (uint2)\n"
"#define make_int2 (int2)\n"
"\n"
"#define WG_SIZE 64\n"
"#define ELEMENTS_PER_WORK_ITEM 4\n"
"#define BITS_PER_PASS 4\n"
"#define NUM_BUCKET (1<<BITS_PER_PASS)\n"
"typedef uchar u8;\n"
"\n"
"//	this isn't optimization for VLIW. But just reducing writes. \n"
"#define USE_2LEVEL_REDUCE 1\n"
"\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_n;\n"
"	int m_nWGs;\n"
"	int m_startBit;\n"
"	int m_nBlocksPerWG;\n"
"} ConstBuffer;\n"
"\n"
"\n"
"u32 prefixScanEx( u32* data )\n"
"{\n"
"	u32 sum = 0;\n"
"	u32 tmp = data[0];\n"
"	data[0] = sum;\n"
"	sum += tmp;\n"
"	tmp = data[1];\n"
"	data[1] = sum;\n"
"	sum += tmp;\n"
"	tmp = data[2];\n"
"	data[2] = sum;\n"
"	sum += tmp;\n"
"	tmp = data[3];\n"
"	data[3] = sum;\n"
"	sum += tmp;\n"
"	return sum;\n"
"}\n"
"\n"
"\n"
"uint prefixScanVectorEx( uint4* data )\n"
"{\n"
"/*\n"
"	uint4 backup = data[0];\n"
"	data[0].y += data[0].x;\n"
"	data[0].w += data[0].z;\n"
"	data[0].z += data[0].y;\n"
"	data[0].w += data[0].y;\n"
"	uint sum = data[0].w;\n"
"	data[0] -= backup;\n"
"	return sum;\n"
"*/\n"
"	u32 sum = 0;\n"
"	u32 tmp = data[0].x;\n"
"	data[0].x = sum;\n"
"	sum += tmp;\n"
"	tmp = data[0].y;\n"
"	data[0].y = sum;\n"
"	sum += tmp;\n"
"	tmp = data[0].z;\n"
"	data[0].z = sum;\n"
"	sum += tmp;\n"
"	tmp = data[0].w;\n"
"	data[0].w = sum;\n"
"	sum += tmp;\n"
"	return sum;\n"
"}\n"
"\n"
"/*\n"
"//__attribute__((reqd_work_group_size(128,1,1)))\n"
"u32 localPrefixSum128VSingle( u32 pData, uint lIdx, uint* totalSum, __local u32 sorterSharedMemory[] )\n"
"{\n"
"	{	//	Set data\n"
"		sorterSharedMemory[lIdx] = 0;\n"
"		sorterSharedMemory[lIdx+WG_SIZE] = pData;\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	{	//	Prefix sum\n"
"		int idx = 2*lIdx + (WG_SIZE+1);\n"
"		if( lIdx < 64 )\n"
"		{\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-1];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-2];			\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-4];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-8];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-16];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-32];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-64];\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			sorterSharedMemory[idx-1] += sorterSharedMemory[idx-2];\n"
"			GROUP_MEM_FENCE;\n"
"		}\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	*totalSum = sorterSharedMemory[WG_SIZE*2-1];\n"
"	u32 addValue = sorterSharedMemory[lIdx+127];\n"
"	return addValue;\n"
"}\n"
"*/\n"
"//__attribute__((reqd_work_group_size(64,1,1)))\n"
"u32 localPrefixSum64VSingle( u32 pData, uint lIdx, uint* totalSum, __local u32 sorterSharedMemory[] )\n"
"{\n"
"	const int wgSize = 64;\n"
"	{	//	Set data\n"
"		sorterSharedMemory[lIdx] = 0;\n"
"		sorterSharedMemory[lIdx+wgSize] = pData;\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	{	//	Prefix sum\n"
"		int idx = 2*lIdx + (wgSize+1);\n"
"#if defined(USE_2LEVEL_REDUCE)\n"
"		if( lIdx < 64 )\n"
"		{\n"
"			u32 u0, u1, u2;\n"
"			u0 = sorterSharedMemory[idx-3];\n"
"			u1 = sorterSharedMemory[idx-2];\n"
"			u2 = sorterSharedMemory[idx-1];\n"
"			AtomAdd( sorterSharedMemory[idx], u0+u1+u2 );			\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			u0 = sorterSharedMemory[idx-12];\n"
"			u1 = sorterSharedMemory[idx-8];\n"
"			u2 = sorterSharedMemory[idx-4];\n"
"			AtomAdd( sorterSharedMemory[idx], u0+u1+u2 );			\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			u0 = sorterSharedMemory[idx-48];\n"
"			u1 = sorterSharedMemory[idx-32];\n"
"			u2 = sorterSharedMemory[idx-16];\n"
"			AtomAdd( sorterSharedMemory[idx], u0+u1+u2 );			\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			sorterSharedMemory[idx-1] += sorterSharedMemory[idx-2];\n"
"			GROUP_MEM_FENCE;\n"
"		}\n"
"#else\n"
"		if( lIdx < 64 )\n"
"		{\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-1];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-2];			\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-4];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-8];\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-16];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-32];\n"
"			GROUP_MEM_FENCE;\n"
"//			sorterSharedMemory[idx] += sorterSharedMemory[idx-64];\n"
"//			GROUP_MEM_FENCE;\n"
"\n"
"			sorterSharedMemory[idx-1] += sorterSharedMemory[idx-2];\n"
"			GROUP_MEM_FENCE;\n"
"		}\n"
"#endif\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	*totalSum = sorterSharedMemory[wgSize*2-1];\n"
"	u32 addValue = sorterSharedMemory[lIdx+wgSize-1];\n"
"	return addValue;\n"
"}\n"
"\n"
"//__attribute__((reqd_work_group_size(128,1,1)))\n"
"uint4 localPrefixSum128V( uint4 pData, uint lIdx, uint* totalSum, __local u32 sorterSharedMemory[] )\n"
"{\n"
"	const int wgSize = 128;\n"
"	{	//	Set data\n"
"		sorterSharedMemory[lIdx] = 0;\n"
"		sorterSharedMemory[lIdx+wgSize] = prefixScanVectorEx( &pData );\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	{	//	Prefix sum\n"
"		int idx = 2*lIdx + (wgSize+1);\n"
"		if( lIdx < 64 )\n"
"		{\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-1];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-2];			\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-4];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-8];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-16];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-32];\n"
"			GROUP_MEM_FENCE;\n"
"			sorterSharedMemory[idx] += sorterSharedMemory[idx-64];\n"
"			GROUP_MEM_FENCE;\n"
"\n"
"			sorterSharedMemory[idx-1] += sorterSharedMemory[idx-2];\n"
"			GROUP_MEM_FENCE;\n"
"		}\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	*totalSum = sorterSharedMemory[wgSize*2-1];\n"
"	uint addValue = sorterSharedMemory[lIdx+127];\n"
"	return pData + make_uint4(addValue, addValue, addValue, addValue);\n"
"}\n"
"\n"
"\n"
"//__attribute__((reqd_work_group_size(64,1,1)))\n"
"uint4 localPrefixSum64V( uint4 pData, uint lIdx, uint* totalSum, __local u32 sorterSharedMemory[] )\n"
"{\n"
"	u32 s4 = prefixScanVectorEx( &pData );\n"
"	u32 rank = localPrefixSum64VSingle( s4, lIdx, totalSum, sorterSharedMemory );\n"
"	return pData + make_uint4( rank, rank, rank, rank );\n"
"}\n"
"\n"
"//===\n"
"\n"
"u32 unpack4Key( u32 key, int keyIdx ){ return (key>>(keyIdx*8)) & 0xff;}\n"
"\n"
"uint4 extractKeys(uint4 data, uint targetKey)\n"
"{\n"
"	uint4 key;\n"
"	key.x = data.x == targetKey ? 1:0;\n"
"	key.y = data.y == targetKey ? 1:0;\n"
"	key.z = data.z == targetKey ? 1:0;\n"
"	key.w = data.w == targetKey ? 1:0;\n"
"	return key;\n"
"}\n"
"\n"
"//===\n"
"\n"
"\n"
"\n"
"\n"
"#define MY_HISTOGRAM(idx) localHistogramMat[(idx)*WG_SIZE+lIdx]\n"
"\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void StreamCountKernel( __global u32* gSrc, __global u32* histogramOut, ConstBuffer cb )\n"
"{\n"
"	__local u32 localHistogramMat[NUM_BUCKET*WG_SIZE];\n"
"\n"
"	u32 gIdx = GET_GLOBAL_IDX;\n"
"	u32 lIdx = GET_LOCAL_IDX;\n"
"	u32 wgIdx = GET_GROUP_IDX;\n"
"	u32 wgSize = GET_GROUP_SIZE;\n"
"	const int startBit = cb.m_startBit;\n"
"\n"
"	const int n = cb.m_n;\n"
"	const int nWGs = cb.m_nWGs;\n"
"	const int nBlocksPerWG = cb.m_nBlocksPerWG;\n"
"\n"
"	for(int i=0; i<NUM_BUCKET; i++)\n"
"	{\n"
"		MY_HISTOGRAM(i) = 0;\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	const int blockSize = ELEMENTS_PER_WORK_ITEM*WG_SIZE;\n"
"	u32 localKeys[ELEMENTS_PER_WORK_ITEM];\n"
"//	for(int addr=ELEMENTS_PER_WORK_ITEM*gIdx; addr<n; addr+=stride)\n"
"	for(int addr = blockSize*nBlocksPerWG*wgIdx+ELEMENTS_PER_WORK_ITEM*lIdx; \n"
"		addr<min(blockSize*nBlocksPerWG*(wgIdx+1), n); \n"
"		addr+=blockSize )\n"
"	{\n"
"		for(int i=0; i<ELEMENTS_PER_WORK_ITEM; i++)\n"
"			localKeys[i] = (gSrc[addr+i]>>startBit) & 0xf;\n"
"\n"
"		//	MY_HISTOGRAM( localKeys.x ) ++ is much expensive than atomic add as it requires read and write while atomics can just add\n"
"		//	Using registers didn't perform well. It seems like use localKeys to address requires a lot of alu ops\n"
"		for(int i=0; i<ELEMENTS_PER_WORK_ITEM; i++)\n"
"			AtomInc( MY_HISTOGRAM( localKeys[i] ) );\n"
"	}\n"
"\n"
"	if( lIdx < NUM_BUCKET )\n"
"	{\n"
"		u32 sum = 0;\n"
"		for(int i=0; i<GET_GROUP_SIZE; i++)\n"
"		{\n"
"			sum += localHistogramMat[lIdx*WG_SIZE+i];\n"
"		}\n"
"		histogramOut[lIdx*nWGs+wgIdx] = sum;\n"
"//		histogramOut[wgIdx*NUM_BUCKET+lIdx] = sum;\n"
"	}\n"
"}\n"
"\n"
"\n"
"#define nPerWI 16\n"
"#define nPerLane (nPerWI/4)\n"
"\n"
"//	NUM_BUCKET*nWGs < 128*nPerWI\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(128,1,1)))\n"
"void PrefixScanKernel( __global u32* wHistogram1, ConstBuffer cb )\n"
"{\n"
"	__local u32 ldsSortData[128*2];\n"
"\n"
"	u32 lIdx = GET_LOCAL_IDX;\n"
"	u32 wgIdx = GET_GROUP_IDX;\n"
"	const int nWGs = cb.m_nWGs;\n"
"\n"
"	u32 data[nPerWI];\n"
"	for(int i=0; i<nPerWI; i++)\n"
"	{\n"
"		data[i] = 0;\n"
"		if( (nPerWI*lIdx+i) < NUM_BUCKET*nWGs )\n"
"			data[i] = wHistogram1[nPerWI*lIdx+i];\n"
"	}\n"
"\n"
"	uint4 myData = make_uint4(0,0,0,0);\n"
"\n"
"	for(int i=0; i<nPerLane; i++)\n"
"	{\n"
"		myData.x += data[nPerLane*0+i];\n"
"		myData.y += data[nPerLane*1+i];\n"
"		myData.z += data[nPerLane*2+i];\n"
"		myData.w += data[nPerLane*3+i];\n"
"	}\n"
"\n"
"	uint totalSum;\n"
"	uint4 scanned = localPrefixSum128V( myData, lIdx, &totalSum, ldsSortData );\n"
"\n"
"//	for(int j=0; j<4; j++) //	somehow it introduces a lot of branches\n"
"	{	int j = 0;\n"
"		u32 sum = 0;\n"
"		for(int i=0; i<nPerLane; i++)\n"
"		{\n"
"			u32 tmp = data[nPerLane*j+i];\n"
"			data[nPerLane*j+i] = sum;\n"
"			sum += tmp;\n"
"		}\n"
"	}\n"
"	{	int j = 1;\n"
"		u32 sum = 0;\n"
"		for(int i=0; i<nPerLane; i++)\n"
"		{\n"
"			u32 tmp = data[nPerLane*j+i];\n"
"			data[nPerLane*j+i] = sum;\n"
"			sum += tmp;\n"
"		}\n"
"	}\n"
"	{	int j = 2;\n"
"		u32 sum = 0;\n"
"		for(int i=0; i<nPerLane; i++)\n"
"		{\n"
"			u32 tmp = data[nPerLane*j+i];\n"
"			data[nPerLane*j+i] = sum;\n"
"			sum += tmp;\n"
"		}\n"
"	}\n"
"	{	int j = 3;\n"
"		u32 sum = 0;\n"
"		for(int i=0; i<nPerLane; i++)\n"
"		{\n"
"			u32 tmp = data[nPerLane*j+i];\n"
"			data[nPerLane*j+i] = sum;\n"
"			sum += tmp;\n"
"		}\n"
"	}\n"
"\n"
"	for(int i=0; i<nPerLane; i++)\n"
"	{\n"
"		data[nPerLane*0+i] += scanned.x;\n"
"		data[nPerLane*1+i] += scanned.y;\n"
"		data[nPerLane*2+i] += scanned.z;\n"
"		data[nPerLane*3+i] += scanned.w;\n"
"	}\n"
"\n"
"	for(int i=0; i<nPerWI; i++)\n"
"	{\n"
"		wHistogram1[nPerWI*lIdx+i] = data[i];\n"
"	}\n"
"}\n"
"\n"
"void sort4Bits(u32 sortData[4], int startBit, int lIdx, __local u32 ldsSortData[WG_SIZE*ELEMENTS_PER_WORK_ITEM+16])\n"
"{\n"
"	for(int bitIdx=0; bitIdx<BITS_PER_PASS; bitIdx++)\n"
"	{\n"
"		u32 mask = (1<<bitIdx);\n"
"		uint4 cmpResult = make_uint4( (sortData[0]>>startBit) & mask, (sortData[1]>>startBit) & mask, (sortData[2]>>startBit) & mask, (sortData[3]>>startBit) & mask );\n"
"		uint4 prefixSum = SELECT_UINT4( make_uint4(1,1,1,1), make_uint4(0,0,0,0), cmpResult != make_uint4(0,0,0,0) );\n"
"		u32 total;\n"
"		prefixSum = localPrefixSum64V( prefixSum, lIdx, &total, ldsSortData );\n"
"//		prefixSum = localPrefixSum128V( prefixSum, lIdx, &total, ldsSortData );\n"
"\n"
"		{\n"
"			uint4 localAddr = make_uint4(lIdx*4+0,lIdx*4+1,lIdx*4+2,lIdx*4+3);\n"
"			uint4 dstAddr = localAddr - prefixSum + make_uint4( total, total, total, total );\n"
"			dstAddr = SELECT_UINT4( prefixSum, dstAddr, cmpResult != make_uint4(0, 0, 0, 0) );\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"			ldsSortData[dstAddr.x] = sortData[0];\n"
"			ldsSortData[dstAddr.y] = sortData[1];\n"
"			ldsSortData[dstAddr.z] = sortData[2];\n"
"			ldsSortData[dstAddr.w] = sortData[3];\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"			sortData[0] = ldsSortData[localAddr.x];\n"
"			sortData[1] = ldsSortData[localAddr.y];\n"
"			sortData[2] = ldsSortData[localAddr.z];\n"
"			sortData[3] = ldsSortData[localAddr.w];\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"void sort4Bits1(u32 sortData[4], int startBit, int lIdx, __local u32* ldsSortData)\n"
"{\n"
"	for(uint ibit=0; ibit<BITS_PER_PASS; ibit+=2)\n"
"	{\n"
"		uint4 b = make_uint4((sortData[0]>>(startBit+ibit)) & 0x3, \n"
"			(sortData[1]>>(startBit+ibit)) & 0x3, \n"
"			(sortData[2]>>(startBit+ibit)) & 0x3, \n"
"			(sortData[3]>>(startBit+ibit)) & 0x3);\n"
"\n"
"		u32 key4;\n"
"		u32 sKeyPacked[4] = { 0, 0, 0, 0 };\n"
"		{\n"
"			sKeyPacked[0] |= 1<<(8*b.x);\n"
"			sKeyPacked[1] |= 1<<(8*b.y);\n"
"			sKeyPacked[2] |= 1<<(8*b.z);\n"
"			sKeyPacked[3] |= 1<<(8*b.w);\n"
"\n"
"			key4 = sKeyPacked[0] + sKeyPacked[1] + sKeyPacked[2] + sKeyPacked[3];\n"
"		}\n"
"\n"
"		u32 rankPacked;\n"
"		u32 sumPacked;\n"
"		{\n"
"			rankPacked = localPrefixSum64VSingle( key4, lIdx, &sumPacked, ldsSortData );\n"
"		}\n"
"\n"
"		GROUP_LDS_BARRIER;\n"
"\n"
"		u32 sum[4] = { unpack4Key( sumPacked,0 ), unpack4Key( sumPacked,1 ), unpack4Key( sumPacked,2 ), unpack4Key( sumPacked,3 ) };\n"
"\n"
"		{\n"
"			u32 sum4 = 0;\n"
"			for(int ie=0; ie<4; ie++)\n"
"			{\n"
"				u32 tmp = sum[ie];\n"
"				sum[ie] = sum4;\n"
"				sum4 += tmp;\n"
"			}\n"
"		}\n"
"\n"
"		u32 newOffset[4] = { 0,0,0,0 };\n"
"\n"
"		for(int ie=0; ie<4; ie++)\n"
"		{\n"
"			uint4 key = extractKeys( b, ie );\n"
"			uint4 scannedKey = key;\n"
"			prefixScanVectorEx( &scannedKey );\n"
"			uint offset = sum[ie] + unpack4Key( rankPacked, ie );\n"
"			uint4 dstAddress = make_uint4( offset, offset, offset, offset ) + scannedKey;\n"
"\n"
"			newOffset[0] += dstAddress.x*key.x;\n"
"			newOffset[1] += dstAddress.y*key.y;\n"
"			newOffset[2] += dstAddress.z*key.z;\n"
"			newOffset[3] += dstAddress.w*key.w;\n"
"		}\n"
"\n"
"\n"
"\n"
"		{\n"
"			ldsSortData[newOffset[0]] = sortData[0];\n"
"			ldsSortData[newOffset[1]] = sortData[1];\n"
"			ldsSortData[newOffset[2]] = sortData[2];\n"
"			ldsSortData[newOffset[3]] = sortData[3];\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"			sortData[0] = ldsSortData[lIdx*4+0];\n"
"			sortData[1] = ldsSortData[lIdx*4+1];\n"
"			sortData[2] = ldsSortData[lIdx*4+2];\n"
"			sortData[3] = ldsSortData[lIdx*4+3];\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel\n"
"__attribute__((reqd_work_group_size(WG_SIZE,1,1)))\n"
"void SortAndScatterKernel( __global u32* restrict gSrc, __global u32* rHistogram, __global u32* restrict gDst, ConstBuffer cb )\n"
"{\n"
"	__local u32 ldsSortData[WG_SIZE*ELEMENTS_PER_WORK_ITEM+16];\n"
"	__local u32 localHistogramToCarry[NUM_BUCKET];\n"
"	__local u32 localHistogram[NUM_BUCKET*2];\n"
"\n"
"\n"
"	u32 gIdx = GET_GLOBAL_IDX;\n"
"	u32 lIdx = GET_LOCAL_IDX;\n"
"	u32 wgIdx = GET_GROUP_IDX;\n"
"	u32 wgSize = GET_GROUP_SIZE;\n"
"\n"
"	const int n = cb.m_n;\n"
"	const int nWGs = cb.m_nWGs;\n"
"	const int startBit = cb.m_startBit;\n"
"	const int nBlocksPerWG = cb.m_nBlocksPerWG;\n"
"\n"
"	if( lIdx < (NUM_BUCKET) )\n"
"	{\n"
"		localHistogramToCarry[lIdx] = rHistogram[lIdx*nWGs + wgIdx];\n"
"	}\n"
"\n"
"	GROUP_LDS_BARRIER;\n"
"\n"
"	const int blockSize = ELEMENTS_PER_WORK_ITEM*WG_SIZE;\n"
"//	for(int addr=ELEMENTS_PER_WORK_ITEM*gIdx; addr<n; addr+=stride)\n"
"	for(int addr = blockSize*nBlocksPerWG*wgIdx+ELEMENTS_PER_WORK_ITEM*lIdx; \n"
"		addr<min(blockSize*nBlocksPerWG*(wgIdx+1), n); \n"
"		addr+=blockSize )\n"
"	{\n"
"		u32 myHistogram = 0;\n"
"\n"
"		u32 sortData[ELEMENTS_PER_WORK_ITEM];\n"
"		{\n"
"			for(int i=0; i<ELEMENTS_PER_WORK_ITEM; i++)\n"
"				sortData[i] = gSrc[ addr+i ];\n"
"		}\n"
"\n"
"		sort4Bits1(sortData, startBit, lIdx, ldsSortData);\n"
"\n"
"		u32 keys[4];\n"
"		for(int i=0; i<4; i++)\n"
"			keys[i] = (sortData[i]>>startBit) & 0xf;\n"
"\n"
"		{	//	create histogram\n"
"			if( lIdx < NUM_BUCKET )\n"
"			{\n"
"				localHistogram[lIdx] = 0;\n"
"				localHistogram[NUM_BUCKET+lIdx] = 0;\n"
"			}\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"			AtomInc( localHistogram[NUM_BUCKET+keys[0]] );\n"
"			AtomInc( localHistogram[NUM_BUCKET+keys[1]] );\n"
"			AtomInc( localHistogram[NUM_BUCKET+keys[2]] );\n"
"			AtomInc( localHistogram[NUM_BUCKET+keys[3]] );\n"
"			\n"
"			GROUP_LDS_BARRIER;\n"
"			\n"
"			uint hIdx = NUM_BUCKET+lIdx;\n"
"			if( lIdx < NUM_BUCKET )\n"
"			{\n"
"				myHistogram = localHistogram[hIdx];\n"
"			}\n"
"			GROUP_LDS_BARRIER;\n"
"\n"
"#if defined(USE_2LEVEL_REDUCE)\n"
"			if( lIdx < NUM_BUCKET )\n"
"			{\n"
"				localHistogram[hIdx] = localHistogram[hIdx-1];\n"
"				GROUP_MEM_FENCE;\n"
"\n"
"				u32 u0, u1, u2;\n"
"				u0 = localHistogram[hIdx-3];\n"
"				u1 = localHistogram[hIdx-2];\n"
"				u2 = localHistogram[hIdx-1];\n"
"				AtomAdd( localHistogram[hIdx], u0 + u1 + u2 );\n"
"				GROUP_MEM_FENCE;\n"
"				u0 = localHistogram[hIdx-12];\n"
"				u1 = localHistogram[hIdx-8];\n"
"				u2 = localHistogram[hIdx-4];\n"
"				AtomAdd( localHistogram[hIdx], u0 + u1 + u2 );\n"
"				GROUP_MEM_FENCE;\n"
"			}\n"
"#else\n"
"			if( lIdx < NUM_BUCKET )\n"
"			{\n"
"				localHistogram[hIdx] = localHistogram[hIdx-1];\n"
"				GROUP_MEM_FENCE;\n"
"				localHistogram[hIdx] += localHistogram[hIdx-1];\n"
"				GROUP_MEM_FENCE;\n"
"				localHistogram[hIdx] += localHistogram[hIdx-2];\n"
"				GROUP_MEM_FENCE;\n"
"				localHistogram[hIdx] += localHistogram[hIdx-4];\n"
"				GROUP_MEM_FENCE;\n"
"				localHistogram[hIdx] += localHistogram[hIdx-8];\n"
"				GROUP_MEM_FENCE;\n"
"			}\n"
"#endif\n"
"\n"
"			GROUP_LDS_BARRIER;\n"
"		}\n"
"\n"
"		{\n"
"			for(int ie=0; ie<ELEMENTS_PER_WORK_ITEM; ie++)\n"
"			{\n"
"				int dataIdx = 4*lIdx+ie;\n"
"				int binIdx = keys[ie];\n"
"				int groupOffset = localHistogramToCarry[binIdx];\n"
"				int myIdx = dataIdx - localHistogram[NUM_BUCKET+binIdx];\n"
"				gDst[ groupOffset + myIdx ] = sortData[ie];\n"
"			}\n"
"		}\n"
"\n"
"		GROUP_LDS_BARRIER;\n"
"\n"
"		if( lIdx < NUM_BUCKET )\n"
"		{\n"
"			localHistogramToCarry[lIdx] += myHistogram;\n"
"		}\n"
"		GROUP_LDS_BARRIER;\n"
"\n"
"	}\n"
"}\n"
"\n"
;
